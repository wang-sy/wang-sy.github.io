<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python图像处理笔记-八-针孔照相机模型与照相机标定</title>
    <url>/2020/04/24/python%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0-%E5%85%AB-%E9%92%88%E5%AD%94%E7%85%A7%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%85%A7%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>python图像处理笔记-七-图像扭曲与配准</title>
    <url>/2020/04/19/python%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0-%E4%B8%83-%E5%9B%BE%E5%83%8F%E6%89%AD%E6%9B%B2%E4%B8%8E%E9%85%8D%E5%87%86/</url>
    <content><![CDATA[<h1 id="python图像处理笔记-七-图像扭曲与配准">python图像处理笔记-七-图像扭曲与配准</h1>
<p>对图像块使用仿射变换，我们将其称为图像扭曲。该操作不仅出现在计算机图形学中，还出现在计算机视觉算法中，扭曲可以用scipy的ndimage完成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transformedIm = ndimage.affine_transform(im, A, b, size)</span><br></pre></td></tr></table></figure>
<p>使用如上所示的线性变换A和一个平移向量B来对图像块进行仿射变换。选择参数size可以用来指定输出图像的大小。默认输出图像设置为和原始图像同样大小。为研究该函数是如何工作的，我们运行以下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	im = array(Image.open(<span class="string">'imgs/timg.jpg'</span>).convert(<span class="string">'L'</span>))</span><br><span class="line">	H  = array([[<span class="number">1.4</span>, <span class="number">0.05</span>, <span class="number">-100</span>], [<span class="number">0.05</span>, <span class="number">1.5</span>, <span class="number">-100</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">	im2= ndimage.affine_transform(im, H[:<span class="number">2</span>, :<span class="number">2</span>],(H[<span class="number">0</span>,<span class="number">2</span>], H[<span class="number">1</span>,<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line">	figure()</span><br><span class="line">	gray()</span><br><span class="line">	imshow(im2)</span><br><span class="line">	show()</span><br></pre></td></tr></table></figure>
<p>在这里，我们把之前那张铁塔的图做了一个扭曲，实质上我们用到的方法就是上一节讲到的仿射变换，其中，我们使用到的A、T矩阵是： <span class="math display">\[
\left[
\begin{matrix}
1.4 &amp;0.05 &amp;-100\\
0.05 &amp;1.5 &amp; -100\\
0 &amp; 0 &amp; 1
\end{matrix}
\right]
\]</span> 其中，旋转缩放矩阵与平移矩阵分别为： <span class="math display">\[
A = 
\left[
\begin{matrix}
1.4 &amp;0.05 \\
0.05 &amp;1.5 
\end{matrix}
\right]
, T =  
\left[
\begin{matrix}
-100 \\
-100
\end{matrix}
\right]
\]</span> 图像经过扭曲后，输出如下，其中丢失的值使用零来填充：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/图像处理7后/图像处理7/Figure_1.png" /></p>
<p>接下来我们来简单地看一下这个ndimage.affine_transform(im, A, b, size)函数：</p>
<ul>
<li>im ： 需要进行变换的图像</li>
<li>A ：我们上面给出的A矩阵，主要负责图像的旋转、缩放等等</li>
<li>b ： 我们上面给出的T，负责图像的平移</li>
<li>size ： 目前还不知道</li>
</ul>
<h2 id="图像中的图像">图像中的图像</h2>
<p>放射扭曲的一个简单例子是：将图像或者图像的一部分放置在另一幅图像中，使他们能够和指定的区域或者标记物对齐。下面我们搞一个函数，它的输入参数是两幅图像和一个坐标，该坐标为第一幅图像放置第二幅图像中角点的坐标：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imageInImage</span><span class="params">(im1, im2, tp)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	使用仿射变换将im1放置在im2上，使im1 图像的角点和tp尽可能靠近</span></span><br><span class="line"><span class="string">	tp是齐次坐标，按照从左上角逆时针计算的</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment"># 扭曲的点</span></span><br><span class="line">	m, n = im1.shape[:<span class="number">2</span>]</span><br><span class="line">	fp = array([[<span class="number">0</span>, m, m, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, n, n], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 计算仿射变换,并将其用于图像im1</span></span><br><span class="line">	<span class="comment"># 这里掉了我们上个程序中写的包</span></span><br><span class="line">	H = homoraphy.HaffineFromPoints(tp, fp)</span><br><span class="line">	im1T = ndimage.affine_transform(im1, H[:<span class="number">2</span>, :<span class="number">2</span>], (H[<span class="number">0</span>, <span class="number">2</span>], H[<span class="number">1</span>, <span class="number">2</span>]),im2.shape[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">	alpha = (im1T &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1</span> - alpha) * im2 + alpha * im1T</span><br></pre></td></tr></table></figure>
<p>现在我们的目标是这个样子的：</p>
<p>我们现在有两张图片：</p>
<p>第一张是我们的这个网页</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%867%E5%90%8E/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%867/2020-04-16%2022-02-42%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" style="zoom: 40%;" /></p>
<p>第二张是我们从网上下载到的一个电脑的图片：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/图像处理7后/图像处理7/Jindong.jpg" style="zoom: 50%;" /></p>
<p>我们说，看这个星空多没意思，看我们博客的话，这个显示器的销量肯定能涨，那么接下来我们要把我们的博客加上去。首先，我们使用matplotlib.pyplot将这个电脑的图片打印出来，进行选点，当然了，如果我们每次都要重新手工取点，还要再更改程序的话，未免就有些太繁琐了，所以我们选用ginput()函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPoints</span><span class="params">(image, pointNum = <span class="number">4</span>, isChange = True)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	在image中取pointNum个点，如果ischange的话，那么就将点转换成齐次坐标</span></span><br><span class="line"><span class="string">	最终返回获取到的点</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	figure()</span><br><span class="line">	gray()</span><br><span class="line">	imshow(im)</span><br><span class="line">	tempPoints = ginput(pointNum) <span class="comment"># 取点</span></span><br><span class="line">	x = []</span><br><span class="line">	y = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> tempPoints:</span><br><span class="line">		x.append(i[<span class="number">0</span>])</span><br><span class="line">		y.append(i[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">if</span>(isChange == <span class="literal">True</span>):</span><br><span class="line">		points = homoraphy.makeHomog(array([x,y])) <span class="comment"># 将点转换成齐次坐标</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> points</span><br></pre></td></tr></table></figure>
<p>运行该函数，我们可以在图像中选四个点：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/图像处理7后/图像处理7/2020-04-16 22-20-22 的屏幕截图.png" style="zoom:50%;" /></p>
<p>选完四个点后，我们会将四个点的齐次坐标记录下来：</p>
<blockquote>
<p>[[ 75.80458427 79.67916676 707.70405211 706.01624668] [151.9661478 518.80662682 526.25148681 107.01198678] [ 1. 1. 1. 1. ]]</p>
</blockquote>
<p>最终我们将其次坐标导入我们的函数，即可完成我们想要的效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</span><br><span class="line"><span class="keyword">import</span> homoraphy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imageInImage</span><span class="params">(im1, im2, tp)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	使用仿射变换将im1放置在im2上，使im1 图像的角点和tp尽可能靠近</span></span><br><span class="line"><span class="string">	tp是齐次坐标，按照从左上角逆时针计算的</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment"># 扭曲的点</span></span><br><span class="line">	m, n = im1.shape[:<span class="number">2</span>]</span><br><span class="line">	fp = array([[<span class="number">0</span>, m, m, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, n, n], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 计算仿射变换,并将其用于图像im1</span></span><br><span class="line">	<span class="comment"># 这里掉了我们上个程序中写的包</span></span><br><span class="line">	H = homoraphy.HaffineFromPoints(tp, fp)</span><br><span class="line">	im1T = ndimage.affine_transform(im1, H[:<span class="number">2</span>, :<span class="number">2</span>], (H[<span class="number">0</span>, <span class="number">2</span>], H[<span class="number">1</span>, <span class="number">2</span>]),im2.shape[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">	alpha = (im1T &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1</span> - alpha) * im2 + alpha * im1T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPoints</span><span class="params">(image, pointNum = <span class="number">4</span>, isChange = True)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	在image中取pointNum个点，如果ischange的话，那么就将点转换成齐次坐标</span></span><br><span class="line"><span class="string">	最终返回获取到的点</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	figure()</span><br><span class="line">	gray()</span><br><span class="line">	imshow(image)</span><br><span class="line">	tempPoints = ginput(pointNum) <span class="comment"># 取点</span></span><br><span class="line">	x = []</span><br><span class="line">	y = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> tempPoints:</span><br><span class="line">		y.append(i[<span class="number">0</span>])</span><br><span class="line">		x.append(i[<span class="number">1</span>])</span><br><span class="line">	<span class="keyword">if</span>(isChange == <span class="literal">True</span>):</span><br><span class="line">		points = homoraphy.makeHomog(array([x,y])) <span class="comment"># 将点转换成齐次坐标</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> points</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	toImg = array(Image.open(<span class="string">'imgs/Jindong.jpg'</span>).convert(<span class="string">'L'</span>))</span><br><span class="line">	fromImg = array(Image.open(<span class="string">'imgs/screen.png'</span>).convert(<span class="string">'L'</span>))</span><br><span class="line">	points = getPoints(toImg)</span><br><span class="line">	finalImg = imageInImage(fromImg, toImg, points)</span><br><span class="line">	figure()</span><br><span class="line">	gray()</span><br><span class="line">	imshow(finalImg)</span><br><span class="line">	show()</span><br></pre></td></tr></table></figure>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/图像处理7后/图像处理7/2020-04-16 22-25-31 的屏幕截图.png" style="zoom:67%;" /></p>
<p>emm，还是有一些问题的，如果京东用了我们的照片的话，恐怕这款我最喜欢的显示器就要凉了，但是为了印证我们算法的准确性，我们还是需要找一张图片来找回点场子的：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/图像处理7后/图像处理7/Jindong2.jpg" style="zoom:50%;" /></p>
<p>我们按照刚才的方法，将我们博客的图片帖进去：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/图像处理7后/图像处理7/2020-04-16 22-32-28 的屏幕截图.png" style="zoom:50%;" /></p>
<p>很好，这样的话，这款电脑的销量又被我们保住了，我们可真是“犹如天上降魔主,真是人间太岁神”这个算法，nb。但是又由此产生了一个疑问：为什么同一款显示器，对我的博客兼容性不一样呢？我们不难发现，这是由图像的<strong>透视效应</strong>决定的，很明显，正放的显示器透视效应不强，而刚才侧放的显示器透视效果就很强，那么我们再问自己，为什么会有透视效应？</p>
<p>很明显，所谓透视就是进大远小，而我们的博客，实际上是一个方方正正的矩形。而我们的仿射变换能够做到的只有：</p>
<ul>
<li>平移、旋转、放缩、剪切、反射</li>
</ul>
<p>下面有一张图非常形象的告诉我们，仿射变换能够干什么：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/图像处理7后/图像处理7/myimg.png" style="zoom:67%;" /></p>
<p>很明显，这些性质都直接的无法与进大远小联系起来，所以我们说：</p>
<ul>
<li>在具有很强透视效应的情况下，我们不可能使用同一个射影变换输出图像的情况。在这种情况下，我们不可能使用同一个仿射变换将全部四个角点变换到他们的目标位置。</li>
</ul>
<p>对于这种情况，有一个很好的方法：</p>
<ul>
<li>对于三个点，仿射变换可以将一幅图像进行扭曲，使这三对对应点可以玩美的匹配上，这是因为，仿射变换有6个自由度，三个对应点可以给出六个约束条件。所以如果在上述情况下，你可以将图像分解为两个三角形，然后分别对他们进行扭曲图像操作：</li>
</ul>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</span><br><span class="line"><span class="keyword">import</span> homoraphy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imageInImage</span><span class="params">(im1, im2, tp)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	使用仿射变换将im1放置在im2上，使im1 图像的角点和tp尽可能靠近</span></span><br><span class="line"><span class="string">	tp是齐次坐标，按照从左上角逆时针计算的</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment"># 扭曲的点</span></span><br><span class="line">	m, n = im1.shape[:<span class="number">2</span>]</span><br><span class="line">	fp = array([[<span class="number">0</span>, m, m, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, n, n], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 计算仿射变换,并将其用于图像im1</span></span><br><span class="line">	<span class="comment"># 这里掉了我们上个程序中写的包</span></span><br><span class="line">	H = homoraphy.HaffineFromPoints(tp, fp)</span><br><span class="line">	im1T = ndimage.affine_transform(im1, H[:<span class="number">2</span>, :<span class="number">2</span>], (H[<span class="number">0</span>, <span class="number">2</span>], H[<span class="number">1</span>, <span class="number">2</span>]),im2.shape[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">	alpha = (im1T &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1</span> - alpha) * im2 + alpha * im1T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPoints</span><span class="params">(image, pointNum = <span class="number">4</span>, isChange = True)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	在image中取pointNum个点，如果ischange的话，那么就将点转换成齐次坐标</span></span><br><span class="line"><span class="string">	最终返回获取到的点</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	figure()</span><br><span class="line">	gray()</span><br><span class="line">	imshow(image)</span><br><span class="line">	tempPoints = ginput(pointNum) <span class="comment"># 取点</span></span><br><span class="line">	x = []</span><br><span class="line">	y = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> tempPoints:</span><br><span class="line">		y.append(i[<span class="number">0</span>]//<span class="number">1</span>)</span><br><span class="line">		x.append(i[<span class="number">1</span>]//<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span>(isChange == <span class="literal">True</span>):</span><br><span class="line">		points = homoraphy.makeHomog(array([x,y])) <span class="comment"># 将点转换成齐次坐标</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> points</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alphaForTriangle</span><span class="params">(points, m, n)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">		对于带有points定义角点的三角形</span></span><br><span class="line"><span class="string">		创建m，n的alpha</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	alpha = zeros((m,n))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(int(min(points[<span class="number">0</span>])),int(max(points[<span class="number">0</span>]))):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(int(min(points[<span class="number">1</span>])),int(max(points[<span class="number">1</span>]))):</span><br><span class="line">			x = linalg.solve(points, [i,j,<span class="number">1</span>])</span><br><span class="line">			<span class="keyword">if</span>(min(x) &gt; <span class="number">0</span>): <span class="comment"># 所有系数都大于0</span></span><br><span class="line">				alpha[i][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> alpha</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangleImageInImage</span><span class="params">(im1, im2, tp)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	与上面不同的是：将im1分裂为了两个三角形进行变换</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment"># 扭曲的点</span></span><br><span class="line">	m, n = im1.shape[:<span class="number">2</span>]</span><br><span class="line">	fp = array([[<span class="number">0</span>, m, m, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, n, n], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 第一个三角形，前三个点：</span></span><br><span class="line">	fp2 = fp[:,:<span class="number">3</span>]</span><br><span class="line">	tp2 = tp[:,:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 计算H</span></span><br><span class="line">	<span class="comment"># 这里掉了我们上个程序中写的包，将第一个三角形写入</span></span><br><span class="line">	H = homoraphy.HaffineFromPoints(tp2, fp2)</span><br><span class="line">	im1T = ndimage.affine_transform(im1, H[:<span class="number">2</span>, :<span class="number">2</span>], (H[<span class="number">0</span>, <span class="number">2</span>], H[<span class="number">1</span>, <span class="number">2</span>]),im2.shape[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 三角形的alpha</span></span><br><span class="line">	alpha = alphaForTriangle(tp2, im2.shape[<span class="number">0</span>], im2.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	im3 = (<span class="number">1</span> - alpha) * im2 + alpha * im1T</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 第二个三角形</span></span><br><span class="line">	fp2 = fp[:,[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">	tp2 = tp[:,[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 计算H</span></span><br><span class="line">	<span class="comment"># 这里掉了我们上个程序中写的包，将第一个三角形写入</span></span><br><span class="line">	H = homoraphy.HaffineFromPoints(tp2, fp2)</span><br><span class="line">	im1T = ndimage.affine_transform(im1, H[:<span class="number">2</span>, :<span class="number">2</span>], (H[<span class="number">0</span>, <span class="number">2</span>], H[<span class="number">1</span>, <span class="number">2</span>]),im2.shape[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 三角形的alpha</span></span><br><span class="line">	alpha = alphaForTriangle(tp2, im2.shape[<span class="number">0</span>], im2.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	im4 = (<span class="number">1</span> - alpha) * im3 + alpha * im1T</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> im4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选定im1角上的一些点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	toImg = array(Image.open(<span class="string">'imgs/Jindong.jpg'</span>).convert(<span class="string">'L'</span>))</span><br><span class="line">	fromImg = array(Image.open(<span class="string">'imgs/screen.png'</span>).convert(<span class="string">'L'</span>))</span><br><span class="line">	points = getPoints(toImg)</span><br><span class="line">	finalImg = triangleImageInImage(fromImg, toImg, points)</span><br><span class="line">	figure()</span><br><span class="line">	gray()</span><br><span class="line">	imshow(finalImg)</span><br><span class="line">	show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/图像处理7后/图像处理7/2020-04-16 22-58-23 的屏幕截图.png" style="zoom:67%;" /></p>
<p>对比刚才这个结果已经算得上是非常不错的了，但是我们发现，从三维空间考虑，我们对这个图片做的事情就是从中间对折了一下，这样就能与屏幕更适配了，但可惜的是，正是这种思想，导致两个三角形部分的缩放比不同，所以导致中间分隔线部分比较失真。但总体来说这个结果已经算得上是比较让人满意的了。</p>
<h2 id="分段仿射扭曲">分段仿射扭曲</h2>
<p>我们通过上面的例子发现，三角形图像块的仿射扭曲可以完成角点的精准匹配，然我们来看一下对应点对集合之间的最常用扭曲方式：分段放射扭曲。给定任意图像的标记点，通过将这些点进行三角形剖分，然后使用仿射扭曲来扭曲每一个三角形，我们可以将图像和另一幅图像的对应标记点扭曲对应。</p>
<p>为了三角化这些点，我们常用狄洛克三角剖分方法，下面我们简单的讲解下原理：</p>
<h3 id="delaunay三角剖分">Delaunay三角剖分</h3>
<h4 id="参考">参考</h4>
<p>WhiteAndWhite 链接：https://zhuanlan.zhihu.com/p/42331420</p>
<h4 id="三角形剖分定义">三角形剖分定义</h4>
<p>【定义】三角剖分：假设V是二维实数域上的有限点集，边e是由点集中的点作为端点构成的封闭线段, E为e的集合。那么该点集V的一个三角剖分T=(V,E)是一个平面图G，该平面图满足条件：</p>
<p>​ 1.除了端点，平面图中的边不包含点集中的任何点。</p>
<p>​ 2.没有相交边。</p>
<p>​ 3.平面图中所有的面都是三角面，且所有三角面的合集是散点集V的凸包。</p>
<h4 id="delaunay三角剖分准则">Delaunay三角剖分准则</h4>
<ol type="1">
<li><p>空圆特性：Delaunay三角网是唯一的，任意四个点不能共圆。在Delaunay三角形网中任一三角形的外接圆范围内不会有其它点存在。</p>
<p><img src="https://pic1.zhimg.com/v2-a61fa3e96f9c9f992952198abeaa73f8_b.jpg" /></p></li>
<li><p>最大化最小角特性：在散点集可能形成的三角剖分中，Delaunay三角剖分所形成的三角形的最小角最大。从这个意义上讲，Delaunay三角网是“最接近于规则化的“的三角网。具体的说是指在两个相邻的三角形构成凸四边形的对角线，在相互交换后，六个内角的最小角不再增大。如下图所示：</p>
<p><img src="https://pic3.zhimg.com/v2-0fa96f4c12895bc7a61daad441c3c586_b.jpg" /></p>
<p>下面我们来看最重要的部分</p></li>
</ol>
<h4 id="bowyer-watson算法">Bowyer-Watson算法</h4>
<p>可以看这里：https://ui-mario.github.io/2019/11/29/Bowyer-Watson</p>
<p>为了效率和易用性，我们直接使用Scipy中的轮子就可以了（书中的matplotlib的我用不通不过问题不大）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.spatial <span class="keyword">import</span> Delaunay</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line">points = array(standard_normal((<span class="number">100</span>,<span class="number">2</span>)))</span><br><span class="line">tri = Delaunay(points)</span><br><span class="line">triplot(points[:,<span class="number">0</span>], points[:,<span class="number">1</span>], tri.simplices.copy())</span><br><span class="line">plot(points[:,<span class="number">0</span>], points[:,<span class="number">1</span>], <span class="string">'o'</span>)</span><br><span class="line">axis(<span class="string">'off'</span>)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/图像处理7后/图像处理7/Figure_2.png" /></p>
<p>我们看到这里根据点生成了很多的三角形，那么这如何与我们之前的东西结合起来呢？</p>
<ul>
<li>我们知道三角形内的点能够完美的通过仿射变换被置换到其他图中</li>
<li>现在在原图中有很多点</li>
<li>原图中的点和新图中的很多点一一对应</li>
</ul>
<p>有了上面这些东西我们的思路就非常的清晰了！我们希望能够将这些点整合成很多的三角形，这样就能更加精细的扭曲过去了，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</span><br><span class="line"><span class="keyword">import</span> homoraphy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imageInImage</span><span class="params">(im1, im2, tp)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	使用仿射变换将im1放置在im2上，使im1 图像的角点和tp尽可能靠近</span></span><br><span class="line"><span class="string">	tp是齐次坐标，按照从左上角逆时针计算的</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment"># 扭曲的点</span></span><br><span class="line">	m, n = im1.shape[:<span class="number">2</span>]</span><br><span class="line">	fp = array([[<span class="number">0</span>, m, m, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, n, n], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 计算仿射变换,并将其用于图像im1</span></span><br><span class="line">	<span class="comment"># 这里掉了我们上个程序中写的包</span></span><br><span class="line">	H = homoraphy.HaffineFromPoints(tp, fp)</span><br><span class="line">	im1T = ndimage.affine_transform(im1, H[:<span class="number">2</span>, :<span class="number">2</span>], (H[<span class="number">0</span>, <span class="number">2</span>], H[<span class="number">1</span>, <span class="number">2</span>]),im2.shape[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">	alpha = (im1T &gt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">1</span> - alpha) * im2 + alpha * im1T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPoints</span><span class="params">(image, pointNum = <span class="number">4</span>, isChange = True)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	在image中取pointNum个点，如果ischange的话，那么就将点转换成齐次坐标</span></span><br><span class="line"><span class="string">	最终返回获取到的点</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	figure()</span><br><span class="line">	gray()</span><br><span class="line">	imshow(image)</span><br><span class="line">	tempPoints = ginput(pointNum) <span class="comment"># 取点</span></span><br><span class="line">	x = []</span><br><span class="line">	y = []</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> tempPoints:</span><br><span class="line">		y.append(i[<span class="number">0</span>]//<span class="number">1</span>)</span><br><span class="line">		x.append(i[<span class="number">1</span>]//<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">if</span>(isChange == <span class="literal">True</span>):</span><br><span class="line">		points = homoraphy.makeHomog(array([x,y])) <span class="comment"># 将点转换成齐次坐标</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> points</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alphaForTriangle</span><span class="params">(points, m, n)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">		对于带有points定义角点的三角形</span></span><br><span class="line"><span class="string">		创建m，n的alpha</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	alpha = zeros((m,n))</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(int(min(points[<span class="number">0</span>])),int(max(points[<span class="number">0</span>]))):</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(int(min(points[<span class="number">1</span>])),int(max(points[<span class="number">1</span>]))):</span><br><span class="line">			x = linalg.solve(points, [i,j,<span class="number">1</span>])</span><br><span class="line">			<span class="keyword">if</span>(min(x) &gt; <span class="number">0</span>): <span class="comment"># 所有系数都大于0</span></span><br><span class="line">				alpha[i][j] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> alpha</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangleImageInImage</span><span class="params">(im1, im2, tp)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	与上面不同的是：将im1分裂为了两个三角形进行变换</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment"># 扭曲的点</span></span><br><span class="line">	m, n = im1.shape[:<span class="number">2</span>]</span><br><span class="line">	fp = array([[<span class="number">0</span>, m, m, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, n, n], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 第一个三角形，前三个点：</span></span><br><span class="line">	fp2 = fp[:,:<span class="number">3</span>]</span><br><span class="line">	tp2 = tp[:,:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 计算H</span></span><br><span class="line">	<span class="comment"># 这里掉了我们上个程序中写的包，将第一个三角形写入</span></span><br><span class="line">	H = homoraphy.HaffineFromPoints(tp2, fp2)</span><br><span class="line">	im1T = ndimage.affine_transform(im1, H[:<span class="number">2</span>, :<span class="number">2</span>], (H[<span class="number">0</span>, <span class="number">2</span>], H[<span class="number">1</span>, <span class="number">2</span>]),im2.shape[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 三角形的alpha</span></span><br><span class="line">	alpha = alphaForTriangle(tp2, im2.shape[<span class="number">0</span>], im2.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	im3 = (<span class="number">1</span> - alpha) * im2 + alpha * im1T</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 第二个三角形</span></span><br><span class="line">	fp2 = fp[:,[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">	tp2 = tp[:,[<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 计算H</span></span><br><span class="line">	<span class="comment"># 这里掉了我们上个程序中写的包，将第一个三角形写入</span></span><br><span class="line">	H = homoraphy.HaffineFromPoints(tp2, fp2)</span><br><span class="line">	im1T = ndimage.affine_transform(im1, H[:<span class="number">2</span>, :<span class="number">2</span>], (H[<span class="number">0</span>, <span class="number">2</span>], H[<span class="number">1</span>, <span class="number">2</span>]),im2.shape[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 三角形的alpha</span></span><br><span class="line">	alpha = alphaForTriangle(tp2, im2.shape[<span class="number">0</span>], im2.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">	im4 = (<span class="number">1</span> - alpha) * im3 + alpha * im1T</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> im4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwAffine</span><span class="params">(fromim, toim, fp, tp, tri)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	从一幅图像中扭曲矩形图像块</span></span><br><span class="line"><span class="string">	fromim  ：将要扭曲的图像</span></span><br><span class="line"><span class="string">	toim    ：目标图像</span></span><br><span class="line"><span class="string">	fp      ：齐次坐标表示下，扭曲前的点</span></span><br><span class="line"><span class="string">	tp      ：齐次坐标表示下，扭曲后的点</span></span><br><span class="line"><span class="string">	tri     ：三角形剖分</span></span><br><span class="line"><span class="string">	:return im</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	im = toim.copy()</span><br><span class="line">	<span class="comment"># 检查图像是否是彩色图，如果三通道，那么</span></span><br><span class="line">	isColor = len(fromim.shape) == <span class="number">3</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 创建扭曲后的图像</span></span><br><span class="line">	imT = zeros(im.shape, <span class="string">'uint'</span>)</span><br><span class="line">	<span class="keyword">for</span> t <span class="keyword">in</span> tri:</span><br><span class="line">		<span class="comment"># 计算仿射变换</span></span><br><span class="line">		H = homoraphy.HaffineFromPoints(tp[:, t], fp[:, t])</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> isColor :</span><br><span class="line">			<span class="keyword">for</span> col <span class="keyword">in</span> range(fromim.shape[<span class="number">2</span>]<span class="number">-1</span>):</span><br><span class="line">				print(col)</span><br><span class="line">				imT[:, :, col] = ndimage.affine_transform(</span><br><span class="line">					fromim[:, :, col], H[:<span class="number">2</span>, :<span class="number">2</span>], (H[<span class="number">0</span>,<span class="number">2</span>], H[<span class="number">1</span>,<span class="number">2</span>]), im.shape[:<span class="number">2</span>]</span><br><span class="line">				)</span><br><span class="line">		<span class="keyword">else</span> :</span><br><span class="line">			imT = ndimage.affine_transform(</span><br><span class="line">				fromim, H[:<span class="number">2</span>, :<span class="number">2</span>], (H[<span class="number">0</span>,<span class="number">2</span>], H[<span class="number">1</span>,<span class="number">2</span>]), im.shape[:<span class="number">2</span>]</span><br><span class="line">			)</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 三角形的alpha</span></span><br><span class="line">		alpha = alphaForTriangle(tp[:, t], im.shape[<span class="number">0</span>], im.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">		<span class="comment"># 三角形加入到图像中</span></span><br><span class="line">		im[alpha &gt; <span class="number">0</span>] = imT[alpha &gt; <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> im</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三角形剖分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triangulatePoints</span><span class="params">(x,y)</span>:</span></span><br><span class="line">	<span class="keyword">from</span> scipy.spatial <span class="keyword">import</span> Delaunay</span><br><span class="line">	tri = Delaunay(c_[x,y]).simplices</span><br><span class="line">	<span class="keyword">return</span> tri</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotMesh</span><span class="params">(x, y, tri)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> t <span class="keyword">in</span> tri:</span><br><span class="line">		t_ext = [t[<span class="number">0</span>], t[<span class="number">1</span>], t[<span class="number">2</span>], t[<span class="number">0</span>]]</span><br><span class="line">		plot(x[t_ext],y[t_ext], <span class="string">'r'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	toImg = array(Image.open('imgs/Jindong.jpg').convert('L'))</span></span><br><span class="line"><span class="string">	fromImg = array(Image.open('imgs/screen.png').convert('L'))</span></span><br><span class="line"><span class="string">	points = getPoints(toImg)</span></span><br><span class="line"><span class="string">	finalImg = triangleImageInImage(fromImg, toImg, points)</span></span><br><span class="line"><span class="string">	figure()</span></span><br><span class="line"><span class="string">	gray()</span></span><br><span class="line"><span class="string">	imshow(finalImg)</span></span><br><span class="line"><span class="string">	show()</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment"># 打开图像、扭曲</span></span><br><span class="line">	fromim = array(Image.open(<span class="string">'imgs/screen.png'</span>))</span><br><span class="line">	x, y = meshgrid(range(<span class="number">7</span>), range(<span class="number">2</span>))</span><br><span class="line">	x = (fromim.shape[<span class="number">1</span>] / <span class="number">7</span>) * x.flatten()</span><br><span class="line">	y = (fromim.shape[<span class="number">0</span>] / <span class="number">2</span>) * y.flatten()</span><br><span class="line">	<span class="comment"># 三角剖分</span></span><br><span class="line">	tri = triangulatePoints(x, y)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 打开图像和目标点</span></span><br><span class="line">	im = array(Image.open(<span class="string">'imgs/Jindong.jpg'</span>))</span><br><span class="line">	imshow(im)</span><br><span class="line">	tp =ginput(<span class="number">14</span>)</span><br><span class="line">	tp = array([[i[<span class="number">0</span>],i[<span class="number">1</span>]] <span class="keyword">for</span> i <span class="keyword">in</span> tp])</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 将点转换成齐次坐标</span></span><br><span class="line">	fp = vstack((y, x, ones((<span class="number">1</span>,len(x)))))</span><br><span class="line">	tp = vstack((tp[:, <span class="number">1</span>], tp[:, <span class="number">0</span>], ones((<span class="number">1</span>,len(tp)))))</span><br><span class="line">	<span class="comment"># 扭曲三角形</span></span><br><span class="line">	im = pwAffine(fromim, im, fp, tp, tri)</span><br><span class="line">	figure()</span><br><span class="line">	gray()</span><br><span class="line">	imshow(im)</span><br><span class="line">	plotMesh(tp[<span class="number">1</span>], tp[<span class="number">0</span>], tri)</span><br><span class="line">	axis(<span class="string">'off'</span>)</span><br><span class="line">	show()</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/图像处理7后/图像处理7/2020-04-18 00-52-33 的屏幕截图.png" style="zoom:50%;" /></p>
<p>可以看到，结果依然很糟糕，但是之前的糟糕是因为技术原因而造成的，而这种糟糕是因为我手残而造成的，我们接下来多取一行点。</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/图像处理7后/图像处理7/2020-04-18 00-55-15 的屏幕截图.png" style="zoom:50%;" /></p>
<p>显然，效果更糟糕了，但显然，原因是我的手更残了。</p>
<h2 id="图像的配准">图像的配准</h2>
<p>图像配准是对图像进行变换，使变换后的图像能够在常见的坐标系中对齐。配准可以是严格配准，也可以是非严格配准。为了能够进行图像对比和更精细的图像分析，图像配准非常重要。</p>
<h3 id="第一步下载数据集">第一步：下载数据集</h3>
<p>在之前的学习中，我一直用的自己的数据，这不是因为我特立独行，而是我实在不知道这玩意从哪里下。但是到了JKface这里，我就实在没办法了。在借着找不到数据集的原因滑了两天水之后，我竟然神奇的找到了整本书的数据集，下载方式如下，直接在shell里面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://programmingcomputervision.com/downloads/pcv_data.zip</span><br></pre></td></tr></table></figure>
<p>在里面你就可以找到jkface.zip以及jkface.xml了。</p>
<h3 id="第二步xml数据读取">第二步：xml数据读取</h3>
<p>这个数据集是这个老哥每天给自己来一张自拍，在2008年拍了366天拍出来的，选一张效果如下</p>
<p><img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%867%E5%90%8E/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%867/20080129.jpg" style="zoom:50%;" /></p>
<p>更厉害的是，不知道是谁，还对这366张照片的眼睛和嘴进行了标记，标记都保存在jkface.xml中/我们要做的事情就是：计算出一个相似变换，将可以使用该变换的这些图像扭曲到一个归一化的坐标系中。为了读取XML格式的文件，需要用到xml.dom模块中的minidom，下面我们来先看一下这个xml文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">faces</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">face</span> <span class="attr">file</span>=<span class="string">"20080210.jpg"</span> <span class="attr">xf</span>=<span class="string">"127"</span> <span class="attr">xm</span>=<span class="string">"157"</span> <span class="attr">xs</span>=<span class="string">"189"</span> <span class="attr">yf</span>=<span class="string">"171"</span> <span class="attr">ym</span>=<span class="string">"247"</span> <span class="attr">ys</span>=<span class="string">"171"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">face</span> <span class="attr">file</span>=<span class="string">"20080601.jpg"</span> <span class="attr">xf</span>=<span class="string">"132"</span> <span class="attr">xm</span>=<span class="string">"156"</span> <span class="attr">xs</span>=<span class="string">"186"</span> <span class="attr">yf</span>=<span class="string">"183"</span> <span class="attr">ym</span>=<span class="string">"238"</span> <span class="attr">ys</span>=<span class="string">"166"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">face</span> <span class="attr">file</span>=<span class="string">"20080226.jpg"</span> <span class="attr">xf</span>=<span class="string">"137"</span> <span class="attr">xm</span>=<span class="string">"160"</span> <span class="attr">xs</span>=<span class="string">"183"</span> <span class="attr">yf</span>=<span class="string">"185"</span> <span class="attr">ym</span>=<span class="string">"238"</span> <span class="attr">ys</span>=<span class="string">"182"</span>/&gt;</span></span><br><span class="line">.......</span><br></pre></td></tr></table></figure>
<p>我们大概可以看出来：xml文件中记录了每个文件中左眼的坐标:<span class="math inline">\((xf,yf)\)</span>，右眼的坐标<span class="math inline">\((xs,ys)\)</span>，嘴的坐标<span class="math inline">\((xm,ym)\)</span>，下面我们对它进行读入，由于上一小节的程序太长了，所以我们新开一个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</span><br><span class="line"><span class="keyword">import</span> homoraphy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readPointsFromXML</span><span class="params">(xmlFileName)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    读取人脸的标记点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    xmldoc = minidom.parse(xmlFileName)</span><br><span class="line">    faceList = xmldoc.getElementsByTagName(<span class="string">'face'</span>)</span><br><span class="line">    faces = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> xmlFace <span class="keyword">in</span> faceList:</span><br><span class="line">        fileName = xmlFace.attributes[<span class="string">'file'</span>].value</span><br><span class="line">        xf = int(xmlFace.attributes[<span class="string">'xf'</span>].value)</span><br><span class="line">        yf = int(xmlFace.attributes[<span class="string">'yf'</span>].value)</span><br><span class="line">        xs = int(xmlFace.attributes[<span class="string">'xs'</span>].value)</span><br><span class="line">        ys = int(xmlFace.attributes[<span class="string">'ys'</span>].value)</span><br><span class="line">        xm = int(xmlFace.attributes[<span class="string">'xm'</span>].value)</span><br><span class="line">        ym = int(xmlFace.attributes[<span class="string">'ym'</span>].value)</span><br><span class="line">        faces[fileName] = array([xf, yf, xs, ys, xm, ym])</span><br><span class="line">    <span class="keyword">return</span> faces</span><br><span class="line"></span><br><span class="line">temp = readPointsFromXML(<span class="string">'C:\\Users\\wangsy\\Desktop\\opencvLearning\\jkDatas\\jkfaces.xml'</span>)</span><br><span class="line">print(temp)</span><br></pre></td></tr></table></figure>
<p>通过上面的函数，我们可以给出一个jkface.xml的路径，得到文件名与对应的坐标的字典。</p>
<h3 id="扭曲">扭曲</h3>
<p>在这个数据集中，对于每个映射前的点<span class="math inline">\((x_i,y_i)\)</span>与映射后的点<span class="math inline">\((\hat{x_i},\hat{y_i})\)</span>，它们之间的关系可以表示为： <span class="math display">\[
\left[
\begin{matrix}
    \hat{x_i}\\
    \hat{y_i}
\end{matrix}
\right]
= 
\left[
\begin{matrix}
    a &amp; -b\\
    b &amp; a
\end{matrix}
\right]
\left[
\begin{matrix}
    x_i\\
    y_i
\end{matrix}
\right]
+
\left[
\begin{matrix}
    t_x\\
    t_y
\end{matrix}
\right]
\]</span> 为什么这里的扭曲矩阵是这个样子的呢？，我们可以再来回顾一下这张图片：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zYWl5dXdhbmctYmxvZy5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vJUU1JTlCJUJFJUU1JTgzJThGJUU1JUE0JTg0JUU3JTkwJTg2Y2g2L1Z1RWc1bi5wbmc?x-oss-process=image/format,png" style="zoom:50%;" /></p>
<p>我们这里对应着图片中第二行第一列的情况，但是在此基础上可能还会在cosθ和sinθ前面加上一个系数，这就说明我们在旋转的基础上还有可能做缩放，也就是说，上面的式子包含了：</p>
<ul>
<li>旋转</li>
<li>缩放</li>
<li>平移</li>
</ul>
<p>将三个点都写成上面的样子，在合到一起就是下面的样子了： <span class="math display">\[
\left[
\begin{matrix}
    \hat{x_1}\\
    \hat{y_1}\\
    \hat{x_2}\\
    \hat{y_2}\\
    \hat{x_3}\\
    \hat{y_3}
\end{matrix}
\right]
= 
\left[
\begin{matrix}
    x_1 &amp; -y_1 &amp; 1 &amp; 0\\
    y_1 &amp; x_1 &amp; 0 &amp; 1\\
    x_2 &amp; -y_2 &amp; 1 &amp; 0\\
    y_2 &amp; x_2 &amp; 0 &amp; 1\\
    x_3 &amp; -y_3 &amp; 1 &amp; 0\\
    y_3 &amp; x_3 &amp; 0 &amp; 1
\end{matrix}
\right]
\left[
\begin{matrix}
    a\\
    b\\
    t_x\\
    t_y
\end{matrix}
\right]
\]</span> 上面我们也说了，可以使用相似矩阵的参数化表示方式： <span class="math display">\[
\left[
\begin{matrix}
    a &amp; -b\\
    b &amp; a
\end{matrix}
\right]
 = \left[
\begin{matrix}
    cos(\theta) &amp; -sin(\theta)\\
    sin(\theta) &amp; cos(\theta)
\end{matrix}
\right]
= s R
\]</span> 其中，尺度<span class="math inline">\(s = \sqrt{a^2+b^2}\)</span>，旋转矩阵为<span class="math inline">\(R\)</span>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</span><br><span class="line"><span class="keyword">import</span> homoraphy</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> linalg</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> imageio <span class="keyword">import</span> imread, imsave</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readPointsFromXML</span><span class="params">(xmlFileName)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    读取人脸的标记点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    xmldoc = minidom.parse(xmlFileName)</span><br><span class="line">    faceList = xmldoc.getElementsByTagName(<span class="string">'face'</span>)</span><br><span class="line">    faces = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> xmlFace <span class="keyword">in</span> faceList:</span><br><span class="line">        fileName = xmlFace.attributes[<span class="string">'file'</span>].value</span><br><span class="line">        xf = int(xmlFace.attributes[<span class="string">'xf'</span>].value)</span><br><span class="line">        yf = int(xmlFace.attributes[<span class="string">'yf'</span>].value)</span><br><span class="line">        xs = int(xmlFace.attributes[<span class="string">'xs'</span>].value)</span><br><span class="line">        ys = int(xmlFace.attributes[<span class="string">'ys'</span>].value)</span><br><span class="line">        xm = int(xmlFace.attributes[<span class="string">'xm'</span>].value)</span><br><span class="line">        ym = int(xmlFace.attributes[<span class="string">'ym'</span>].value)</span><br><span class="line">        faces[fileName] = array([xf, yf, xs, ys, xm, ym])</span><br><span class="line">    <span class="keyword">return</span> faces</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeRigidTransform</span><span class="params">(refPoints, points)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算用于将点对齐到参考点的RT矩阵</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    A = array([</span><br><span class="line">        [points[<span class="number">0</span>], -points[<span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">        [points[<span class="number">1</span>], points[<span class="number">0</span>], <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [points[<span class="number">2</span>], -points[<span class="number">3</span>], <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">        [points[<span class="number">3</span>], points[<span class="number">2</span>], <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [points[<span class="number">4</span>], -points[<span class="number">5</span>], <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">        [points[<span class="number">5</span>], points[<span class="number">4</span>], <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    ])</span><br><span class="line">    y = array([</span><br><span class="line">        refPoints[<span class="number">0</span>],</span><br><span class="line">        refPoints[<span class="number">1</span>],</span><br><span class="line">        refPoints[<span class="number">2</span>],</span><br><span class="line">        refPoints[<span class="number">3</span>],</span><br><span class="line">        refPoints[<span class="number">4</span>],</span><br><span class="line">        refPoints[<span class="number">5</span>]</span><br><span class="line">    ])</span><br><span class="line">    a, b, tx, ty = linalg.lstsq(A,y)[<span class="number">0</span>]</span><br><span class="line">    R = array([[a, -b], [b, a]])</span><br><span class="line">    <span class="keyword">return</span> R, tx, ty</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rigidAlignment</span><span class="params">(faces, path, plotflag = False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    严格对齐图像，并将其保存为新的图像</span></span><br><span class="line"><span class="string">    path : 决定对齐后图像的保存位置</span></span><br><span class="line"><span class="string">    设置plotflag = True可以绘制图像</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 将第一幅图像中的点作为参考点</span></span><br><span class="line">    refpoints = list(faces.values())[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用仿射变换扭曲每幅图像</span></span><br><span class="line">    <span class="keyword">for</span> face <span class="keyword">in</span> faces :</span><br><span class="line">        points = faces[face]</span><br><span class="line">        R, tx, ty = computeRigidTransform(refpoints, points)</span><br><span class="line">        T = array([[R[<span class="number">1</span>][<span class="number">1</span>], R[<span class="number">1</span>][<span class="number">0</span>]], [R[<span class="number">0</span>][<span class="number">1</span>], R[<span class="number">0</span>][<span class="number">0</span>]]])</span><br><span class="line"></span><br><span class="line">        im = array(Image.open(os.path.join(path,face)))</span><br><span class="line">        im2 = zeros(im.shape, <span class="string">'uint8'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对每个颜色通道进行扭曲</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(im.shape)):</span><br><span class="line">            im2[:,:,i] = ndimage.affine_transform(im[:,:,i], linalg.inv(T), offset=[-ty, -tx])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(plotflag):</span><br><span class="line">            imshow(im2)</span><br><span class="line">            show()</span><br><span class="line">        <span class="comment"># 剪裁边界，进行保存</span></span><br><span class="line">        h,w = im2.shape[:<span class="number">2</span>]</span><br><span class="line">        border = (w+h)//<span class="number">20</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 保存</span></span><br><span class="line">        imsave(os.path.join(path, <span class="string">'aligned\\'</span> + face), im2[border: h - border, border: w - border, :])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    xmlFileName = <span class="string">'C:\\Users\\wangsy\\Desktop\\opencvLearning\\jkDatas\\jkfaces.xml'</span></span><br><span class="line">    points = readPointsFromXML(xmlFileName)</span><br><span class="line">    rigidAlignment(points, <span class="string">'C:\\Users\\wangsy\\Desktop\\opencvLearning\\jkDatas\\jkfaces\\'</span>)</span><br></pre></td></tr></table></figure>
<p>我们展示三组配准前后图像的区别：</p>
<p>配准前：</p>
<figure>
<img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%867%E5%90%8E/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%867/image-20200419142724185.png" alt="" /><figcaption>image-20200419142724185</figcaption>
</figure>
<p>配准后：</p>
<p><img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%867%E5%90%8E/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%867/image-20200419142545586.png" /></p>
<p>可以看到图像中的人的眼睛、嘴巴是对齐了的，但是第三个图片我们感觉他的头是歪的，我个人认为造成这种现象的原因是：配准是根据人的眼睛、嘴巴来进行配准的，在这个过程可能出现以下误差：</p>
<ul>
<li>手工标记时出现误差</li>
<li>眼、嘴对齐，但脸是歪的（局部最优）</li>
</ul>
<p>为了避免该误差可以使用多个点来进行配准。</p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python图像处理笔记-六——单应性变换</title>
    <url>/2020/04/16/python%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0-%E5%85%AD%E2%80%94%E2%80%94%E5%8D%95%E5%BA%94%E6%80%A7%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="python图像处理笔记-六单应性变换">python图像处理笔记-六——单应性变换</h1>
<h2 id="齐次坐标">齐次坐标</h2>
<p>单应性变化是将一个平面内的店映射到另一个平面内的二维投影变换。本质上，单应性变换 H，按照下方的方程映射到二维的点：</p>
<p><span class="math display">\[
\left[\begin{matrix}    x&#39; \\   y&#39; \\   w&#39;\end{matrix}\right]=\left[\begin{matrix}        h_1 &amp; h_2 &amp; h_3 \\        h_4 &amp; h_5 &amp; h_6 \\        h_7 &amp; h_8 &amp; h_9\end{matrix}\right]\left[\begin{matrix}        x \\        y \\        w\end{matrix}\right]
\]</span> 我们也可以表示为： <span class="math display">\[
x&#39; = Hx 
\]</span> 对于图像平面内的点，齐次坐标是一个非常有用的表示方式。点的齐次坐标是依赖于其尺度定义的，所以以下三种表述实质上都在表示同一个二维点。 <span class="math display">\[
\begin{align}
x &amp;= [\begin{matrix} x &amp; y&amp; w\end{matrix}] \\
&amp;= [\begin{matrix} \alpha x &amp; \alpha y&amp; \alpha w\end{matrix}] \\
&amp;= [\begin{matrix} x/w &amp; y/w&amp; 1\end{matrix}]
\end{align}
\]</span></p>
<p>因此单应性矩阵H也仅依赖尺度定义，所以单应性矩阵具有八个独立的自由度。我们常用<span class="math inline">\(w = 1\)</span>来归一化点，这样点就会拥有唯一的坐标：x和y。如果你看过我写的组成原理笔记的话，你会发现这里的目的和浮点数的左归、右归那里的目的非常相似。这个额外的坐标使得我们可以简单地使用一个矩阵来表示变换。</p>
<h2 id="仿射变换">仿射变换</h2>
<p>在投影变换中，有一些特别重要的变换，如：仿射变换： <span class="math display">\[
\left[\begin{matrix}    x&#39; \\   y&#39; \\   1\end{matrix}\right]=
\left[\begin{matrix}    a_1 &amp; a_2 &amp; t_x  \\   a_3 &amp; a_4 &amp; t_y \\   0 &amp; 0 &amp; 1\end{matrix}\right]
\left[\begin{matrix}        x \\        y \\        z\end{matrix}\right]
\]</span> 或者我们也可以写作： <span class="math display">\[
x&#39; = \left[\begin{matrix}A &amp; t \\ 0 &amp; 1\end{matrix}\right] x
\]</span> 我们来实现一下这个仿射变换的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(points)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	在齐次坐标意义下：</span></span><br><span class="line"><span class="string">	对点进行归一化，使得最后一行为1</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="keyword">for</span> row <span class="keyword">in</span> points:</span><br><span class="line">		row = points[<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> points</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeHomog</span><span class="params">(points)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	将点集(dim * n)的数组转化为齐次坐标表示</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="keyword">return</span> vstack((points, ones((<span class="number">1</span>, points.shape[<span class="number">1</span>]))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 仿射变换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flact</span><span class="params">(points, rtMatrix)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> np.dot(rtMatrix, points)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotPoints</span><span class="params">(points, color = None, line = True)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	给出一堆点，把他们画出来，并且显示</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(points.shape[<span class="number">1</span>]):</span><br><span class="line">		<span class="keyword">if</span>(color == <span class="literal">None</span>):</span><br><span class="line">			scatter(points[<span class="number">0</span>][i], points[<span class="number">1</span>][i])</span><br><span class="line">		<span class="keyword">else</span> :</span><br><span class="line">			scatter(points[<span class="number">0</span>][i], points[<span class="number">1</span>][i], c= color[i])</span><br><span class="line">	<span class="keyword">if</span>(line == <span class="literal">False</span> ):</span><br><span class="line">		<span class="keyword">return</span> </span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(points.shape[<span class="number">1</span>]):</span><br><span class="line">		nextPoint = (i + <span class="number">1</span>)%points.shape[<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">if</span>(color == <span class="literal">None</span>):</span><br><span class="line">			plot([points[<span class="number">0</span>][i],points[<span class="number">1</span>][i]],[points[<span class="number">0</span>][nextPoint],points[<span class="number">1</span>][nextPoint]])</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			plot([points[<span class="number">0</span>][i],points[<span class="number">1</span>][i]], [points[<span class="number">0</span>][nextPoint],points[<span class="number">1</span>][nextPoint]], c= color[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">	pointX = [<span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>]</span><br><span class="line">	pointY = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">	color = [<span class="string">'r'</span>,<span class="string">'g'</span>,<span class="string">'b'</span>,<span class="string">'m'</span>]</span><br><span class="line">	Points = array([pointX, pointY])</span><br><span class="line">	Points = makeHomog(Points)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 绘制变换之前的点</span></span><br><span class="line">	plotPoints(Points, color)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 仿射变换矩阵</span></span><br><span class="line">	rtMatrix = array(</span><br><span class="line">		[[<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">		[<span class="number">0</span>,<span class="number">0.5</span>,<span class="number">0</span>],</span><br><span class="line">		[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">		)</span><br><span class="line">	changedPoints = flact(Points, rtMatrix)</span><br><span class="line">	plotPoints(changedPoints, color)</span><br><span class="line">	show()</span><br></pre></td></tr></table></figure>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/图像处理ch6/2020-04-16 17-34-36 的屏幕截图.png" style="zoom:33%;" /> 上面的图像中我们对左边的图像使用矩阵： <span class="math display">\[
\left[
\begin{matrix}
0.5 &amp;0 &amp;0\\
0 &amp;0.5 &amp; 0\\
0 &amp; 0 &amp; 1
\end{matrix}
\right]
\]</span> 进行仿射变换，我们发现图像变小了，于是我们知道左边的A可以控制图像的大小。随后，我们将矩阵修改为： <span class="math display">\[
\left[\begin{matrix}0.5 &amp;0 &amp;1\\0 &amp;0.5 &amp; 1\\0 &amp; 0 &amp; 1\end{matrix}\right]
\]</span></p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86ch6/2020-04-16%2017-37-32%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" style="zoom:33%;" /> 我们发现之前说的T能够控制图像的平移，实际上它还可以控制图像的旋转等，我在网上看到一张图，和大家分享一下： <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zYWl5dXdhbmctYmxvZy5vc3MtY24tYmVpamluZy5hbGl5dW5jcy5jb20vJUU1JTlCJUJFJUU1JTgzJThGJUU1JUE0JTg0JUU3JTkwJTg2Y2g2L1Z1RWc1bi5wbmc?x-oss-process=image/format,png" /></p>
<p>除此之外还有<strong>相似变换</strong>，相似变换是一种特殊的仿射变换，他描述了图像的旋转、平移、缩放，可以表示为：</p>
<p><span class="math display">\[
\left[
\begin{matrix}
x&#39;\\
y&#39;\\
1
\end{matrix}
\right]  = 
 \left[
\begin{matrix}
s *cos(\theta) &amp; -s *sin(\theta) &amp; t_x\\
s *sin(\theta) &amp; -s *cos(\theta) &amp; t_x\\
0&amp;0 &amp; 1
\end{matrix}
\right]
\left[
\begin{matrix}
x\\
y\\
1
\end{matrix}
\right]
\]</span></p>
<h2 id="直接线性变换算法">直接线性变换算法</h2>
<p>单应性矩阵可以由两幅图像中对应点计算出来。一个完全摄影变换有8个自由度。根据对应点约束，每个对应点可以写出两个方程，分别对应于<span class="math inline">\(x,y\)</span>坐标。因此计算单应性矩阵H需要四个对应点对。</p>
<p>DLT(Diret Linear Transformation, 直接线性相似变化)是给定4个或者更多对应点对矩阵，来计算单应性矩阵H的方法。将单应性矩阵H作用在对应点上，重新写出该方程，我们可以得到下方方程：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/图像处理ch6/749F6C7D5FCC111FCB38104FA5157836.jpg" style="zoom:33%;" /></p>
<p>我们可以看到，实际上用一组也可以解出结果，但是为了解的稳定，我们最好使用四组以上的特征匹配。方程的最小二乘解有一个既定的结论，即对A进行SVD分解，A的最小的奇异值对应的右奇异向量即是h的解。对h做reshape得到H。</p>
<p>直接线性变换算法在普通情况下，有八个自由度，而在解决仿射变换时，只有六个自由度，我们分别对两种情况写了代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(points)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    在齐次坐标意义下：</span></span><br><span class="line"><span class="string">    对点进行归一化，使得最后一行为1</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> points:</span><br><span class="line">        row = points[<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> points</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeHomog</span><span class="params">(points)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    将点集(dim * n)的数组转化为齐次坐标表示</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> vstack((points, ones((<span class="number">1</span>, points.shape[<span class="number">1</span>]))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 仿射变换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flact</span><span class="params">(points, rtMatrix)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.dot(rtMatrix, points)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotPoints</span><span class="params">(ax, points, color=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    给出一堆点，把他们画出来，并且显示</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    xlim(<span class="number">-1</span>, <span class="number">5</span>)</span><br><span class="line">    ylim(<span class="number">-1</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(points.shape[<span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">if</span> (color == <span class="literal">None</span>):</span><br><span class="line">            ax.scatter(points[<span class="number">0</span>][i], points[<span class="number">1</span>][i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ax.scatter(points[<span class="number">0</span>][i], points[<span class="number">1</span>][i], c=color[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotTwoPoints</span><span class="params">(points1, points2)</span>:</span></span><br><span class="line">    fig = figure()</span><br><span class="line">    ax1 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    plotPoints(ax1, points1)</span><br><span class="line">    ax2 = fig.add_subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    plotPoints(ax2, points2)</span><br><span class="line">    show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hFromPoints</span><span class="params">(fp, tp)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用线性DLT，计算H，点自动进行归一化</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    输入：</span></span><br><span class="line"><span class="string">        fp : 起始点</span></span><br><span class="line"><span class="string">        tp : 经过H映射到的点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 形状不同</span></span><br><span class="line">    <span class="keyword">if</span> fp.shape != tp.shape:</span><br><span class="line">        <span class="keyword">return</span> RuntimeError(<span class="string">'number of points do not match'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对点进行归一化处理</span></span><br><span class="line">    <span class="comment"># 映射起始点</span></span><br><span class="line">    m = mean(fp[:<span class="number">2</span>], axis=<span class="number">1</span>)</span><br><span class="line">    maxstd = max(std(fp[:<span class="number">2</span>], axis=<span class="number">1</span>)) + <span class="number">1e-9</span></span><br><span class="line">    C1 = diag([<span class="number">1</span> / maxstd, <span class="number">1</span> / maxstd, <span class="number">1</span>])</span><br><span class="line">    C1[<span class="number">0</span>][<span class="number">2</span>] = -m[<span class="number">0</span>] / maxstd</span><br><span class="line">    C1[<span class="number">1</span>][<span class="number">2</span>] = -m[<span class="number">1</span>] / maxstd</span><br><span class="line">    fp = dot(C1, fp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 映射对应点</span></span><br><span class="line">    m = mean(tp[:<span class="number">2</span>], axis=<span class="number">1</span>)</span><br><span class="line">    maxstd = max(std(tp[:<span class="number">2</span>], axis=<span class="number">1</span>)) + <span class="number">1e-9</span></span><br><span class="line">    C2 = diag([<span class="number">1</span> / maxstd, <span class="number">1</span> / maxstd, <span class="number">1</span>])</span><br><span class="line">    C2[<span class="number">0</span>][<span class="number">2</span>] = -m[<span class="number">0</span>] / maxstd</span><br><span class="line">    C2[<span class="number">1</span>][<span class="number">2</span>] = -m[<span class="number">1</span>] / maxstd</span><br><span class="line">    tp = dot(C2, tp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建用于线性方法的矩阵，对于每个对应对，在矩阵中会出现两行数值</span></span><br><span class="line">    nbrCorreSponDences = fp.shape[<span class="number">1</span>]</span><br><span class="line">    A = zeros((<span class="number">2</span> * nbrCorreSponDences, <span class="number">9</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nbrCorreSponDences):</span><br><span class="line">        A[<span class="number">2</span>*i] = [-fp[<span class="number">0</span>][i], -fp[<span class="number">1</span>][i], <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                  tp[<span class="number">0</span>][i]*fp[<span class="number">0</span>][i],tp[<span class="number">0</span>][i]*fp[<span class="number">1</span>][i], tp[<span class="number">0</span>][i]]</span><br><span class="line">        A[<span class="number">2</span> * i + <span class="number">1</span>] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, -fp[<span class="number">0</span>][i], -fp[<span class="number">1</span>][i], <span class="number">-1</span>,</span><br><span class="line">                    tp[<span class="number">1</span>][i] * fp[<span class="number">0</span>][i], tp[<span class="number">1</span>][i] * fp[<span class="number">1</span>][i], tp[<span class="number">1</span>][i]]</span><br><span class="line"></span><br><span class="line">    U, S, V = linalg.svd(A)</span><br><span class="line">    H = V[<span class="number">8</span>].reshape((<span class="number">3</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="comment"># 反归一化</span></span><br><span class="line">    H = dot(linalg.inv(C2), dot(H,C1))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 归一化，返回</span></span><br><span class="line">    <span class="keyword">return</span> H / H[<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HaffineFromPoints</span><span class="params">(fp, tp)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算H，仿射变换，使得 tp, fp 是经过仿射变换H 得到的，</span></span><br><span class="line"><span class="string">    与上面不同的是，仿射变换是只有六个自由度的，也就是说，h7=h8=0</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 形状不同</span></span><br><span class="line">    <span class="keyword">if</span> fp.shape != tp.shape:</span><br><span class="line">        <span class="keyword">return</span> RuntimeError(<span class="string">'number of points do not match'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对点进行归一化处理</span></span><br><span class="line">    <span class="comment"># 映射起始点</span></span><br><span class="line">    m = mean(fp[:<span class="number">2</span>], axis=<span class="number">1</span>)</span><br><span class="line">    maxstd = max(std(fp[:<span class="number">2</span>], axis=<span class="number">1</span>)) + <span class="number">1e-9</span></span><br><span class="line">    C1 = diag([<span class="number">1</span> / maxstd, <span class="number">1</span> / maxstd, <span class="number">1</span>])</span><br><span class="line">    C1[<span class="number">0</span>][<span class="number">2</span>] = -m[<span class="number">0</span>] / maxstd</span><br><span class="line">    C1[<span class="number">1</span>][<span class="number">2</span>] = -m[<span class="number">1</span>] / maxstd</span><br><span class="line">    fp_cond = dot(C1, fp)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 映射对应点</span></span><br><span class="line">    m = mean(tp[:<span class="number">2</span>], axis=<span class="number">1</span>)</span><br><span class="line">    C2 = C1.copy()</span><br><span class="line">    C2[<span class="number">0</span>][<span class="number">2</span>] = -m[<span class="number">0</span>] / maxstd</span><br><span class="line">    C2[<span class="number">1</span>][<span class="number">2</span>] = -m[<span class="number">1</span>] / maxstd</span><br><span class="line">    tp_cond = dot(C2, tp)</span><br><span class="line"></span><br><span class="line">    A = concatenate((fp_cond[:<span class="number">2</span>],tp_cond[:<span class="number">2</span>]), axis = <span class="number">0</span>)</span><br><span class="line">    U, S, V = linalg.svd(A.T)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建B、C</span></span><br><span class="line">    tmp = V[:<span class="number">2</span>].T</span><br><span class="line">    B   = tmp[:<span class="number">2</span>]</span><br><span class="line">    C   = tmp[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    tmp2 = concatenate((dot(C, linalg.pinv(B)),zeros((<span class="number">2</span>,<span class="number">1</span>))), axis = <span class="number">1</span>)</span><br><span class="line">    H = vstack((tmp2, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反归一化</span></span><br><span class="line">    H = dot(linalg.inv(C2), dot(H, C1))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> H / H[<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pointX = []</span><br><span class="line">    pointY = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            pointX.append(i)</span><br><span class="line">            pointY.append(j)</span><br><span class="line">    Points = array([pointX, pointY])</span><br><span class="line">    Points = makeHomog(Points)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 仿射变换矩阵</span></span><br><span class="line">    rtMatrix = array(</span><br><span class="line">        [[<span class="number">0.5</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>],</span><br><span class="line">         [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">    )</span><br><span class="line">    changedPoints = flact(Points, rtMatrix)</span><br><span class="line">    plotTwoPoints(Points, changedPoints)</span><br><span class="line">    print(hFromPoints(Points, changedPoints))</span><br><span class="line">    print(HaffineFromPoints(Points, changedPoints))</span><br><span class="line">    show()</span><br></pre></td></tr></table></figure>
<h2 id="结果">结果</h2>
<p>在刚才的代码中，我们使用仿射变换矩阵： <span class="math display">\[
\left[\begin{matrix}0.5 &amp;0 &amp;1\\0 &amp;0.5 &amp; 1\\0 &amp; 0 &amp; 1\end{matrix}\right]
\]</span> 进行变化，我们利用一组点变换前后的状态，求仿射变换矩阵。得到的结果如下：</p>
<blockquote>
<p>[[ 5.00000000e-01 1.20777603e-16 1.00000000e+00] [-1.13154271e-16 5.00000000e-01 1.00000000e+00] [ 2.45515188e-17 1.40739819e-17 1.00000000e+00]]</p>
<p>[[ 5.00000000e-01 6.07529133e-16 1.00000000e+00] [-1.11022302e-16 5.00000000e-01 1.00000000e+00] [ 0.00000000e+00 0.00000000e+00 1.00000000e+00]]</p>
</blockquote>
<p>其中，上面的结果是8自由度下的解，而下面的结果是6自由度下的解。我们可以发现结果非常完美。但是这是否是由于我门取了4*4=16个点的原因呢？于是我降低了采样数量，从原来的采样间隔为1降低到采样间隔为2，并进行观察。在此情况下，我们只取4个点，结果如下：</p>
<blockquote>
<p>[[ 5.00000000e-01 -3.12481436e-16 1.00000000e+00] [-5.50986389e-16 5.00000000e-01 1.00000000e+00] [-3.84592537e-16 -9.61481342e-17 1.00000000e+00]]</p>
<p>[[ 5.00000000e-01 -1.79637859e-16 1.00000000e+00] [ 1.11022302e-16 5.00000000e-01 1.00000000e+00] [ 0.00000000e+00 0.00000000e+00 1.00000000e+00]]</p>
</blockquote>
<p>我们发现，虽然结果与上一组相比较下，偏差相对较大，但是误差仍然在可以忽略的范围内，总体来说结果非常理想。</p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python图像处理笔记-五SIFT（尺度不变特征变换）</title>
    <url>/2020/04/16/python%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0-%E4%BA%94SIFT%EF%BC%88%E5%B0%BA%E5%BA%A6%E4%B8%8D%E5%8F%98%E7%89%B9%E5%BE%81%E5%8F%98%E6%8D%A2%EF%BC%89/</url>
    <content><![CDATA[<p>图形学笔记（五）——SIFT（尺度不变特征变换） SIFT(Scale-Invariant Feature Transform)的中文名字是尺度不变特征变换。SIFT描述子具有非常强的稳健性，自从SIFT出现，许多其他本质上使用相同描述子的方法也相继出现。它可以用于三维视角和噪声的可靠匹配。</p>
<p>参考资料 Jan Erik Solem. Python计算机视觉编程 (图灵程序设计丛书) (p. 39). 人民邮电出版社.</p>
<p>6.SIFT(尺度不变特征变换)_bilibili</p>
<p>特别推荐一下，上面那个作者做的东西都特别良心，做的都特别好，讲得很透彻，不过可惜的是他不更新了，这是他的主页</p>
<p>Sift中尺度空间、高斯金字塔、差分金字塔（DOG金字塔）、图像金字塔</p>
<p>建立高斯差分金字塔 首先要说的是，这个部分又可以拆分成两个部分：</p>
<p>建立高斯金字塔</p>
<p>根据高斯金字塔建立DOG金字塔</p>
<p>首先，我们来讨论一个问题，什么是金字塔?</p>
<p>什么是金字塔 相信大家都从电视上（或者亲眼）看见过所谓的金字塔：</p>
<p>图像金字塔是一种以多分辨率来解释图像的结构，通过对原始图像进行多尺度像素采样的方式，生成N个不同分辨率的图像。把具有最高级别分辨率的图像放在底部，以金字塔形状排列，往上是一系列像素（尺寸）逐渐降低的图像，一直到金字塔的顶部只包含一个像素点的图像，这就构成了传统意义上的图像金字塔。（ref）</p>
<p>可以看得出来，还是有丶小像的。那么构建这个图像金字塔包括两个步骤：</p>
<p>一、使用低通滤波器平滑图像</p>
<p>二、对平滑图像进行抽样（采样）</p>
<p>而采样的方法又分为两种：</p>
<p>一、上采样：越采样图片尺寸越大（分辨率逐级升高）</p>
<p>二、下采样：越采样图片尺寸越小（分辨率逐级下降）</p>
<p>那么我们说，从一张高分辨率照片，来构建一个金字塔的过程，往往是对该图片进行上采样或下采样的过程。</p>
<p>高斯金字塔 需要声明的是，高斯金字塔并不是一个金字塔，而是由很多组（Octave）金字塔构成的，并且每组金字塔都包含若干层（Interval）。</p>
<p>高斯金字塔的构建</p>
<p>先将原图像扩大一倍之后作为高斯金字塔的第1组第1层，将第1组第1层图像经高斯卷积（其实就是高斯平滑或称高斯滤波）之后作为第1组金字塔的第2层，高斯卷积函数为：</p>
<p>对于参数​，在Sift算子中取的是固定值1.6。</p>
<p>将​乘以一个比例系数k,等到一个新的平滑因子​，用它来平滑第1组第2层图像，结果图像作为第3层。</p>
<p>如此这般重复，最后得到L层图像，在同一组中，每一层图像的尺寸都是一样的，只是平滑系数不一样。它们对应的平滑系数分别为：​</p>
<p>将第1组倒数第三层图像作比例因子为2的降采样，得到的图像作为第2组的第1层，然后对第2组的第1层图像做平滑因子为​的高斯平滑，得到第2组的第2层，就像步骤2中一样，如此得到第2组的L层图像，同组内它们的尺寸是一样的，对应的平滑系数分别为：​。但是在尺寸方面第2组是第1组图像的一半。</p>
<p>这样反复执行，就可以得到一共O组，每组L层，共计O*L个图像，这些图像一起就构成了高斯金字塔，结构如下：</p>
<p>高斯金字塔的性质</p>
<p>在同一组内，不同层图像的尺寸是一样的，后一层图像的高斯平滑因子σ是前一层图像平滑因子的k倍；</p>
<p>在不同组内，后一组第一个图像是前一组倒数第三个图像的二分之一采样，图像大小是前一组的一半；</p>
<p>说白了就是：</p>
<p>高斯金字塔中每一组内图像的大小相同，组中的图像高斯模糊程度不同</p>
<p>高斯金字塔中不同组之间，大小不同，但是对应位置的高斯模糊程度相同。</p>
<p>至此为止，我们的高斯金字塔已经建好了</p>
<p>高斯差分金字塔，DOG（Difference of Gaussian） DOG金字塔的第1组第1层是由高斯金字塔的第1组第2层减第1组第1层得到的。以此类推，逐组逐层生成每一个差分图像，所有差分图像构成差分金字塔。概括为DOG金字塔的第o组第l层图像是有高斯金字塔的第o组第l+1层减第o组第l层得到的。</p>
<p>说白了就是：高斯差分金字塔中的值就是高斯金字塔中每一组内相邻的两个层的图片相减而得到的。因此高斯差分金字塔每一组中都要比高斯金字塔中少一张图片。</p>
<p>有一些特征是在不同模糊程度、不同尺度下都存在的，这些特征正是Sift所要提取的“稳定”特征，这里如果看不懂，我们会放在最后，根据代码和结果进行详解。</p>
<p>兴趣点 我们认为稳定的点，不会变化的点，包含很多信息的点，是关键点，也就是兴趣点，关键点是由DOG空间的局部极值点组成的。在这个小节内，我们来看一下如何在高斯差分金字塔中寻找极值点。</p>
<p>阈值化 只保留满足下式条件的点以消除噪音：</p>
<p>在高斯差分金字塔中寻找极值点</p>
<p>我们检测一个点连通的​个点，来确定该点是否是附近区域内的极值点，当然，我们这种找法，只能找到近似的极值点，所以就有了下一步。</p>
<p>调整极值点位置 想要调整极值点位置，那么就需要先知道为什么极值点的位置可能有错。错误是由于：我们的极值点的选取是离散的，而非连续的，所以就有可能出现下图中的情况：</p>
<p>我们看到，我们的取点是等间距的、离散的，但是真正的极值点的位置并没有被我们取到。这时就需要我们化离散为连续，使用泰勒展开就能化离散为连续了。</p>
<p>看不懂别慌，我也看不懂。。最后化简完我们就看得懂了：</p>
<p>我们知道，极值点实际上是在我们找到的近似极值点​附近的，上面式子中的​代表的是极值点相对于​的相对位移量，那么怎么将这个​给求出来呢？我们需要对上面的式子进行求导，求导后得到：</p>
<p>将上面的式子带回到初始的函数中，得到:</p>
<p>舍去低对比度的点 如果 ​，则舍去点X。</p>
<p>边缘效应的去除 使用海森矩阵</p>
<p>海森矩阵的特征值​代表​方向的梯度：</p>
<p>​</p>
<p>​</p>
<p>看过讲表示矩阵H对角线元素之和，表示矩阵H的行列式。假设是α较大的特征值，而是β较小的特征值，令​，就有：</p>
<p>如果不满足：</p>
<p>那么就舍去X，这个过程和Harris角点检测器非常的相似，实际上他们想要达到的目标也是非常相似的，他们的目标都是为了尽量选择角点，因为我们默认角点才是包含更多信息的点。</p>
<p>有限差分法求导 一堆公式</p>
<p>为关键点赋予方向 以当前位置为圆心，高斯图像尺度的1.5倍为半径画圆，统计该圆内所有像素的梯度方向及其梯度幅值，这里相当于是在投票，但是每个像素点投得票数不是1，而是该梯度的幅值。</p>
<p>在投票的过程中，我们还需要使用高斯滤波进行加权，其实说白了就是：离中心点近的点投票的重要性更大。其中，结果最大的方向是主方向。当有其他的柱的幅值大于主方向的​，我们就叫他辅方向。</p>
<p>到此为止，我们有了：</p>
<p>特征点</p>
<p>特征点对应的方向</p>
<p>特征点对应的幅值</p>
<p>构建关键点的描述符 我们在一张图片中，找到关键点是没啥作用的。我们需要在两张图片中分别找到关键点，然后把它们相对应的点匹配起来，所以我们需要找到一种匹配的方法，这里我们使用的是KNN。</p>
<p>我们找到以中心点为中心的16个格子，分别统计十六个格子中八个方向的梯度的长度（高斯加权后的）。</p>
<p>这样我们就得到了下面的：</p>
<p>这样我们就得到了一个8*16的向量，用于描述这个区域。但是在做这些之前，我们需要先将区域内的点旋转到主方向上，然后再进行统计。</p>
<p>代码 下面这个代码是从网上copy的，用cv2直接掉的包，下面还有一个b站up主自己写的，大家可以去学习一下。</p>
<p>""" Created on Sat Sep 29 14:43:02 2018</p>
<p><span class="citation" data-cites="author">@author</span>: qgl """</p>
<p>import numpy as np import cv2 from matplotlib import pyplot as plt</p>
<p>imgname = 'C:/Users/qgl/Desktop/articles/test1.jpg'</p>
<p>sift = cv2.xfeatures2d.SIFT_create()</p>
<p>img = cv2.imread(imgname) gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY) kp,des = sift.detectAndCompute(img,None)</p>
<p>cv2.imshow('gray',gray) cv2.waitKey(0)</p>
<p>img1=cv2.drawKeypoints(img,kp,img,color=(255,0,255))</p>
<p>cv2.imshow('point',img1) cv2.waitKey(0)</p>
<p>这份代码是学习之前说的那个up主的项目写的，希望大家去给他打个星：</p>
<p>https://github.com/o0o0o0o0o0o0o/image-processing-from-scratch</p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python图像处理笔记-四-Harris角点检测器延申</title>
    <url>/2020/04/16/python%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0-%E5%9B%9B-Harris%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B%E5%99%A8%E5%BB%B6%E7%94%B3/</url>
    <content><![CDATA[<h1 id="图形学笔记四">图形学笔记（四）</h1>
<h2 id="harris-角点检测器延申在图像间寻找对应点">Harris 角点检测器延申——在图像间寻找对应点</h2>
<h3 id="原理">原理</h3>
<p>Harris角点检测器可以检测出来图像中的兴趣点，但是没有给出比较图像间兴趣点来寻找匹配角点的方法。我们需要在每个点上加上描述子信息，并给出比较这些描述子的方法。</p>
<p>兴趣点描述子是分配给兴趣点的一个向量，描述该点附近的图像的表观信息，描述子越好，寻找到的对应点也越好。我们用<strong>对应点</strong>或<strong>点的对应</strong>来描述相同物体和场景点在不同图像上形成的像素点.</p>
<p>Harris角点的描述子通常是由周围图像像素块的灰度值,以及用于比较的归一化互相关矩阵构成的.图像的像素块由以该像素点为中心的周围矩阵部分图像构成.（其实我们可以把这个矩阵，看成一个窗口，因为我们很难从全局去考虑这个点的位置，所以我们需要在这个点附近开一个窗口，然后通过对应点之间的窗口进行比较，来达到描述两个角点的相似性的目的）</p>
<p>我们可以定义一个函数: <span class="math display">\[
c(I_1,I_2) = \Sigma_x f(I_1(x),I_2(x))
\]</span> 其中，函数f随着相关方法的变化而变化，上式取像素块中所有像素位置x的和，对于互相关矩阵，函数<span class="math inline">\(f(I_1,I_2) = I_1I_2\)</span>，因此<span class="math inline">\(c(I_1,I_2) = I_1\cdot I_2\)</span>，其中<span class="math inline">\(\cdot\)</span>代表向量乘法。<span class="math inline">\(c(I_1,I_2)\)</span>的值越高，像素块<span class="math inline">\(I_1,I_2\)</span>的相似度也越高。（另一个常用的是<span class="math inline">\(f(I_1,I_2)= (I_1-I_2)^2\)</span>）</p>
<p>上面说的其实就是用余弦法来度量两个向量的相似度，余弦的值越大，两个向量就越接近。</p>
<p>归一化的互相关矩阵是互相关矩阵的一种变形，可以被定义为： <span class="math display">\[
ncc(I_1,I_2) = \frac{1}{n-1} \Sigma_{x}  \frac{I_1(x)-\mu_1}{\sigma_1}\cdot \frac{I_2(x)-\mu_2}{\sigma_2}
\]</span> 学过高斯的都知道，这里的<span class="math inline">\(\mu\)</span>代表的是平均值，<span class="math inline">\(\sigma\)</span>代表的是标准差，而这里的统计范围是以某个点为中心的窗口中的所有像素点。这里实际上在干的事情是：求每张图片的相对亮度，所构成的向量的余弦，这样可以有效地消除由于左右目相机接收到的光照条件不同而引起的差异。</p>
<p>我们使用非常有名的tsukuba来进行测试，这个数据集是一个用于立体匹配的数据集：</p>
<p><img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%83%8F%E5%AD%A6%E4%B9%A0ch4/image-20200415080627078.png" alt="image-20200415080627078" style="zoom:50%;" /></p>
<h3 id="代码">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy. ndimage <span class="keyword">import</span> filters</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算比值得分的函数,即计算finalScore</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeHarrisResponse</span><span class="params">(im, sigma = <span class="number">3</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        在一幅灰度图像中，对每个像素计算角点器响应函数</span></span><br><span class="line"><span class="string">        输入:</span></span><br><span class="line"><span class="string">            im:表示需要求R的图像（需要是灰度图）</span></span><br><span class="line"><span class="string">            sigma：考虑半径</span></span><br><span class="line"><span class="string">        返回：</span></span><br><span class="line"><span class="string">            Wdet / Wtr ： lambda1*lambda2 与 (lambda1+lambda2)^2的比</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算导数</span></span><br><span class="line">    <span class="comment"># I_x</span></span><br><span class="line">    imx = zeros(im.shape)</span><br><span class="line">    filters.gaussian_filter(im, (sigma, sigma), (<span class="number">0</span>, <span class="number">1</span>) , imx)</span><br><span class="line">    <span class="comment"># I_y</span></span><br><span class="line">    imy = zeros(im.shape)</span><br><span class="line">    filters.gaussian_filter(im, (sigma, sigma), (<span class="number">1</span>, <span class="number">0</span>) , imy)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算Harris矩阵的分量</span></span><br><span class="line">    Wxx = filters.gaussian_filter(imx * imx, sigma)</span><br><span class="line">    Wxy = filters.gaussian_filter(imx * imy, sigma)</span><br><span class="line">    Wyy = filters.gaussian_filter(imy * imy, sigma)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算特征值和迹</span></span><br><span class="line">    Wdet = Wxx * Wyy - Wxy ** <span class="number">2</span></span><br><span class="line">    Wtr = Wxx + Wyy</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Wdet / Wtr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从每个像素计算角点器响应函数到图像中的所有角点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHarrisPoints</span><span class="params">(harrisim, minDist = <span class="number">10</span>, threshold = <span class="number">0.1</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        从一幅Harris响应图像中返回角点。</span></span><br><span class="line"><span class="string">        输入：</span></span><br><span class="line"><span class="string">            minDist：分割角点和图像边界的最少像素数目</span></span><br><span class="line"><span class="string">        输出：</span></span><br><span class="line"><span class="string">            角点们</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 寻找高于阈值的候选角点</span></span><br><span class="line">    <span class="comment"># 角点阈值等于得分矩阵中最大的*0.1</span></span><br><span class="line">    cornerThreshold = harrisim.max() * threshold</span><br><span class="line">    <span class="comment">#harrisim_t为1的位置就是可能是角点的</span></span><br><span class="line">    harrisimT = (harrisim &gt; cornerThreshold) * <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 得到候选点的坐标</span></span><br><span class="line">    coords = array(harrisimT.nonzero()).T</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 候选点的Harris 响应值</span></span><br><span class="line">    candidateValues = [harrisim[c[<span class="number">0</span>], c[<span class="number">1</span>]] <span class="keyword">for</span> c <span class="keyword">in</span> coords]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对候选点按照Harris 响应值进行排序</span></span><br><span class="line">    index = argsort(candidateValues)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将可行点的位置保存到数组中</span></span><br><span class="line">    allowedLocations = zeros(harrisim.shape) </span><br><span class="line">    allowedLocations[minDist : -minDist, minDist : -minDist] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按照minDistance 原则，选择最佳Harris点</span></span><br><span class="line">    filteredCoords = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> index:</span><br><span class="line">        <span class="keyword">if</span>(allowedLocations[coords[i, <span class="number">0</span>], coords[i, <span class="number">1</span>]] == <span class="number">1</span>):</span><br><span class="line">            filteredCoords.append(coords[i])</span><br><span class="line">            allowedLocations[(coords[i, <span class="number">0</span>] - minDist) : (coords[i, <span class="number">0</span>] + minDist),</span><br><span class="line">                             (coords[i, <span class="number">1</span>] - minDist) : (coords[i, <span class="number">1</span>] + minDist)] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> filteredCoords</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示角点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotHarrisPoints</span><span class="params">(img, filteredCoords)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        绘制图像中检测到的角点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    figure()</span><br><span class="line">    <span class="comment">#灰度图</span></span><br><span class="line">    gray()</span><br><span class="line">    <span class="comment">#显示图</span></span><br><span class="line">    imshow(img)</span><br><span class="line">    <span class="comment"># 显示点</span></span><br><span class="line">    plot([p[<span class="number">1</span>] <span class="keyword">for</span> p <span class="keyword">in</span> filteredCoords], [p[<span class="number">0</span>] <span class="keyword">for</span> p <span class="keyword">in</span> filteredCoords], <span class="string">"*"</span>)</span><br><span class="line">    <span class="comment"># 关闭坐标</span></span><br><span class="line">    axis(<span class="string">'off'</span>)</span><br><span class="line">    show()</span><br><span class="line">    </span><br><span class="line"><span class="comment">## 返回周围点    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDescriptors</span><span class="params">(image, filteredCoords, wid = <span class="number">5</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        对于每个返回的点，给出周围2*wid+1个像素的值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    desc = []</span><br><span class="line">    <span class="keyword">for</span> coords <span class="keyword">in</span> filteredCoords:</span><br><span class="line">        patch = image[coords[<span class="number">0</span>] - wid:coords[<span class="number">0</span>] + wid + <span class="number">1</span>, </span><br><span class="line">                      coords[<span class="number">1</span>] - wid:coords[<span class="number">1</span>] + wid + <span class="number">1</span>].flatten()</span><br><span class="line">        desc.append(patch)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> desc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于第一个图片中的每个角点描述子，使用归一化互相关，选取他再第二幅图像中的匹配角点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(desc1, desc2, threshold = <span class="number">0.5</span>)</span>:</span></span><br><span class="line">    n = len(desc1[<span class="number">0</span>])</span><br><span class="line">    d = -ones((len(desc1),len(desc2)))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(desc1)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(desc2)):</span><br><span class="line">            d1 = (desc1[i] - mean(desc1[i])) / std(desc1[i])</span><br><span class="line">            d2 = (desc2[j] - mean(desc2[j])) / std(desc2[j])</span><br><span class="line">            nccValue = sum(d1 * d2) / (n<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span>(nccValue &gt; threshold):</span><br><span class="line">                d[i][j] = nccValue</span><br><span class="line">    ndx = argsort(-d)</span><br><span class="line">    matchscores = ndx[:,<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> matchscores</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用match函数正反各匹配一次，舍去两次匹配中不同的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">matchTwoSided</span><span class="params">(desc1, desc2, threshold = <span class="number">0.5</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">     两边对称的match </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    match12 = match(desc1, desc2, threshold)</span><br><span class="line">    print(match12)</span><br><span class="line">    match21 = match(desc2, desc1, threshold)</span><br><span class="line">    print(match21)</span><br><span class="line">    <span class="comment"># 舍去不同的</span></span><br><span class="line">    index12 = where(match12&gt;=<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> n  <span class="keyword">in</span> index12:</span><br><span class="line">        <span class="keyword">if</span>(match21[match12[n]] != n):</span><br><span class="line">            match12[n] = <span class="number">-1</span></span><br><span class="line">    print(<span class="string">"mathc12"</span>)</span><br><span class="line">    print(match12)</span><br><span class="line">    <span class="keyword">return</span> match12</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回将两张图片并排拼接成一幅新的图像</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">appendImages</span><span class="params">(im1, im2)</span>:</span></span><br><span class="line">    <span class="comment"># 选取具有最少行数的图像，然后填充足够的空行</span></span><br><span class="line">    rows1 = im1.shape[<span class="number">0</span>]</span><br><span class="line">    rows2 = im2.shape[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (rows1 &lt; rows2):</span><br><span class="line">        im1 = concatenate((im1, zeros((rows2 - rows1, im1.shape[<span class="number">1</span>]))), axis = <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">elif</span> (rows1 &gt; rows2):</span><br><span class="line">        im2 = concatenate((im2, zeros((rows1 - rows2, im2.shape[<span class="number">1</span>]))), axis = <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 都没有说明行数相同，无需填充</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> concatenate((im1,im2), axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotMatches</span><span class="params">(im1, im2, locs1, locs2, matchscores, showBelow = True)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        显示一幅带有连接匹配之间连线的图片</span></span><br><span class="line"><span class="string">        输入：</span></span><br><span class="line"><span class="string">            im1, im2 图像</span></span><br><span class="line"><span class="string">            locs1，locs2 特征位置</span></span><br><span class="line"><span class="string">            matchscores：match的输出</span></span><br><span class="line"><span class="string">            showBelow：如果图像应该显示在匹配的下方</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    im3 = appendImages(im1, im2)</span><br><span class="line">    <span class="keyword">if</span> showBelow:</span><br><span class="line">        im3 = vstack((im3,im3))</span><br><span class="line">    imshow(im3)</span><br><span class="line">    cols1 = im1.shape[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i,m <span class="keyword">in</span> enumerate(matchscores):</span><br><span class="line">        <span class="keyword">if</span>(m &gt; <span class="number">0</span>):</span><br><span class="line">            plot([locs1[i][<span class="number">1</span>], locs2[m][<span class="number">1</span>] + cols1], [locs1[i][<span class="number">0</span>],locs2[m][<span class="number">0</span>]],<span class="string">'c'</span>)</span><br><span class="line">    axis(<span class="string">'off'</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doIt</span><span class="params">(im1, im2)</span>:</span></span><br><span class="line">    wid = <span class="number">5</span></span><br><span class="line">    harrisim = computeHarrisResponse(im1, <span class="number">5</span>)</span><br><span class="line">    filteredCoords1 = getHarrisPoints(harrisim, wid + <span class="number">1</span>, <span class="number">0.3</span>)</span><br><span class="line">    d1 = getDescriptors(im1, filteredCoords1, wid)</span><br><span class="line">    plotHarrisPoints(im1, filteredCoords1)</span><br><span class="line">    harrisim = computeHarrisResponse(im2, <span class="number">5</span>)</span><br><span class="line">    filteredCoords2 = getHarrisPoints(harrisim, wid + <span class="number">1</span>, <span class="number">0.3</span>)</span><br><span class="line">    d2 = getDescriptors(im2, filteredCoords2, wid)</span><br><span class="line">    plotHarrisPoints(im2, filteredCoords2)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">"MATCHING!!!"</span>)</span><br><span class="line">    matches = matchTwoSided(d1,d2)</span><br><span class="line">    </span><br><span class="line">    figure()</span><br><span class="line">    gray()</span><br><span class="line">    plotMatches(im1, im2, filteredCoords1, filteredCoords2, matches)</span><br><span class="line">    show()</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imresize</span><span class="params">(im, sz)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用PIL对象重定义图像数组大小</span></span><br><span class="line"><span class="string">    im : 重定义大小的图像</span></span><br><span class="line"><span class="string">SIFT（尺度不变特征变换）    sz : 重定义的大小</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    pil_im = Image.fromarray(uint8(im))</span><br><span class="line">    <span class="keyword">return</span> array(pil_im.resize(sz))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    im = array(Image.open(<span class="string">r'C:\Users\wangsy\Desktop\learning\ch4\tsukuba\scene1.row3.col1.ppm'</span>).convert(<span class="string">'L'</span>))</span><br><span class="line">    im2 = array(Image.open(<span class="string">r'C:\Users\wangsy\Desktop\learning\ch4\tsukuba\scene1.row3.col5.ppm'</span>).convert(<span class="string">'L'</span>))</span><br><span class="line">    </span><br><span class="line">    doIt(im, im2)</span><br></pre></td></tr></table></figure>
<h3 id="结果">结果</h3>
<p><img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E5%9B%BE%E5%83%8F%E5%AD%A6%E4%B9%A0ch4/image-20200415080724859.png" alt="image-20200415080724859" style="zoom: 67%;" /></p>
<p>可以看到，这个匹配结果还凑活，但是说实话，不咋地。我准备以后开个专题来讲一下几个传统的立体匹配方法，因为最近也有可能要做相关的东西，正好复习一下。所以这一次，这方面的就先带过去了。</p>
<p>我们可以看出来，匹配的核心是相似性的度量，也就是描述子，在下一节我们会学习最好的一种描述子之一。</p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>组成原理第三章-下-——浮点数的相关运算</title>
    <url>/2020/04/15/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0-%E4%B8%8B-%E2%80%94%E2%80%94%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E7%9B%B8%E5%85%B3%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="组成原理三下浮点数运算">组成原理（三）下——浮点数运算</h1>
<h2 id="浮点数的表示">浮点数的表示</h2>
<h3 id="基础原理">基础原理</h3>
<p>有很多数字非常的大或者非常的小，会超出32位2进制数的表示范围。所以仅使用整形变量或是定点数并不能满足我们的需求，所以我们有了一套由十进制的科学计数法推广而来的浮点数表示方法。首先，我们来回顾一下十进制下的科学计数法: <span class="math display">\[
N = 10^E *M
\]</span> 我们把它推广到R进制，就可以得到: <span class="math display">\[
N = R^e*M
\]</span> 我们给他们都来命一个名：</p>
<ul>
<li>R：基数，对于二进计数值的机器是一个常数，一般规定为2、8、16中的一个</li>
<li>e：指数</li>
<li>M：尾数</li>
</ul>
<p>一个机器浮点数由<strong>阶码和尾数以及符号位</strong>组成：</p>
<p><img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B8%8B/image-20200414020015817.png" alt="image-20200414020015817" style="zoom:67%;" /></p>
<ul>
<li>尾数：用定点小数表示，给出有效数字的位数</li>
<li>阶码：用定点整数形式表示，知名小数点在数据中的位置，决定了浮点数的表示范围。</li>
</ul>
<p>通俗的说，就是：阶码控制一个范围<span class="math inline">\([-X,X]\)</span>我们可以将这个范围看作一个区间，然后尾数，也就是这个定点小数表示当前的数字在这个区间中的相对位置。</p>
<h3 id="ieee754重点">IEEE754（重点）</h3>
<p><strong>标准表示方法：</strong>为便于软件移植，使用 IEEE标准IEEE754 ：<strong>（重点）</strong></p>
<ul>
<li>尾数用原码；</li>
<li>阶码用变形移码；</li>
<li>基为2</li>
</ul>
<p>按照该标准，32位浮点数和64位浮点数的标准格式为：</p>
<p><img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B8%8B/image-20200414020700674.png" alt="image-20200414020700674" style="zoom:67%;" /></p>
<p>其中：</p>
<ul>
<li>S—尾数符号，0正1负</li>
<li>M—尾数，纯小数表示，小数点放在尾数域的最前面，采用源码表示</li>
<li>E—阶码，采用移码表示（后面填坑）</li>
</ul>
<h3 id="浮点数的规格化表示">浮点数的规格化表示</h3>
<p>众所周知，一个数可以由很多种科学计数法来表示，比如：</p>
<p><span class="math inline">\(0.5 = 5*10^{-1}=0.5*10^{0},....\)</span></p>
<p>我们可以一直写下去，那显然，如果大家都乱写就乱套了，所以为了提高数据的表示精度，需要做规格化处理，这样做可以：</p>
<ul>
<li>提高表示精度</li>
<li>使数据表示有唯一性</li>
</ul>
<blockquote>
<p>Q：什么是规格化？</p>
<p>A：如果尾数为R进制的规格化，绝对值大于或等于<span class="math inline">\(\frac{1}{R}\)</span></p>
</blockquote>
<p>二进制源码的规格化数的表现形式：</p>
<p>正数：<span class="math inline">\(0.1....\)</span></p>
<p>负数：<span class="math inline">\(1.1....\)</span></p>
<p>补码位数的规格化的表现形式：</p>
<p>正数：<span class="math inline">\(0.1....\)</span></p>
<p>负数：<span class="math inline">\(1.0.....\)</span></p>
<p>补码下尾数的最高位域符号位相反</p>
<p>可能有人看到这里看不懂，我解释一下，规格化处理后的数字应该满足尾数的绝对值大于或等于<span class="math inline">\(\frac{1}{R}\)</span>这里有<span class="math inline">\(R=1\)</span>，所以我们规格化处理后，尾数的绝对值应当大于等于0.5，0.5是什么?是2的-1次方，那么二进制源码表示下当尾数的最高位为1时，就满足规格化，这样的设计便于判断。</p>
<p><strong>为什么这样的设计能够提高精度？</strong></p>
<p>要想知道为什么这样做能够提高精度，就应当先了解为什么会产生精度误差。产生精度误差的原因是：<strong>当我们要表示的数很小或不能被准确表示的时候，我们的区间长*比例只能达到近似解。</strong>那么我们分析以下两种情况：</p>
<ul>
<li>例子：表示0.0001</li>
<li>大区间小比例：
<ul>
<li>假设我们的指数为表示出来的值为100，那么我们想要表示0.0001，就需要让尾数位为：0.000001，但是众所周知，二进制数在很多情况下都只能尽量地逼近这个数，那么问题来了：该怎么让尾数尽可能地逼近这个数呢？答案就是：尽量用更多的位。那么反过来观察我们的方法，我们浪费了尾数位的高位。这显然是不理智的。</li>
</ul></li>
<li>小区间大比例：
<ul>
<li>我们刚才悟出了一个道理：<strong>精度主要由尾数位的准确程度决定</strong>，那么我们就要尽量的压榨尾数位，什么时候才能把它压榨到极限呢？答案很简单：第一位不为0。</li>
</ul></li>
</ul>
<p><strong>隐藏位计数</strong></p>
<p>我们还可以再使用隐藏位技术再提高一点精度，既然我们都知道，尾数的第一位必为1了，那我们还记录他干什么呢？那么我们在记录尾数的时候，可以将尾数的最高位通过左移一位隐藏起来(其实就是自然溢出)，这样就可以再多记一位尾数了。</p>
<h3 id="规格化浮点数的真值">规格化浮点数的真值</h3>
<p>我们通过32位浮点数来看：</p>
<p><img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B8%8B/image-20200414025741113.png" alt="image-20200414025741113" style="zoom:50%;" /></p>
<p>移码定义： <span class="math display">\[
\begin{align}
\begin{array}
x[x]_移 &amp;= x_0x_1x_2x_3...x_n\\
&amp; = 2^n +x
\end{array}
\end{align}
\]</span> 实际上就是：在<span class="math inline">\(2^n\)</span>的基础上进行平移。</p>
<p>一个规格化的32位浮点数的x的真值为： <span class="math display">\[
x = (-1)^s*(1.M) * 2^{E-127}
\]</span> 一个规格化的64位浮点数x的真值为： <span class="math display">\[
x = (-1)^s*(1.M)*2^{E-1023}
\]</span></p>
<h4 id="例题1">例题1</h4>
<p>若浮点数x的二进制储存格式为:<span class="math inline">\((41360000)_{16}\)</span>求其32位浮点数的十进制格式：</p>
<p><img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B8%8B/IMG_20200414_111131.jpg" alt="IMG_20200414_111131" style="zoom: 15%;" /></p>
<h4 id="例题2">例题2</h4>
<p>将十进制数20.59375转换成32位浮点数的二进制格式来存储。</p>
<p>首先先将整数部分和分数部分转化成二进制数：</p>
<p><span class="math inline">\(20.59375 = 10100.10011\)</span></p>
<p>移动小数点，使其在1，2位之间：</p>
<p><span class="math inline">\(10100.10011 = 1.010010011 * 2^4,e=4\)</span></p>
<p>得到:<span class="math inline">\(e = E - 127\)</span></p>
<p><span class="math inline">\(S = 0, E = 4+127=131=1000,0011,M = 010010011\)</span></p>
<p>最后得到32位浮点数的二进制储存格式为：</p>
<p><span class="math inline">\(0100,0001,1010,0100,1100,0000,0000,0000\)</span></p>
<h3 id="ieee754浮点数的范围">IEEE754浮点数的范围</h3>
<p><img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B8%8B/image-20200414032235696.png" alt="image-20200414032235696" style="zoom:50%;" /></p>
<p><img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B8%8B/image-20200414032250767.png" alt="image-20200414032250767" style="zoom:50%;" /></p>
<h2 id="浮点数的加减">浮点数的加减</h2>
<h3 id="加法">加法</h3>
<p>我们先从算数式的角度去理解，假设我们已经有了两个浮点数，它们分别是：</p>
<p><span class="math inline">\(x = 2^{Ex}M_x\)</span></p>
<p><span class="math inline">\(y = 2^{Ey}M_y\)</span></p>
<p>其中，E代表阶码，M代表尾数</p>
<p>那么两个浮点数进行加减运算实际上就是： <span class="math display">\[
x \pm y = (M_x2^{Ex-Ey} \pm M_y)2^{Ey},E_x \leq E_y
\]</span> 说白了就是分为几步：</p>
<ul>
<li>一、将两个数对齐，对齐到阶码大的数那里</li>
<li>二、将对齐后的尾数相加</li>
<li>三、乘上较大的阶码表示的数</li>
</ul>
<p>那么我们将这个操作转化到机器上，就变成了：</p>
<ul>
<li><p>一、0操作数的检查：</p></li>
<li><p>二、比较阶码大小并完成对阶（小的数向大的数对齐），小阶的尾数右移，每右移一位,其阶码加1(右规)。</p></li>
<li><p>三、尾数进行加或减运算</p></li>
<li><p>四、结果规格化：尾数运算完之后可能不满足规格化的要求，所以要进行规格化处理</p>
<ul>
<li>向左规格化：如果不是规格化的数，需要尾数向左移位，这个很好理解，就是太小了需要大一点，实现方法就是：每向左一位，阶码减1，直到满足规格化要求为止</li>
<li>向右规格化：两个满足规格化的数相加，可能太大。所以需要用右移的方法使结果满足规格化要求。方法是：每右移一位，阶码加一，直到满足规格化要求为止。</li>
</ul></li>
<li><p>五、舍入处理：在对阶或向右规格化的时候，尾数要向右进位，这样被右移的尾数的低位部分会被丢掉，从而会造成一定的误差，所以要进行舍入处理。</p>
<ul>
<li>0舍入1法:
<ul>
<li>如果右移的时候被丢掉的位数的最高位为0就舍去，否则就加一</li>
</ul></li>
<li>恒置1法：
<ul>
<li>只要数位被移掉，就在尾数的末尾置1。</li>
</ul></li>
</ul></li>
<li><p>六、溢出处理：将数字右规后，再根据阶码来判断浮点运算是否溢出，溢出可以分为三类：</p>
<ul>
<li>负上溢：</li>
<li>正上溢：正负上溢都一样，就是+1操作的时候，没法再加了，就溢出了</li>
<li>下溢：向左规格化的时候，阶码已经小于0了，但是仍然要减1，这时叫做下溢</li>
</ul>
<p>所以我们说，浮点数的溢出是以其阶码溢出表现出来的：</p>
<ul>
<li>阶码下溢是由于表示的数的绝对值太小了，这时可以把数看作0</li>
<li>阶码上溢是由于表示的数的绝对值实在是太大了，可以把数看作无穷</li>
</ul>
<p>流程图就直接copy老师的了：</p>
<p><img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B8%8B/image-20200414063901228.png" alt="image-20200414063901228" style="zoom: 67%;" /></p></li>
</ul>
<h4 id="例题">例题</h4>
<p><img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B8%8B/IMG_20200414_145344.jpg" alt="IMG_20200414_145344" style="zoom:25%;" /></p>
<h4 id="硬件电路">硬件电路</h4>
<p><img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B8%8B/image-20200414065701391.png" alt="image-20200414065701391" style="zoom: 67%;" /></p>
<h2 id="浮点数的乘除运算">浮点数的乘除运算</h2>
<p><span class="math inline">\(x = 2^{Ex}M_x\)</span></p>
<p><span class="math inline">\(y = 2^{Ey}M_y\)</span></p>
<p>乘法运算规则： <span class="math display">\[
x*y = 2^{(E_x+E_y)}*(M_x*M_y)
\]</span> 除法规则： <span class="math display">\[
x \div y= 2^{(E_x-E_y)}*(M_x \div M_y)
\]</span></p>
<h3 id="移码的溢出判断">移码的溢出判断</h3>
<p>首先明确：使用双符号位的阶码加法器，规定移码的第二位始终为0，那么移码的第二位为1的话就说明他溢出了。</p>
<ul>
<li>当低位符号为0时，(10)表明结果上溢</li>
<li>当低位符号位1时，(11)表明结果下溢</li>
<li>最高位为0，说明没溢出</li>
<li>低位符号为1，(01)结果为正</li>
<li>低位结果为0，(00)结果为负</li>
</ul>
<h3 id="尾数处理">尾数处理</h3>
<p>浮点加减法对结果的规格化及舍入处理也适用于浮点乘除法。</p>
<h3 id="例题-1">例题</h3>
<p><img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B8%8B/image-20200414071918356.png" alt="image-20200414071918356" style="zoom: 67%;" /></p>
<h2 id="浮点数表示和算法总结">浮点数表示和算法总结</h2>
<ul>
<li>IEEE754</li>
<li>尾数规格化</li>
<li>浮点数计算流程</li>
<li>浮点数计算硬件实现</li>
</ul>
<h2 id="mips中的浮点数指令">MIPS中的浮点数指令</h2>
<p>在mips中有32个单精度的寄存器，专门用于浮点数的操作。记作：<span class="math inline">\(f_0,f_1,...,f_{31}\)</span>，在储存单精度浮点数的时候，我32个可以分别使用，而在储存双精度浮点数的时候可以两两组合使用，也就是<span class="math inline">\(f_0/f_1,f_2/f_3,...,f_{30}/f_{31}\)</span>。</p>
<p>单精度的加减乘除指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add.s, sub.s, mul.s, div.s</span><br><span class="line"># 示例：add.s $f0, $f1, $f6</span><br></pre></td></tr></table></figure>
<p>双精度的加减乘除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add.d, sub.d, mul.d, div.d</span><br><span class="line"># 实例：mul.d $f4, $f4, $f6</span><br></pre></td></tr></table></figure>
<p>值得注意的是，上面说过双精度浮点数储存在两个连续的寄存器中，我们一般用开头的那个寄存器来代指另这两个寄存器的总体，所以我们上面的加法<span class="math inline">\(f4 = f4 + f6\)</span>中的f4实际上是指的f4f5连接而成的双精度数，当然f6也是同理。</p>
<h3 id="例题1-1">例题1</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">f2c</span> <span class="params">(<span class="keyword">float</span> fahr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="number">5.0</span>/<span class="number">9.0</span>) * (fahr - <span class="number">32.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MIPS:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f2c : lwc1 $f16, const5($gp)# 从环境中把5读入</span><br><span class="line">	  lwc2 $f18, const9($gp)# 从环境中把9读入</span><br><span class="line">	  div.s $f16, $f16, $f18# 除法</span><br><span class="line">	  lwc1 $f18, const32($gp)# 将32读入</span><br><span class="line">	  sub.s $f18, $f12, $f18# 减法</span><br><span class="line">	  mul.s $f0, $f16, $f18# 乘法</span><br><span class="line">	  jr $ra# 返回</span><br></pre></td></tr></table></figure>
<h3 id="例题2-1">例题2</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm</span><span class="params">(<span class="keyword">double</span> x[][], <span class="keyword">double</span> y[][], <span class="keyword">double</span> z[][])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">32</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j != <span class="number">32</span>;j ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k != <span class="number">32</span>; k++)&#123;</span><br><span class="line">                x[i][j] = x[i][j] + y[i][k] * z[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设x,y,z分别在$a0, $a1, $a2,并且i,j,k在$s0,$s1,$s2。</p>
<p>MIPS：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    li $t1, 32 # t1 &#x3D; 32，用于判断是否临界</span><br><span class="line">    li $s0, 0 # i &#x3D; 0，对i进行初始化</span><br><span class="line">L1:</span><br><span class="line">    li $s1, 0 # j &#x3D; 0，</span><br><span class="line">L2:</span><br><span class="line">    li $s2, 0 # k &#x3D; 0</span><br><span class="line">    sll $t2, $s0, 5 # t2 &#x3D; i*32，左移五位也就是*32</span><br><span class="line">    addu $t2, $t2, $s1 # t2 &#x3D; i*size(row) + j，到此为止，t2 就是 (i,j)的位置了</span><br><span class="line">    sll $t2, $t2, 3 ## t2 &#x3D; t2 * 8， 因为每个字节八位，所以要乘八</span><br><span class="line">    l.d $f4, 0($t2) #f4 &#x3D; x[i][j]</span><br><span class="line">L3:</span><br><span class="line">    sll $t0, $s2, 5 # t0 &#x3D; k*32，左移五位也就是*32</span><br><span class="line">    addu $t0, $t2, $s1 # t0 &#x3D; k*size(row) + j，到此为止，t2 就是 (i,j)的位置了</span><br><span class="line">    sll $t0, $t0, 3 ## t0 &#x3D; t0 * 8， 因为每个字节八位，所以要乘八</span><br><span class="line">    addu $t0, $a2, $t0 # t0 是z[k][j]的地址</span><br><span class="line">    l.d $f16, 0($t0) # f16 &#x3D; z[k][j]</span><br><span class="line">	sll $t0, $s0, 5 # t0 &#x3D; k*32，左移五位也就是*32</span><br><span class="line">    addu $t0, $t0, $s2 # t0 &#x3D; k*size(row) + j，到此为止，t2 就是 (i,k)的位置了</span><br><span class="line">    sll $t0, $t0, 3 ## t0 &#x3D; t0 * 8， 因为每个字节八位，所以要乘八</span><br><span class="line">    addu $t0, $a1, $t0 # t0 是y[i][k]的地址</span><br><span class="line">    l.d $f18, 0($t0)</span><br><span class="line">    mul.d $f16, $f18, $f16 # y[i][k] * z[k][j]</span><br><span class="line">    add.d $f4, $f4, $f16 # f4 &#x3D; x[i][j] + y[i][k]*z[k][j]</span><br><span class="line">    addiu $s2, $s2, 1 # k++</span><br><span class="line">    bne $s2, $t1, L3 # if(k!&#x3D;32) goto: L3</span><br><span class="line">    s.d $f4, 0($t2) # x[i][j] &#x3D; $f4</span><br><span class="line">    addiu $s1, $s1, 1 # $j &#x3D; j + 1</span><br><span class="line">    bne $s1, $t1, L2 # if( j!&#x3D; 32) goto : L2</span><br><span class="line">    addiu $s0, $s0, 1# i++</span><br><span class="line">    bne $s0, $t1, L1# if(i!&#x3D; 32) goto L1</span><br></pre></td></tr></table></figure>
<h2 id="精度误差">精度误差</h2>
<h3 id="grs">GRS</h3>
<p>双精度的尾数只有53位，即使包含了一个恒为1的隐藏位。但是他只能表述<span class="math inline">\(2^{53}\)</span>个数字，所以她表示的过程中一定是有一定的精度误差的，为了保证精度，IEEE754定义了一些额外的规则，比如这里的GRS。其中guard、round、sticky是53位以外有额外增加的三位。</p>
<ul>
<li>guard,保护位</li>
<li>round, 舍入位</li>
<li>sticky,黏贴位</li>
</ul>
<p><span class="math display">\[
F = 1.xxxxxxxxxxxxxxxxxxx\ G \ R \ S
\]</span></p>
<p>但是不是所有的处理器都实现了这样的操作，这是因为我们需要在硬件实现的成本、效率、市场等角度去做均衡。实际操作过程中，根据IEEE754，中间结果在右边至少应该增加两个附加位(guard &amp; round)：</p>
<ul>
<li>Guard bit(保护位)：在尾数部分右边的位</li>
<li>Rounding bit（舍入位）：在保护位右边的位</li>
</ul>
<p>附加位的作用：用于保护对阶时向右移的位或运算的中间结果</p>
<p>附加位的处理：</p>
<ul>
<li>左规的时候被移动到尾数中</li>
<li>作为舍入的依据</li>
</ul>
<h3 id="舍入方式">舍入方式</h3>
<figure>
<img src="https://imgconvert.csdnimg.cn/aHR0cDovL3NhaXl1d2FuZy1ibG9nLm9zcy1jbi1iZWlqaW5nLmFsaXl1bmNzLmNvbS8lRTclQkIlODQlRTYlODglOTAlRTUlOEUlOUYlRTclOTAlODYlRTclQUMlQUMlRTQlQjglODklRTclQUIlQTAlRTQlQjglOEIvaW1hZ2UtMjAyMDA0MTQwODU0NTc1MTAucG5n?x-oss-process=image/format,png" alt="" /><figcaption>image-20200414085457510</figcaption>
</figure>
<ul>
<li>一、就近舍入：舍入为最近可表示的数</li>
<li>二、朝正无穷舍入：舍入为Z2（正向）</li>
<li>三、朝负无穷舍入：舍入为Z1（负向舍入）</li>
<li>四、朝0方向舍入：截去，正数：Z1；负数：取Z2；</li>
</ul>
<h3 id="由计算顺序引起的误差">由计算顺序引起的误差</h3>
<p><img src="http://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0%E4%B8%8B/image-20200414085606233.png" alt="image-20200414085606233" style="zoom:50%;" /></p>
<p>比如说向上面的一样，我们的单精度数能够表示的数字个数有限，当范围过大时，克表示的最小单位会超过1，那么这时将1加入，1无法准确计算，只能作为舍入依据</p>
]]></content>
      <categories>
        <category>组成原理</category>
      </categories>
      <tags>
        <tag>大二下</tag>
        <tag>课内学习</tag>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>组成原理第三章(上)——ALU与整数的四则运算</title>
    <url>/2020/04/14/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%89%E7%AB%A0-%E4%B8%8A-%E2%80%94%E2%80%94ALU%E4%B8%8E%E6%95%B4%E6%95%B0%E7%9A%84%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="计算机组成原理第三章">计算机组成原理—第三章</h1>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><p>《计算机组成与设计：硬件/软件接口》——机械工业出版社</p></li>
<li><p>《Arithmetic for Computers》——Jiang Zhong</p></li>
<li><p>授课内容 —— 吴长泽老师</p></li>
</ul>
<h2 id="alu的构建">ALU的构建</h2>
<p>ALU就是运算器，这些内容都可以在书中的附录中找到，我们接下来看一个简单的例子</p>
<h3 id="逻辑的与或">逻辑的与、或</h3>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413025641380.png" alt="image-20200413025641380" style="zoom:50%;" /></p>
<p>可以看到，这里有两个输入，a、b，他们分别连接到了一个与门和一个或门，他们分别与和或的结果又连接到了一个多路选择器上，Select用于控制到底是做与运算还是做或运算，Select = 0时，做与，Select = 1的时候我们就做或运算。</p>
<h3 id="回归正题加法半加器">回归正题，加法——半加器</h3>
<p>为了达到计算的目的，我们需要构建最基础的运算单元，那就是半加器。半加器是什么？半加器可以接收两个相加的数，然后给出他们相加的和以及他们的进位，但是他没有接受低位的进位，所以它叫半加器。</p>
<pre class="mermaid">
graph LR

a --> halfAdder

b --> halfAdder

halfAdder --> sum

halfAdder --> carry</pre>
<p>我们先来构建一个真值表:</p>
<div class="line-block">a | b | result | carry |</div>
<div class="line-block">---- | ---- | ------ | ----- |</div>
<div class="line-block">0 | 0 | 0 | 0 |</div>
<div class="line-block">0 | 1 | 1 | 0 |</div>
<div class="line-block">1 | 0 | 1 | 0 |</div>
<div class="line-block">1 | 1 | 0 | 1 |</div>
<p>根据真值表可以构建出表达式：</p>
<p>$$</p>
<p>Sum = b +a\</p>
<p>Carry = ab</p>
<p>$$</p>
<p>根据表达式可以构建出电路：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413030612265.png" alt="image-20200413030612265" style="zoom:50%;" /></p>
<h3 id="全加器">全加器</h3>
<h4 id="真值表">真值表</h4>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413030758347.png" alt="image-20200413030758347" style="zoom:67%;" /></p>
<h4 id="表达式">表达式</h4>
<p>$$</p>
<p>Sum = A xor B xor CarryIn \</p>
<p>CarryOut = B CarryIn + A CarryIn + A B</p>
<p>$$</p>
<h4 id="电路">电路</h4>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413031042132.png" alt="image-20200413031042132" style="zoom:50%;" /></p>
<p>有了加法器之后，我们就可以做很多的运算了，以加法为例，只需要将很多全加器串在一起就可以构成一个多位整数的加法器。</p>
<h3 id="bit-alu">1 bit ALU</h3>
<p>有了上面的这些积累之后，我们就可以实现一个有以下功能的ALU:</p>
<ul>
<li><p>AND</p></li>
<li><p>OR</p></li>
<li><p>ADD</p></li>
</ul>
<p>其实实现的方法也非常简单，就是对刚才的多路选择器做一个拓展，把全加器加进来就可以了。</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413031641887.png" alt="image-20200413031641887" style="zoom: 50%;" /></p>
<h3 id="basic-32-bit-alu">Basic 32 bit ALU</h3>
<p>那么有了一个1 bit ALU之后，就可以把32个1 bit ALU级联在一起，就可以形成一个32位的ALU</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413031830822.png" alt="image-20200413031830822" style="zoom:50%;" /></p>
<p>但是值得注意的是，级联的运算器的数目越多，它的体积、成本以及出错概率都会相应的上升，他的可靠性、成本都会有所下降，所以往往不会以1bitALU为基础进行级联，而是会以多位的ALU为基础在进行级联，这样能够降低成本、增加准确率。</p>
<h3 id="扩展1-bit-alu">扩展1 bit ALU</h3>
<p>我们还希望我们的这个ALU可以完成减法操作，那么应该怎么做呢？我们都知道，假如说要完成<span class="math inline">\(a-b\)</span>的操作，那么实际上完成的是<span class="math inline">\(a\)</span>加上<span class="math inline">\(b\)</span>的补码。<span class="math inline">\(b\)</span>的补码就是对<span class="math inline">\(b\)</span>进行取反，然后加一。那么这一系列的操作反应在电路中实际上就是：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413032402505.png" alt="image-20200413032402505" style="zoom: 50%;" /></p>
<p>如果我们要进行减法运算，那么我们就需要将<span class="math inline">\(Binvert\)</span>设置为1这样就完成了对b的取反操作，同时，我们需要将最低位的<span class="math inline">\(Carryin\)</span>的值改为1，就可以完成上面说的加一的操作。这样我们在没有添加过多的逻辑单元的情况下就完成了从加法器到加法、减法器的扩展。</p>
<p>那么经过扩展后，我们的功能有：</p>
<ul>
<li><p>AND</p></li>
<li><p>OR</p></li>
<li><p>ADD</p></li>
<li><p>Subtract</p></li>
</ul>
<p>我们发现缺少了比较操作：</p>
<ul>
<li><p>Slt rd, rs, rt; 也就是比较功能</p></li>
<li><p>如果rs &lt; rt， rd = 1 否则 为0</p></li>
</ul>
<p>那么怎么去做呢？我们可以是用减法来完成这一功能，我们可以做<span class="math inline">\(rs - rt\)</span>的操作，如果结果是负数，那么就表示<span class="math inline">\(rs&lt;rt\)</span>。接下来看电路：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413033818472.png" alt="image-20200413033818472" style="zoom:50%;" /></p>
<p>这里的less是负责接收高位信息的，因为我们在判断两个多位整数的大小的时候，是不能通过低位去判断的，所以我们需要这种机制来进行。大家觉得没讲透的话可以继续往下看，一会会讲到级联后的这个，到时候会好理解一些。</p>
<p>那么除了设置比较之外，我们还需要去做一个溢出探测。溢出是指有限的符号位无法表示我们的结果了。溢出是通过最高位和符号位进行判断。</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413034346563.png" alt="image-20200413034346563" style="zoom:50%;" /></p>
<p>这里也是先挖个坑，等下再来填。</p>
<h3 id="compute-alu">Compute ALU</h3>
<p>输入：</p>
<ul>
<li><p>A</p></li>
<li><p>B</p></li>
</ul>
<p>控制量：</p>
<ul>
<li><p>Binvert：是否反转</p></li>
<li><p>Operation：选择做什么运算的，其实就是那个选择器</p></li>
<li><p>Carryin：上一个数的进位</p></li>
</ul>
<p>输出：</p>
<ul>
<li><p>Result</p></li>
<li><p>Overflow</p></li>
</ul>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413034609661.png" alt="image-20200413034609661" style="zoom:50%;" /></p>
<p>哒哒哒敲黑板开始填坑了：观察这个电路我们可以发现，高位的结果连接到了最低位的Less上，如果<span class="math inline">\(Operation\)</span>是加法而且<span class="math inline">\(Binvert\)</span>是1也就是进行反转，而且<span class="math inline">\(Carryin\)</span>是1的话，就代表着我们在做A-B的操作。A-B后，如果高位是1的话，那么就说明A&gt;B，否则就说明<span class="math inline">\(A \leq B\)</span>，这样就完成了简单的判断大小的操作。</p>
<p>如果到这里你还是看不懂，那么不慌，我们详细的讲一下，假如说我们现在有两个4位有符号数A = 3,B=4</p>
<p>我们要对比它们的大小，那么就需要先进行A-B的操作，为执行该操作，我们先对B进行取补码的操作：</p>
<ul>
<li><p>B = <span class="math inline">\(0100_2\)</span></p></li>
<li><p><span class="math inline">\(B_补=not(0100) + 0001 = 1011+0001=1100\)</span></p></li>
<li><p><span class="math inline">\(A-B = A+B_补 = 0011+1100 = 1111\)</span>最高位为1，说明A&lt;B</p></li>
</ul>
<p>接下来看第二种情况，<span class="math inline">\(A=4,B=3\)</span>，判断A、B大小</p>
<ul>
<li><p>B = <span class="math inline">\(0011_2\)</span></p></li>
<li><p><span class="math inline">\(B_补=not(0011_2) + 0001_2 = 1100_2+0001_2=1101_2\)</span></p></li>
<li><p><span class="math inline">\(A-B = A+B_补 = 1101_2 + 0100_2 = 0001_2\)</span>，最高位为0，说明<span class="math inline">\(A \not &lt; B\)</span></p></li>
</ul>
<p>相信大家一定看懂了，如果看不懂，那就把上面的部分再看一遍，还是看不懂建议再去复习一下二进制表示部分的内容。接下来还需要增加一个功能，因为我们时常需要判断相加的结果是否为0，所以我们想要添加一个判断是否为0的门，原理也很简单，如果每一位都是0的话，那么结果也一定为0，把人话翻译成机器语言就是所有Result进行或运算，如果是0的话那么就说明都是0，反之就说明不是0，那么对结果取反后，如果不是0那么就输出1，反之就是0，电路如下。</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413051637383.png" alt="image-20200413051637383" style="zoom: 50%;" /></p>
<h3 id="alu-symbol-control">ALU symbol &amp; control</h3>
<p>我们将上面的级联电路进行封装，就得到了一个ALU，示意图如下：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413051923724.png" alt="image-20200413051923724" style="zoom:50%;" /></p>
<p>ALU operation的值与其对应的操作如下:</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413051957833.png" alt="image-20200413051957833" style="zoom:50%;" /></p>
<p>ALU的构建部分到此结束了。</p>
<h2 id="整数加减法">整数加减法</h2>
<h3 id="数的表示范围">数的表示范围：</h3>
<p>有一个n位的二进制整数</p>
<ul>
<li><p>有符号:</p>
<ul>
<li><p>正数：<span class="math inline">\(2^{n-1}-1\)</span></p></li>
<li><p>负数：<span class="math inline">\(2^{n-1}\)</span></p></li>
</ul></li>
<li><p>无符号：<span class="math inline">\(2^n-1\)</span></p></li>
</ul>
<p>什么样子的数进行运算会溢出呢？</p>
<ul>
<li><p>正数负数相加：不会发生溢出</p></li>
<li><p>两个正数相加：可能溢出</p></li>
<li><p>两个负数相加：可能溢出</p></li>
</ul>
<h3 id="整数的减法">整数的减法</h3>
<p>很简单，我们上面也有所提及，<span class="math inline">\(A-B=A+B_补\)</span>，在这里我们主要讨论在什么情况下会发生溢出。</p>
<h4 id="什么时候溢出">什么时候溢出？</h4>
<ul>
<li><p>两个正数相减或两个负数相减：不会溢出，因为结果的绝对值一定比两者绝对值一定比两者绝对值的最大值小，人话听不懂，但是用数学语言描述就看得懂了：</p>
<p>$$</p>
<p>if (A B)(A B):\</p>
<p>|A-B|max(|A|,|B|)</p>
<p>$$</p></li>
<li><p>正数减负数：可能发生溢出</p></li>
<li><p>负数减正数：可能发生溢出</p></li>
</ul>
<h4 id="溢出处理">溢出处理</h4>
<p>发生溢出的时候，通常的做法是：将PC的值存到EPC中，其中PC的值代表当前指令，EPC代表发生错误的指令，执行这步操作，实际上在干的事情就是：记录下来，这个语句出错了。</p>
<p><span class="math inline">\(mfc0\)</span>指令可以进行异常处理并且返回到当前指令继续执行。</p>
<h3 id="加法器的速度问题">加法器的速度问题</h3>
<h4 id="问题">问题</h4>
<p>常用的方法是使用串行的处理方式，也就是先计算低位，然后从低位到高位依次计算，如下图所示：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413053913521.png" alt="image-20200413053913521" style="zoom: 33%;" /></p>
<p>这样计算的效率很低，这是由于后方的运算需要等待前方的进位完成才能够进行计算。如果我们能够预先知道上一位的进位的话，就可以极大地加快效率。</p>
<h4 id="解决">解决</h4>
<p>我们可以将这个串行的电路改成一个两层的逻辑，这样可以极大的提升他的计算速度，但是这样的改动是有巨大的代价的，代价就是：需要很多的输入门，导致电路的体量很大。下面有一些解决方案：</p>
<h5 id="超前进位加法器">超前进位加法器</h5>
<p>核心思路：将需要进位的值和计算的值进行分离。</p>
<p>$$</p>
<p>Generate : g_i = a_i*b_i</p>
<p>$$</p>
<p>$$</p>
<p>Propagate : p_i = a_i  xor  b_i</p>
<p>$$</p>
<p>我们先来看上面的两个符号，<span class="math inline">\(Generate\)</span>代表当前位的结果，<span class="math inline">\(Propagate\)</span>代表当前位的进位。我们很容易得到当前位的结果为<span class="math inline">\(a_i\ xor\ b_i\)</span>，进位的结果是<span class="math inline">\(a_i \and b_i\)</span>。</p>
<p>接下来我们再来关注一下上一位的进位和最终结果之间的关系，我们定义符号<span class="math inline">\(C_i\)</span>表示来自上一位的进位</p>
<div class="line-block"><span class="math inline">\(a_i\)</span> | <span class="math inline">\(b_i\)</span> | <span class="math inline">\(c_i\)</span> | C（进位） | S（当前位） |</div>
<div class="line-block">----- | ----- | ----- | --------- | ----------- |</div>
<div class="line-block">0 | 0 | 0 | 0 | 0 |</div>
<div class="line-block">0 | 0 | 1 | 0 | 1 |</div>
<div class="line-block">0 | 1 | 0 | 0 | 1 |</div>
<div class="line-block">0 | 1 | 1 | 1 | 0 |</div>
<div class="line-block">1 | 0 | 0 | 0 | 0 |</div>
<div class="line-block">1 | 0 | 1 | 1 | 0 |</div>
<div class="line-block">1 | 1 | 0 | 1 | 0 |</div>
<div class="line-block">1 | 1 | 1 | 1 | 0 |</div>
<p>接下来我们来写一下这个表达式：</p>
<p>$$</p>
<p><span class="math display">\[\begin{align}

    \begin{array}

         CC &amp;= (c_i\and b_i\and not(a_i)) \or (a_i\and not(b_i)\and c_i)\or(a_i\and b_i\and not(c_i))\or (a_i\and b_i\and c_i)

    \end{array}

\end{align}\]</span></p>
<p>$$</p>
<p>我们将这个表达式进行化简，就可以得到最终的结果：</p>
<p>$$</p>
<p>C_0 = (a   xor  b )c + ab</p>
<p>$$</p>
<p>计算过程如下( 写字烂，勿喷)，由于篇幅原因这里省略了很多中间步骤：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413063746627.png" alt="image-20200413063746627" style="zoom: 67%;" /></p>
<p>根据这个过程我们可以构造出相应的全加器电路：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413063833244.png" alt="image-20200413063833244"  /></p>
<p>下面的图中给出了超前进位加法，在多位运算中的式子:</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413064001556.png" alt="image-20200413064023371" style="zoom:50%;" /></p>
<p>我们可以把原来串行的加法器拆分成四个一组，在每一组中进行超前进位加法，然后再将多个四位的超前进位加法器级联在一起，就可以达到使计算速度增加，但又不过度使用计算资源的效果。</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413064201321.png" alt="image-20200413064201321" style="zoom:50%;" /></p>
<p>下图所示的是一个四位的超前进位加法器：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413064323970.png" alt="image-20200413064323970" style="zoom: 33%;" /></p>
<p>我们可以对他进行封装，并且进行级联即可获得更高位的快速加法器:</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413064404843.png" alt="image-20200413064404843" style="zoom:50%;" /></p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413064432856.png" alt="image-20200413064432856" style="zoom:50%;" /></p>
<p>我们对比两种方式：</p>
<ul>
<li><p>一、组内使用超前进位，组间串行：如上方左图所示。</p></li>
<li><p>二、组内使用超前进位，组间超前进位：如上方右图所示。</p></li>
</ul>
<h3 id="多媒体中的饱和操作">多媒体中的饱和操作</h3>
<p>当正向溢出时，值保留在最大可表示值。</p>
<p>当反向溢出时，值保留在最小可表示值。</p>
<h2 id="二进制乘法">二进制乘法</h2>
<h3 id="整数">整数</h3>
<p>二进制乘法和十进制乘法的运算是一样的，我们可以看一个例子：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413075433008.png" alt="image-20200413075433008" style="zoom:50%;" /></p>
<p>我们可以将这个过程用一个流程图来表示：</p>
<pre class="mermaid">
graph TD

A(开始计算) --> B{乘数最低位=?}

B --> |最低位=1|C[结果+=被乘数]

B --> |最低为=0|D[被乘数左移一位]

C --> D

D --> E[乘数右移一位]

E --> F{是否进行了32次?}

F --> |否|B

F --> |是|G(结束)</pre>
<p>其中，被乘数左移一位，就相当于我们在使用竖式计算十进制乘法时，每过一位都要将新的得数向左移一位一样。而乘数向右移一位实际上就是更换将要检测的位数，这样就可以保证每次都检查最低位就可以了。</p>
<h3 id="定点小数的乘法">定点小数的乘法</h3>
<h4 id="方法">方法</h4>
<p>假设有两个定点小数：</p>
<p>$$</p>
<p>x = 0.x_1x_2x_3...x_n \</p>
<p>y = 0.y_1y_2y_3...y_n</p>
<p>$$</p>
<p>我们可以将<span class="math inline">\(x·y\)</span>表示成下面的式子：</p>
<p>$$ <span class="math display">\[\begin{align}

    \begin{array}

    xx*y &amp;= x(2^{-1}y_1+2^{-2}y_2+...+2^{-n}y_n)\\

    &amp; = 2^{-1}(y_1x+2^{-1}(y_2x+2^{-1}(…+2^{-1}(y_{n-1}x+2^{-1}(y_nx+0))…)))

    \end{array}

\end{align}\]</span> $$</p>
<p>据此我们可以得到一个通项公式:</p>
<p>$$</p>
<p><span class="math display">\[\begin{align}

    \begin{array}

    . z_0 &amp;=0\\

    z_1 &amp;= 2^{-1}(y_nx+z_{0})\\

    z_2 &amp;= 2^{-1}(y_{n-1}x+z_{1})\\

    ...\\

    z_i &amp;= 2^{-1}(y_{n-i+1}x+z_{i-1})\\

    ...\\

    z_n &amp;= x*y =  2^{-1}(y_1x+z_{n-1})

    

    \end{array}

\end{align}\]</span></p>
<p>$$</p>
<p>所以每次只需要相加两个数，然后向后移一位，且相加的数只有n位，因此不需要2n位的加法器。</p>
<h4 id="示例">示例</h4>
<p>计算：<span class="math inline">\(x = 0.1101,y= 0.1011,x*y = ?\)</span></p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/IMG_20200413_165014.jpg" alt="IMG_20200413_165014" style="zoom: 25%;" /></p>
<h4 id="流程图">流程图</h4>
<p>为了方便理解，我做了一个流程图</p>
<p>假设有问题n位定点小数乘法：</p>
<pre class="mermaid">
graph TD

A(开始) --> B{y最低位是什么}

B --> |y最低一位是1|C[result += x]

C --> D[result右移一位]

B --> |y最低一位是0|D

D --> E[y右移一位]

E --> F{是否进行n次}

F --> |已经进行n次|G(结束)

F --> |没有进行n次|B</pre>
<h3 id="乘法优化">乘法优化</h3>
<p>我们看到刚才的计算过程，y有多少位就需要做多少个轮次的加法，这样的效率是非常之低的。这里优化的主要思想是：并行。</p>
<h4 id="第一种阵列乘法">第一种：阵列乘法</h4>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413090035787.png" alt="image-20200413090035787" style="zoom:50%;" /></p>
<p>我个人认为，这种乘法器的思想和超前进位的思想有一点相似，它将我们竖式中需要计算的都先计算出来，然后再对他们进行加法即可。</p>
<h4 id="第二种树型乘法器">第二种：树型乘法器</h4>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413092103537.png" alt="image-20200413092103537" style="zoom:67%;" /></p>
<p>树形乘法器，就是将32位的结果分别算出来，然后再用树形结构进行归并相加，这样就只用<span class="math inline">\(logn\)</span>级的轮次就可以算出结果。</p>
<h3 id="乘法在mips中">乘法在MIPS中</h3>
<p>在MIPS中，我们将乘法的结果放到了两个专有的寄存器中：</p>
<ul>
<li><p>HI：存储高32位</p></li>
<li><p>LO：存储低32位</p></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mult rs, rt</span><br><span class="line"></span><br><span class="line">multu rs, rt</span><br><span class="line"></span><br><span class="line"># 这两条指令是将 rs*rt的结果存到我们刚才说的HI、LO寄存器中</span><br><span class="line"></span><br><span class="line">mfhi rd # 读取HI到rd</span><br><span class="line"></span><br><span class="line">mflo rd # 读取LO到rd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mul rd, rs, rt # 将rs*rt的低32位赋给rd</span><br></pre></td></tr></table></figure>
<h3 id="除法">除法</h3>
<h4 id="除法及其硬件结构">除法及其硬件结构</h4>
<h5 id="第一种方法恢复余数法">第一种方法:恢复余数法</h5>
<h6 id="算法流程">算法流程</h6>
<pre class="mermaid">
graph TD

A(开始) --> B[从余数寄存器中减去除数寄存器的内容,将结果放在余数寄存器中]

B --> C{测试余数}

C --> |余数大于等于0| D[商寄存器左移,最低位设为1]

C --> |余数小于0| E[通过给余数寄存器加上除数寄存器内容来恢复原值,结果放在余数寄存器.商同样左移,最低位设为0]

D --> F[除数寄存器右移一位]

E --> F[除数寄存器右移一位] 

F --> G{第33次重复?}

G --> |是第33次|H(结束)

G --> |否,小于33次|B</pre>
<h6 id="硬件结构">硬件结构</h6>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413203829386.png" alt="image-20200413203829386" style="zoom:50%;" /></p>
<h6 id="讲解">讲解</h6>
<p>回复余数法是一种非常暴力的方法，为什么暴力呢，听我慢慢道来：</p>
<p>上面框图一大堆，看起来很麻烦的样子。单核心的操作非常简单，那就是：从高位的解开始尝试，先把余数给减了，如果不行的话，再恢复回来，如果行的话，那就保留。</p>
<h6 id="优化">优化</h6>
<p>与优化乘法的方式相似，只用左移余数的方法就可以完成操作，方法如下：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200413211400148.png" alt="image-20200413211400148" style="zoom:50%;" /></p>
<h5 id="更快速的除法">更快速的除法</h5>
<p>因为除法中存在减法操作，所以不能像之前的乘法一样优化，但是我们可以通过同时生成多位商的方法进行操作，或是查表法、不执行除法等方法进行优化。</p>
<h5 id="mips在除法中">MIPS在除法中</h5>
<p>和乘法一样，除法也用到了HI和LO两个寄存器，他们分别用于储存余数、除数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">div rs, rt</span><br><span class="line"></span><br><span class="line">divu rs, rt</span><br><span class="line"></span><br><span class="line">mfhi s1</span><br><span class="line"></span><br><span class="line">mflo s1</span><br></pre></td></tr></table></figure>
<p>今天就讲到这里，明天再继续吧。</p>
]]></content>
      <categories>
        <category>组成原理</category>
      </categories>
      <tags>
        <tag>大二下</tag>
        <tag>课内学习</tag>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>python图像处理笔记-三——Harris角点检测器</title>
    <url>/2020/04/13/python%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0-%E4%B8%89%E2%80%94%E2%80%94Harris%E8%A7%92%E7%82%B9%E6%A3%80%E6%B5%8B%E5%99%A8/</url>
    <content><![CDATA[<h1 id="图形学笔记三-harris角点检测器">图形学笔记（三）—— Harris角点检测器</h1>
<h2 id="前言">前言</h2>
<p>从现在开始学习的是书中的第二章：局部图像描述子。这里主要是寻找图像间的对应点和对应区域。</p>
<h2 id="harris角点检测器">Harris角点检测器</h2>
<h3 id="参考资料">参考资料</h3>
<ul>
<li>Jan Erik Solem. Python计算机视觉编程 (图灵程序设计丛书) (p. 33). 人民邮电出版社. Kindle 版本.</li>
<li>人工智能：harris角点检测_<a href="https://www.bilibili.com/video/BV1JE411f7iG?from=search&amp;seid=6288544590541875218" target="_blank" rel="noopener">bilibili</a></li>
<li>harris corner detection(角点检测)_<a href="https://www.bilibili.com/video/BV1Wb411b79B?from=search&amp;seid=6288544590541875218" target="_blank" rel="noopener">bilibili</a></li>
<li>【机器学习】【线性代数 for PCA】矩阵与对角阵相似、 一般矩阵的相似对角化、实对称矩阵的相似对角化_<a href="https://blog.csdn.net/u012421852/article/details/80489727" target="_blank" rel="noopener">csdn</a></li>
<li>线代022｜矩阵的相似对角化 看过有收获，真心分享给大家_<a href="https://www.bilibili.com/video/BV1iJ411u77D?from=search&amp;seid=4427364463745926667" target="_blank" rel="noopener">bilibili</a></li>
</ul>
<h3 id="什么是角点">什么是角点?</h3>
<p>说白了就是物体边缘的拐点</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200412133125796.png" alt="image-20200412133125796" style="zoom: 80%;" /></p>
<p>上面图像中的红点处就是角点，有了角点之后，就可以干很多的事情了。</p>
<h3 id="harris检测角点的核心思路">Harris检测角点的核心思路</h3>
<p>Harris的核心思路是滑动窗口检测，这里我们将图像中的点分三类进行讨论：</p>
<ul>
<li><p>一、平坦点：在图像的某个像素点周围是平坦的，如图所示：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200412133537098.png" alt="image-20200412133537098" style="zoom:67%;" /></p>
<p>平坦点的周围的像素值没有太大的变化。</p></li>
<li><p>二、边缘点：像素点位于一条边上</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200412133612077.png" alt="image-20200412133612077" style="zoom:67%;" /></p>
<p>边缘点的周围的像素向某个方向变化较为剧烈。</p></li>
<li><p>三、角点：像素点位于一个角上</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200412133958279.png" alt="image-20200412133958279" style="zoom:67%;" /></p>
<p>角点的周围各个方向上像素的变化都比较剧烈。</p></li>
</ul>
<h4 id="moravec">Moravec</h4>
<p>知道了这三类情况后，我们来看公式： <span class="math display">\[
E(u,v) = \Sigma_{x,y}w(x,y) [I(x+u,y+v) - I(x,y)]^2
\]</span> 其中，<span class="math inline">\(E(u,v)\)</span>表示竖直和水平方向的偏移，<span class="math inline">\(w(x,y)\)</span>表示窗口的中心，<span class="math inline">\(I(x+u,y+v)\)</span>表示中心增加偏移后的灰度值，<span class="math inline">\(I(x,y)\)</span>表示中心的灰度值。</p>
<p>这个公式就代表着某个点附近的变化的剧烈程度，<span class="math inline">\(w(x,y)\)</span>是一个滤波（常用高斯）。那么结合上面的理论，这个点的<span class="math inline">\(E(u,v)\)</span>越大，那么它就越有可能是个角点。但是值得注意的是，这种方法没有旋转不变性。</p>
<h4 id="harris">Harris</h4>
<h5 id="泰勒展开">泰勒展开</h5>
<p>Moravec的缺点是，他只考虑了四种方向，所以他没有旋转不变性。而Harris将方向进行了细化。于是Harris使用全微分的方法将方向进行了细化，具体来说，是用了泰勒展开。</p>
<p>先复习一下什么是泰勒展开： <span class="math display">\[
f(x+u,y+v) \approx f(x,y) +uf_x(x,y)+vf_y(x,y)
\]</span> 上面的式子是二变量函数的一阶展开，细心如你能发现上面的式子里表示中心增加偏移后的灰度值的式子可以使用泰勒展开！经过一番计算之后可以得到这样一个式子。</p>
<p>计算过程也是非常简单的：</p>
<p><span class="math display">\[
\begin{align*}
E(u,v) &amp;= \Sigma_{x,y}w(x,y) [I(x+u,y+v) - I(x,y)]^2 \\
&amp;=w(x,y)\Sigma_{x,y}[I(x,y)+uI_x(x,y)+vI_y(x,y) - I(x,y)]^2 \\
&amp;=w(x,y)\Sigma_{x,y}[uI_x(x,y)+vI_y(x,y)]^2 \\
&amp;=w(x,y)\Sigma_{x,y}[u^2I_x(x,y)^2+v^2I_y(x,y)^2+2uvI_x(x,y)I_y(x,y)] \\
\end{align*}
\]</span></p>
<p>将最终的结果简写一下，就可以得到:</p>
<p><span class="math display">\[
E(u,v) = \Sigma_{x,y}w(x,y) (u^2I_x^2+v^2I_y^2+2uvI_xI_y)
\]</span></p>
<h5 id="矩阵表示">矩阵表示</h5>
<p>这里<span class="math inline">\(I_x,I_y\)</span>代表图像在水平、垂直方向上的梯度，我们将这个式子用矩阵来表示（从现在开始就是书上写的了）： <span class="math display">\[
E(u,v) = [u,v] 
\left(
    \Sigma w(x,y) 
    \left[
        \begin{matrix}
            I_x^2&amp;I_xI_y\\
            I_xI_y&amp;I_y^2
        \end{matrix}
    \right]
\right)
\left[
    \begin{matrix}
        u\\
        v
    \end{matrix}
\right]
\]</span></p>
<p>最后再来个特殊表示：</p>
<p><span class="math display">\[
E(u,v) =
\left[
    \begin{matrix}
        u &amp; v
    \end{matrix}
\right]
M_I
\left[
    \begin{matrix}
        u\\
        v
    \end{matrix}
\right]
\]</span></p>
<p>那么问题来了，我们做了这么多东西，不就是用泰勒展开了一下Moravec的式子，然后用矩阵表示了一下么？我们到底是怎么消除其旋转不变性的呢？</p>
<p>下面来到了这个算法的关键步骤：</p>
<h5 id="相似对角化">相似对角化</h5>
<p>我们看到上面的式子<span class="math inline">\(E(u,v) =\left[\begin{matrix} u &amp; v \end{matrix}\right]M_I\left[\begin{matrix} u \\ v \end{matrix}\right]\)</span>我们使用矩阵相似对角化就可以得到下面的式子： $$</p>
<p>E(u,v) = PP^{-1}</p>
<p>$$</p>
<h6 id="什么是相似对角化">什么是相似对角化？</h6>
<p>那么在此之前，我们来复习一下到底什么是矩阵相似对角化呢？（我也忘了）</p>
<ul>
<li><p>定义一：设A、B都是n阶矩阵，若存在可逆矩阵<span class="math inline">\(P\)</span>，使得: <span class="math display">\[
\begin{align*}
P^{-1} AP = B
\end{align*}
\]</span> 则称为矩阵A和矩阵B相似</p></li>
<li><p>定义二：如果方阵A与对角阵相似，则一定存在一个可逆矩阵P，按照下面公式求出方阵A的相似对角矩阵： <span class="math display">\[
\begin{align*}
  \Lambda = PAP^{-1}
\end{align*}
\]</span></p></li>
</ul>
<p>相似对角化就是求出来这个对角矩阵<span class="math inline">\(\Lambda\)</span>（好久没碰线性代数了，如果理解有误欢迎指出）</p>
<p>那么怎么算这个<span class="math inline">\(\Lambda\)</span>呢？在此之前我们需要知道什么样的矩阵能够被相似对角化。 <span class="math display">\[
\begin{align*}
    一个矩阵可以被特征化 \Leftrightarrow 该矩阵有n个线性无关的特征向量
\end{align*}
\]</span> 又有一条件：属于不同特征值的特征向量一定线性无关（这里不能再深挖了，在深挖没完了，有兴趣的自己深挖）</p>
<p>那么根据上面的两个条件，我们可以知道：如果n阶方阵A有n个不相等的特征值，那么说明A可以被相似对角化。而如果A有重特征值，那么检查重特征值对应的线性无关的特征向量的个数若等于特征值的重数，那么就代表A可对角化。另外还有特殊情况：</p>
<ul>
<li>若A为n阶对称阵，那么A可对角化</li>
</ul>
<h6 id="进行相似对角化">进行相似对角化</h6>
<p>那么根据上面的理论，我们的这个： <span class="math display">\[
M_I  = 
\left[
\begin{matrix}
I_x^2&amp;I_xI_y\\
I_xI_y&amp;I_y^2
\end{matrix}
\right]
\]</span> 他显然是一个对称矩阵，所以根据上面的定理他是可以相似对角化的，我们对它使用相似对角化就可以得到上面的式子中的一部分： <span class="math display">\[
M_I  =P\left[    \begin{matrix}        \lambda_1 &amp; 0\\        0 &amp; \lambda_2\\    \end{matrix}\right]P^{-1}
\]</span> 将这部分带入即可得到我们的式子： <span class="math display">\[
E(u,v) = \left[    \begin{matrix}        u &amp; v    \end{matrix}\right]P\left[    \begin{matrix}        \lambda_1 &amp; 0\\        0 &amp; \lambda_2\\    \end{matrix}\right]P^{-1}\left[    \begin{matrix}        u\\        v    \end{matrix}\right]
\]</span> 我们可以先计算<span class="math inline">\([u\ v]P\)</span>以及<span class="math inline">\(P^{-1}\left[ \begin{matrix} u\\ v \end{matrix}\right]\)</span>，假设得到的结果是<span class="math inline">\([u&#39;\ v&#39;]\)</span>以及<span class="math inline">\([u&#39;\ v&#39;]^T\)</span>，那么我们上面的式子就可以改写为： $$ <span class="math display">\[\begin{align}
\begin{array}

E E(u,v) &amp;= \left[
\begin{matrix}
u&#39; &amp; v&#39;    
\end{matrix}
\right]

\left[    
\begin{matrix}
\lambda_1 &amp; 0\\
0 &amp; \lambda_2\\ 
\end{matrix}
\right]

\left[  
\begin{matrix} 
u&#39;\\      
v&#39;  
\end{matrix}
\right] 
\\
&amp;= \lambda_1(u&#39;)^2+\lambda_2(v&#39;)^2\\
&amp;= \frac{u&#39;^2}{\frac{1}{\lambda_1}}+\frac{v&#39;^2}{\frac{1}{\lambda_21}}
\end{array}
\end{align}\]</span> $$ 好的，到了这里大家打眼一看就知道了，这是椭圆公式啊！那么我们对比一下原来椭圆的公式：<span class="math inline">\(\frac{x^2}{a^2}+\frac{y^2}{b^2}\)</span>在这里我们可以写为：<span class="math inline">\(a^2 = \frac{1}{\lambda_1}\)</span>那么我们就可以知道<span class="math inline">\(a = \lambda_1^{-\frac{1}{2}}\)</span>，同理可得<span class="math inline">\(b = \lambda_2^{-\frac{1}{2}}\)</span></p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200412152559928.png" alt="image-20200412152559928" style="zoom:67%;" /></p>
<h4 id="回到问题本身">回到问题本身</h4>
<p>我们看一些图</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200412142519387.png" alt="image-20200412142519387" style="zoom:67%;" /></p>
<p>如果我们取点附近窗口的梯度的话，我们可以看到:</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200412142725820.png" alt="image-20200412142725820" style="zoom:67%;" /></p>
<p>上面的三个图像分别代表：</p>
<ul>
<li>左-平坦点附近窗口内的梯度：离原点普遍较近</li>
<li>中-边缘点附近的窗口的梯度：分布在某个坐标轴周围</li>
<li>右-角点附近的窗口的梯度：分布在两个坐标轴周围</li>
</ul>
<p>我们的目标是：让这个椭圆的两个半轴尽量的长，用数学语言来表示就是：让<span class="math inline">\(\lambda_1,\lambda_2\)</span>尽量的大，有一张图非常的形象：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200412152745271.png" alt="image-20200412152745271" style="zoom: 50%;" /></p>
<p>再把我们的目标明确一下：我们希望<span class="math inline">\(\lambda_1,\lambda_2\)</span>同时很大但又差不多大于是我们构建出了这样的式子： <span class="math display">\[
R = det({M_\lambda}) - k trace({M_\lambda})^2
\]</span> 相信很多同学和我一样，已经忘记了这些符号，或者根本没有学过这些符号，那么我来解释一下：</p>
<ul>
<li><span class="math inline">\(det:\)</span>矩阵的行列式，如果你不知道什么是行列式，那你只能自己百度了</li>
<li><span class="math inline">\(trace:\)</span>矩阵的迹主对角线上各个元素的总和</li>
</ul>
<p>反应在这个式子里：</p>
<ul>
<li><span class="math inline">\(M_\lambda = \left[\begin{matrix}\lambda_1&amp;0\\0&amp;\lambda_2\end{matrix}\right]\)</span></li>
<li><span class="math inline">\(det({M_\lambda}) = \lambda_1\lambda_2\)</span></li>
<li><span class="math inline">\(trace({M_\lambda})=\lambda_1+\lambda_2\)</span></li>
</ul>
<p>所以我们的式子也可以写成： <span class="math display">\[
R = \lambda_1\lambda_2 + t(\lambda_1+\lambda_2)^2
\]</span> 如果这个R很大的话，就说明这里是角点，如果这个R很小的话，那么就不是。值得注意的是，这个R评分并不是一个准确的描述问题的机制，拓展一下，这类问题属于病态的问题，也就是说我们无法找到一种准确的方式来描述这个问题，只能通过近似的方式来描述它。放到这个例子里就是我们人眼很容易观测出一个点是不是角点，也可以说出来很多抽象的方法来判断它是否是角点。但之所以我们能够这么轻易的去判断，是因为我们有足够的抽象能力，什么是角点？角点是在角上的点。我们之所以能够如此轻易的判断，是因为我们将角这个概念进行了抽象和封装，而计算机不会。所以我们只能使用像是上面R这种方法来近似地描述问题。（不废话了，继续讲）</p>
<h3 id="实际计算">实际计算</h3>
<p>但是上面说的东西怎么量化的来算呢？我们先计算每个像素点的M矩阵 <span class="math display">\[
M =
\Sigma
 w(x,y)
\left[
\begin{matrix}
I_x^2&amp;I_xI_y\\
I_xI_y&amp;I_y^2
\end{matrix}
\right]
\]</span> 这里的<span class="math inline">\(I_x,I_y\)</span>也就是图像在水平、垂直方向的导数，可以用可以用Sobel核去做一个卷积就可以得到。然后这个window函数可以使用高斯核等。该卷积的目的是得到<span class="math inline">\(M_I\)</span>在周围像素上的局部平均。</p>
<p>可以看到计算的方法很简单，也没啥好讲的，理论懂了就万事大吉了，最终我们使用这两项的比值来衡量这个问题： <span class="math display">\[
finalScore = \frac{det({M})}{trace({M})^2}
\]</span></p>
<h3 id="代码">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy. ndimage <span class="keyword">import</span> filters</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算比值得分的函数,即计算finalScore</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">computeHarrisResponse</span><span class="params">(im, sigma = <span class="number">3</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        在一幅灰度图像中，对每个像素计算角点器响应函数</span></span><br><span class="line"><span class="string">        输入:</span></span><br><span class="line"><span class="string">            im:表示需要求R的图像（需要是灰度图）</span></span><br><span class="line"><span class="string">            sigma：考虑半径</span></span><br><span class="line"><span class="string">        返回：</span></span><br><span class="line"><span class="string">            Wdet / Wtr ： lambda1*lambda2 与 (lambda1+lambda2)^2的比</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算导数</span></span><br><span class="line">    <span class="comment"># I_x</span></span><br><span class="line">    imx = zeros(im.shape)</span><br><span class="line">    filters.gaussian_filter(im, (sigma, sigma), (<span class="number">0</span>, <span class="number">1</span>) , imx)</span><br><span class="line">    <span class="comment"># I_y</span></span><br><span class="line">    imy = zeros(im.shape)</span><br><span class="line">    filters.gaussian_filter(im, (sigma, sigma), (<span class="number">1</span>, <span class="number">0</span>) , imy)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算Harris矩阵的分量</span></span><br><span class="line">    Wxx = filters.gaussian_filter(imx * imx, sigma)</span><br><span class="line">    Wxy = filters.gaussian_filter(imx * imy, sigma)</span><br><span class="line">    Wyy = filters.gaussian_filter(imy * imy, sigma)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算特征值和迹</span></span><br><span class="line">    Wdet = Wxx * Wyy - Wxy ** <span class="number">2</span></span><br><span class="line">    Wtr = Wxx + Wyy</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Wdet / Wtr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从每个像素计算角点器响应函数到图像中的所有角点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getHarrisPoints</span><span class="params">(harrisim, minDist = <span class="number">10</span>, threshold = <span class="number">0.1</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        从一幅Harris响应图像中返回角点。</span></span><br><span class="line"><span class="string">        输入：</span></span><br><span class="line"><span class="string">            minDist：分割角点和图像边界的最少像素数目</span></span><br><span class="line"><span class="string">        输出：</span></span><br><span class="line"><span class="string">            角点们</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 寻找高于阈值的候选角点</span></span><br><span class="line">    <span class="comment"># 角点阈值等于得分矩阵中最大的*0.1</span></span><br><span class="line">    cornerThreshold = harrisim.max() * threshold</span><br><span class="line">    <span class="comment">#harrisim_t为1的位置就是可能是角点的</span></span><br><span class="line">    harrisimT = (harrisim &gt; cornerThreshold) * <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 得到候选点的坐标</span></span><br><span class="line">    coords = array(harrisimT.nonzero()).T</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 候选点的Harris 响应值</span></span><br><span class="line">    candidateValues = [harrisim[c[<span class="number">0</span>], c[<span class="number">1</span>]] <span class="keyword">for</span> c <span class="keyword">in</span> coords]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 对候选点按照Harris 响应值进行排序</span></span><br><span class="line">    index = argsort(candidateValues)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将可行点的位置保存到数组中</span></span><br><span class="line">    allowedLocations = zeros(harrisim.shape) </span><br><span class="line">    allowedLocations[minDist : -minDist, minDist : -minDist] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 按照minDistance 原则，选择最佳Harris点</span></span><br><span class="line">    filteredCoords = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> index:</span><br><span class="line">        <span class="keyword">if</span>(allowedLocations[coords[i, <span class="number">0</span>], coords[i, <span class="number">1</span>]] == <span class="number">1</span>):</span><br><span class="line">            filteredCoords.append(coords[i])</span><br><span class="line">            allowedLocations[(coords[i, <span class="number">0</span>] - minDist) : (coords[i, <span class="number">0</span>] + minDist),</span><br><span class="line">                             (coords[i, <span class="number">1</span>] - minDist) : (coords[i, <span class="number">1</span>] + minDist)] = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> filteredCoords</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示角点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotHarrisPoints</span><span class="params">(img, filteredCoords)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        绘制图像中检测到的角点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    figure()</span><br><span class="line">    <span class="comment">#灰度图</span></span><br><span class="line">    gray()</span><br><span class="line">    <span class="comment">#显示图</span></span><br><span class="line">    imshow(img)</span><br><span class="line">    <span class="comment"># 显示点</span></span><br><span class="line">    plot([p[<span class="number">1</span>] <span class="keyword">for</span> p <span class="keyword">in</span> filteredCoords], [p[<span class="number">0</span>] <span class="keyword">for</span> p <span class="keyword">in</span> filteredCoords], <span class="string">"*"</span>)</span><br><span class="line">    <span class="comment"># 关闭坐标</span></span><br><span class="line">    axis(<span class="string">'off'</span>)</span><br><span class="line">    show()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    im = array(Image.open(<span class="string">r'C:\Users\wangsy\Desktop\learning\ch3\timg.jpg'</span>).convert(<span class="string">'L'</span>))</span><br><span class="line">    harrisim = computeHarrisResponse(im)</span><br><span class="line">    filteredCoords = getHarrisPoints(harrisim, <span class="number">6</span>)</span><br><span class="line">    plotHarrisPoints(im, filteredCoords)</span><br></pre></td></tr></table></figure>
<p>我们使用第一讲里面用到的埃菲尔铁塔试试，原图如下：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/timg.jpg" alt="timg" style="zoom:50%;" /></p>
<p>使用上述代码提取角点:</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200412165450824.png" alt="image-20200412165450824" style="zoom: 50%;" /></p>
<p>可以看到，效果是可以的，但是艾菲尔铁塔的角点太多了，有点难看出来，所以我们换张图来看看。</p>
<p>这是一个象棋棋盘：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/timg2.jpg" alt="timg2" style="zoom:50%;" /></p>
<p>提取效果如下</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200412165729281.png" alt="image-20200412165729281" style="zoom:50%;" /></p>
<p>可以看出提取效果还是非常好的，虽然提取的有点多。其中有的地方提取效果不佳，这有可能是由于后面的纹理导致的。同时我们可以调整阈值进行查看。将阈值调整到0.3，得到的结果如下：</p>
<p><img src="https://saiyuwang-blog.oss-cn-beijing.aliyuncs.com/image-20200412170009129.png" alt="image-20200412170009129" style="zoom:50%;" /></p>
<p>好了，今天就到这里了，这是第二章的第一小节的前半部分，如果只想囫囵吞枣的话，很快就可以水完，但是如果想要抓住事情的来龙去脉，把事情耨清楚，就需要一定的努力了，之前的博客半章4000字就能搞定了，现在一个问题就需要4000字了。</p>
<p>学这个问题也让我理解到，好的参考读物有多么的重要，读那些垃圾博客再多也不如多读一些经典的东西。</p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里C++研发一面准备</title>
    <url>/2020/04/13/%E9%98%BF%E9%87%8CC-%E7%A0%94%E5%8F%91%E4%B8%80%E9%9D%A2%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h1 id="阿里c面试文档">阿里C++面试文档</h1>
<p>4月8做完笔试，做的稀烂，还以为直接凉凉了，就没管这事了，没想到今天接到约面试的电话，约到了明天下午，然鹅我已经半年多没写过C++了，于是今天下午赶紧恶补一下，许个愿，等过几天看看能不能回来还愿。</p>
<p>先说结果： 我是18级的，他们不招，所以这些准备的今年是用不上了，但是还是可以分享一下的。</p>
<h2 id="null-和-nullptr">NULL 和 nullptr</h2>
<p>参考资料： <a href="https://blog.csdn.net/reasonyuanrobot/article/details/100022574" target="_blank" rel="noopener">this one</a></p>
<p>nullptr是在C++11中才出现的，首先我们来看一下nullptr解决了什么问题：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void *)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在C++中不允许(void*)类型进行隐式转换，所以在C语言中，NULL被定义为(void*)0,而在C++语言中，NULL则被定义为整数0，也就是说，NULL是一个整型变量，这样的设计带来了如下的问题:</p>
<ul>
<li><p>```C++ char* a =" Hello"; void foo(void* p){} foo(a); <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  上方这种调用会出现问题</span><br><span class="line"></span><br><span class="line">* &#96;&#96;&#96;C++</span><br><span class="line">  void func(int data);</span><br><span class="line">   </span><br><span class="line">  void func(char* data);</span><br></pre></td></tr></table></figure></p>
<p>在上面这种情况中，无法将NULL和整形区分，调用的结果与想象中不符。</p></li>
</ul>
<p>nullptr在C++11被引入用于解决这一问题，nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型，所以不会造成参数传递错误。</p>
<h2 id="深拷贝与浅拷贝">深拷贝与浅拷贝</h2>
<ul>
<li><p>浅拷贝下：</p>
<p>A复制了B，那么A和B是共用同一片内存区域的，也就是说，A和B中任何一个发生变化，他们两个都会发生变化。</p></li>
<li><p>深拷贝下:</p>
<p>A复制了B，A和B除了内容相同之外，相互独立。</p></li>
</ul>
<h2 id="堆区与栈区">堆区与栈区</h2>
<p>参考资料：<a href="https://www.zhihu.com/question/19729973/answer/13037929" target="_blank" rel="noopener">this one</a></p>
<h3 id="申请方式的区别">申请方式的区别</h3>
<p>堆区存放的是new、malloc出的变量，由程序员自己定义大小。</p>
<p>栈由系统自动分配，我们直接int出来的局部变量就在栈区。</p>
<h3 id="系统的响应">系统的响应</h3>
<ul>
<li><p>堆:操作系统有一个记录空闲内存地址的链表，系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。会在这块内 存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大 小，系统会自动的将多余的那部分重新放入空闲链表中。</p></li>
<li><p>栈:只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p></li>
</ul>
<h3 id="能申请的空间的大小">能申请的空间的大小</h3>
<ul>
<li>栈：能从栈获得的空间较小。</li>
<li>堆：堆获得的空间比较灵活，也比较大。</li>
</ul>
<h3 id="申请效率">申请效率</h3>
<ul>
<li><p>栈由系统自动分配，速度较快。但程序员是无法控制的。</p></li>
<li><p>堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.</p></li>
</ul>
<h2 id="inline-和-普通函数">inline 和 普通函数</h2>
<h3 id="inline-vs-普通函数">inline VS 普通函数</h3>
<p>参考资料：<a href="http://blog.sina.com.cn/s/blog_5f99444c01013jji.html" target="_blank" rel="noopener">this one</a></p>
<p>内联函数有一些限制：</p>
<ul>
<li>内联函数体不能包含循环语句、switch语句。</li>
<li>内联函数要先定义、后调用，不能先声明内联函数原型，再定义、调用。</li>
</ul>
<p>内联函数实际上是省去了跳转的步骤，在速度层面有一定的加强，但同时也增大了内存的开销。</p>
<h3 id="inline-vs-宏定义">inline VS 宏定义</h3>
<p>宏定义直接就是代码替换，与inline有本质上的区别，如果直接用宏定义来替代inline可能还会导致逻辑错误。</p>
<h2 id="static"><strong>static</strong></h2>
<p><a href="https://blog.csdn.net/majianfei1023/article/details/45290467" target="_blank" rel="noopener">来源</a></p>
<h3 id="静态局部变量">静态局部变量</h3>
<p>刚才在讲堆栈的时候，有一点是没有讲到的，C++程序在内存中，除了占用堆栈区域外，还有一种区域是：静态内存区域，它负责存储<strong>全局变量和静态变量</strong>，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放。当然，还有代码区，这里不展开讲。</p>
<p>static是在全局数据区分配的,那么它存在的意思是什么？又是什么时候初始化的呢？</p>
<ul>
<li>它存在的意义就是随着<strong>第一次函数的调用而初始化</strong>，却不随着函数的调用结束而销毁，所以它只会初始化一次。</li>
</ul>
<p>静态局部变量的特点：</p>
<ul>
<li>（1）该变量在全局数据区分配内存(局部变量在栈区分配内存);</li>
<li>（2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化(局部变量每次函数调用都会被初始化);</li>
<li>（3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(局部变量不会被初始化);</li>
<li>（4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它(局部变量在栈区，在函数结束后立即释放</li>
</ul>
<h3 id="静态全局变量"><strong>静态全局变量</strong></h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;  <span class="comment">//note:3</span></span><br><span class="line"><span class="comment">//int i = 1;  //note:4</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	i += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态全局变量不能被其它文件所用(全局变量可以);</p>
<h3 id="静态函数和静态全局变量类似">静态函数：和静态全局变量类似</h3>
<h3 id="静态数据成员被定义在类里面的静态成员"><strong>静态数据成员</strong>：被定义在类里面的静态成员</h3>
<p>特点：与普通的成员不一样，普通的类成员是一个实例一个。而静态成员是每个类一个的，这个可以用来统计一些累计的东西，也可以用来做公有的东西。</p>
<h3 id="静态成员函数类里面的静态函数"><strong>静态成员函数</strong>：类里面的静态函数</h3>
<ul>
<li>1.静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数;</li>
<li>2.非静态成员函数可以任意地访问静态成员函数和静态数据成员;</li>
<li>3.静态成员函数不能访问非静态成员函数和非静态数据成员;</li>
<li>4.调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)为一个类的对象或指向类对象的指针调用静态成员函数,也可以用类名::函数名调用(因为他本来就是属于类的，用类名调用很正常)</li>
</ul>
<h2 id="虚函数和多态">虚函数和多态</h2>
<p>一、子类对象可以被当作父类对象。</p>
<ul>
<li>派生类的对象可以隐含的转换成基类对象。</li>
<li>派生类对象可以初始化基类的引用。</li>
<li>派生类指针可以隐含转换为基类的指针</li>
</ul>
<p>说人话就是：</p>
<ul>
<li>父类指针可以指向子类对象</li>
</ul>
<p>那么虚函数有什么用处呢？这里我们和java对比着来说，众所周知，Java中可以override，也就是说将函数重写，这样来达到多态。父类指针指向的子类，可以调用子类中重写过的方法。但是C++在默认情况下不可以，所以C++引入了virtual。</p>
<h3 id="多态">多态:</h3>
<p>不同类的对象堆同一消息的不同响应。俺会了，⑧谈了</p>
<h3 id="动态绑定">动态绑定</h3>
<p>可以说是多态的实际应用</p>
<h3 id="实现动态绑定的要点多态">实现动态绑定的要点（多态）</h3>
<ul>
<li>具有类的继承关系图，这个继承关系中每个类都可以调用一个虚函数</li>
<li>基础类的指针指向子类的对象</li>
<li>通过基础类的指针调用虚函数</li>
</ul>
<h3 id="虚析构函数">虚析构函数</h3>
<p>在析构函数定义为虚函数，这样就可以根据子类的不同特性对析构函数进行重写。</p>
<h2 id="虚函数表">虚函数表</h2>
<h3 id="有无虚函数的类的内存布局的区别">有无虚函数的类的内存布局的区别‘</h3>
<p>无虚函数：类的实例化中仅有成员占用空间。</p>
<p>有虚函数：虚函数指针同时占用空间，该虚函数指针指向一个虚函数表。</p>
<p>虚函数表保存了一个函数的地址，也就是函数指针。</p>
<p>再来捋一遍：</p>
<ul>
<li>含有虚函数的类进行实例化：</li>
<li>编译器给类的实例化分配一个虚函数指针</li>
<li>虚函数指针指向虚函数表</li>
<li>虚函数表里面有虚函数</li>
</ul>
<h3 id="子类不重写父类的虚函数的情况">子类不重写父类的虚函数的情况：</h3>
<p>假设现在有一个父类一个子类，父类中定义类一个虚函数，子类在继承父类后，并没有重写该函数。</p>
<p>这种情况下，父类和子类的内存布局中仍然都有虚函数指针，指向虚函数表。为避免套娃，不讲了。</p>
<p>一句话来说:我爸爸有虚函数，我直接继承了， 那我的虚函数指针就指向我爸爸在虚函数表里的虚函数。反之我的虚函数指针就指向我重写的虚函数在虚函数表里的位置。</p>
<h3 id="补充">补充</h3>
<p>看后面看到的，塞过来</p>
<p>子类的虚函数被放在声明的第一个基类的虚函数表中。</p>
<h2 id="c经典继承多态封装">c++经典继承，多态，封装</h2>
<h3 id="封装">封装</h3>
<ul>
<li>好处：安全，方便简单</li>
<li>封装的层次：
<ul>
<li>方法封装了功能</li>
<li>类封装了数据和功能</li>
</ul></li>
<li>如何实现封装
<ul>
<li>使用private修饰属性，不能直接给属性赋值</li>
<li>提供public的方法完成对属性的赋值set和取值get操作</li>
<li>在set方法中添加控制语句</li>
</ul></li>
<li>类的成员使用的修饰符：
<ul>
<li>private 默认 protected public</li>
</ul></li>
<li>类只能用public和默认来修饰</li>
</ul>
<h3 id="继承">继承</h3>
<ul>
<li><p>父类、子类。就是子类继承父类的<strong>属性</strong>和<strong>行为</strong>，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接 访问父类中的<strong>非私有</strong>的属性和行为</p></li>
<li><p>好处：</p>
<ul>
<li>避免代码重复，提高<strong>代码的复用性。</strong></li>
<li>类与类之间产生了关系，是<strong>多态的前提。</strong></li>
<li>修改父类，影响所有的子类（好处：便于修改，修改一次接口。不足：增加了耦合性）</li>
</ul></li>
</ul>
<h3 id="多态-1">多态</h3>
<p>已经说完了</p>
<h2 id="引用vs指针">引用VS指针</h2>
<p>https://blog.csdn.net/tch918/article/details/7401351</p>
<p>引用：</p>
<ul>
<li>是一块内存区域的别名</li>
<li>必须被初始化</li>
<li>初始化后不能被更改（绑定）</li>
<li>他不是一个对象</li>
</ul>
<p>指针：</p>
<ul>
<li>他记录一块内存区域的地址</li>
<li>定义时可以不被初始化</li>
<li>可以指向不同的对象（不绑定）</li>
<li>它是一个对象</li>
</ul>
<h2 id="虚函数vs纯虚函数">虚函数VS纯虚函数</h2>
<p>首先书虚函数和纯虚函数的定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>&#123;&#125; <span class="comment">// 纯虚函数</span></span><br></pre></td></tr></table></figure>
<p>虚函数：虚函数是多态的基础，我们在上面已经有所涉及，基类中含有一个虚函数，派生类可以对该函数进行重写，这一过程就实现了多态。</p>
<p>纯虚函数：和虚函数有很大的相似性，但是纯虚函数多了一个限制，那就是派生类必须重写该函数。</p>
<p>不管是虚函数还是纯虚函数，<strong>基类都可以为提供他们的实现</strong>（<strong>implementation</strong>），如果有的话子类可以调用基类的这些实现。</p>
<p>子类可<strong>自主选择</strong>是否要提供一份属于自己的个性化虚函数实现。</p>
<p>子类<strong>必须提供</strong>一份属于自己的个性化纯虚函数实现。</p>
<h3 id="抽象类">抽象类</h3>
<p>　C++中包含纯虚函数的类，被称为是“抽象类”。抽象类不能使用new出对象，只有实现了这个纯虚函数的子类才能new出对象。</p>
<p>C++中的纯虚函数更像是“只提供申明，没有实现”，是对子类的约束，是“接口继承”。</p>
<p>C++中的纯虚函数也是一种“运行时多态”。</p>
<h2 id="const"><strong>const</strong></h2>
<p>常量表示一种定义后就不能再修改的量</p>
<ul>
<li><p>最简单的用法： <strong>const修饰普通类型的变量</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N = <span class="number">500</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>const 修饰指针变量</strong>，分为三种情况：</p>
<ul>
<li>const 修饰指针指向的内容，则内容为不可变量，人话就是：const修饰的指针指向的东东，那么就只能访问不能更改</li>
<li>const 修饰指针，则指针为不可变量，人话：const修饰指针本身，指针指向的区域不能变化</li>
<li>const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量，就是第一种加第二种</li>
</ul>
<p>对于第一种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p>第二种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"> <span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;a;</span><br><span class="line"></span><br><span class="line"> *p = <span class="number">9</span>; <span class="comment">//it’s right</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span>  b = <span class="number">7</span>;</span><br><span class="line"> p = &amp;b; <span class="comment">//it’s wrong</span></span><br></pre></td></tr></table></figure>
<p>第三种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span>  p = &amp;a;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="const-修饰传递参数">const 修饰传递参数</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cpf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a; </span><br><span class="line">    <span class="comment">// ++a;  it's wrong, a can't is changed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>值传递的const修饰传递</strong>，一般这种情况不需要const修饰，因为<strong>函数会自动产生临时变量复制实参值</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cpf</span><span class="params">(<span class="keyword">int</span> *<span class="keyword">const</span> a)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*a&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    *a = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当const参数为指针时，可以防止指针被意外篡改。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Cmf</span><span class="params">(<span class="keyword">const</span> Test&amp; _tt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;_tt.get_cm(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取const外加引用传递的方法。</strong></p>
<h3 id="const修饰函数的返回值">const修饰函数的返回值</h3>
<p><strong>const修饰内置类型的返回值，修饰与不修饰返回值作用一样。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">Cmf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。</strong></p>
<p><strong>const 修饰返回的指针或者引用，是否返回一个指向const的指针，取决于我们想让用户干什么。</strong></p>
<h3 id="const修饰类成员函数."><strong>const修饰类成员函数.</strong></h3>
<p>onst 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为const成员函数。<strong>注意：const关键字不能与static关键字同时使用，因为static关键字修饰静态成员函数，静态成员函数不含有this指针，即不能实例化，const成员函数必须具体到某一实例。</strong></p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span> <span class="comment">// const 成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ++num;     <span class="comment">// 编译错误，企图修改数据成员m_num</span></span><br><span class="line">        func();     <span class="comment">// 编译错误，企图调用非const函数</span></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="智能指针"><strong>智能指针</strong></h2>
<p>链接：https://zhuanlan.zhihu.com/p/78123220</p>
<p>由于 C++ 语言没有自动内存回收机制，程序员每次 new 出来的内存都要手动 delete。程序员忘记 delete，流程太复杂，最终导致没有 delete，异常导致程序过早退出，没有执行 delete 的情况并不罕见。——解决了忘了delete的问题。</p>
<p>智能指针实际上是一个栈对象，并非指针类型，在栈对象生命期即将结束时，智能指针通过析构函数释放有它管理的堆内存。所有智能指针都重载了“operator-&gt;”操作符，直接返回对象的引用，用以操作对象。访问智能指针原来的方法则使用“.”操作符。</p>
<p>访问智能指针包含的裸指针则可以用 get() 函数。</p>
<h3 id="stdauto_ptr"><strong>std::auto_ptr</strong></h3>
<p>从C++98开始便推出了auto_ptr，对裸指针进行封装，让程序员无需手动释放指针指向的内存区域，在auto_ptr生命周期结束时自动释放，由于auto_ptr在转移指针所有权后会产生野指针，导致程序运行时crash，如下面示例代码所示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; p2 = p1; <span class="comment">//转移控制权</span></span><br><span class="line">*p1 += <span class="number">10</span>; <span class="comment">//crash，p1为空指针，可以用p1-&gt;get判空做保护</span></span><br></pre></td></tr></table></figure>
<h3 id="unique_ptr">unique_ptr</h3>
<p>unique_ptr是auto_ptr的继承者，对于同一块内存只能有一个持有者，而unique_ptr和auto_ptr唯一区别就是unique_ptr不允许赋值操作，也就是不能放在等号的右边（函数的参数和返回值例外），这一定程度避免了一些误操作导致指针所有权转移，然而，unique_str依然有提供所有权转移的方法move，调用move后，原unique_ptr就会失效，再用其访问裸指针也会发生和auto_ptr相似的crash，如下面示例代码，所以，即使使用了unique_ptr，也要慎重使用move方法，防止指针所有权被转移。</p>
<h3 id="shared_ptr">shared_ptr</h3>
<p>shared_ptr 是一个标准的共享所有权的智能指针，允许多个 shared_ptr 智能指针指向同一个指针对象，shared_ptr 利用引用计数的方式实现了对所管理的对象的所有权的分享，即允许多个 shared_ptr 共同管理同一个对象</p>
<h3 id="weak_ptr">weak_ptr</h3>
<p>weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它更像是 shared_ptr 的一个助手而不是智能指针，因为它不具有普通指针的行为，没有重载解引用运算符"*"和运算符"-&gt;"，它的最大作用在于协助 shared_ptr 工作，像旁观者那样观测资源的使用情况</p>
<pre class="mermaid">graph LR
普通指针 --自动delete--> auto_ptr
auto_ptr --禁止所有权转移-->unique_ptr-治标不治本
unique_ptr-治标不治本 --共享所有权--> shared_ptr</pre>
<h2 id="mapset的底层">map&amp;set的底层</h2>
<p>空间占用率高</p>
<p>红黑树：</p>
<ul>
<li>根节点必须为黑色</li>
<li>父子不能同为红色</li>
<li>从任何一个节点出发，到叶子节点经过的黑色节点数量一致</li>
</ul>
<p>操作：</p>
<ul>
<li>搜索：和二叉搜索树一样</li>
<li>插入：以红色作为默认插入颜色，插入后进行修复：
<ul>
<li>一、变色</li>
<li>二、旋转</li>
</ul></li>
</ul>
<h2 id="vector底层">vector底层</h2>
<p>数组，</p>
<p>访问：O(1)</p>
<p>扩容：新建vector会分配连续内存空间，通过push_back增加元素时，如果初始分分配空间满了，那么久扩容，扩容到原来的两倍。</p>
<h2 id="unordered_map-底层">unordered_map 底层</h2>
<p>哈希表，查找速度非常的快</p>
<p>哈希表的建立比较耗费时间</p>
<p>对于查找问题，unordered_map会更加高效一些</p>
<p>哈希：</p>
<ul>
<li>开散列</li>
<li>闭散列</li>
</ul>
<h2 id="c11">C++11</h2>
<ul>
<li>nullptr</li>
<li>auto：自动推导类型，但不能用于传参和数组</li>
<li>基于范围的for循环</li>
<li>初始化列表</li>
<li>tuple元组</li>
</ul>
<h2 id="项目">项目</h2>
<p>什么是立体匹配？</p>
<p>立体匹配解决的科学问题是：</p>
<ul>
<li>给出两张图片，这两张图片是由两个平行的摄像机向同一方向拍摄得到的。</li>
<li>使用这两张图片，得到一张深度图（深度图中每一个点的值表示左右图中在现实世界中的同一点相差的距离）</li>
<li>根据深度图可以重建出三维世界</li>
</ul>
<p>基本流程：</p>
<ul>
<li></li>
</ul>
<h3 id="图割立体匹配">图割立体匹配</h3>
<ul>
<li>匹配代价计算</li>
<li>视差计算</li>
</ul>
<p>相当于是构建了一个全局的函数，深度图构成的序列是函数的自变量，求函数的最优解的问题。</p>
<p>作者用的方法是：使用最大流最小割定理。</p>
<p>建边方法：</p>
<p>假设(i,j,k)代表i，j节点取k深度</p>
<p>随机生成</p>
<ul>
<li>一个像素点位置上：不同深度取值建边，成为深度边。<br />
</li>
<li>交换深度</li>
</ul>
]]></content>
      <categories>
        <category>找实习</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>找实习</tag>
      </tags>
  </entry>
  <entry>
    <title>python图像处理笔记(二)</title>
    <url>/2020/04/09/python%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
    <content><![CDATA[<h1 id="图像处理笔记二">图像处理笔记（二）</h1>
<h2 id="放在最开始的话">放在最开始的话</h2>
<h3 id="参考的资料">参考的资料</h3>
<p>参考的资料是《python图像处理》，所以说学习的顺序和书中的编排也是基本相同的。书中对原理的解析非常少（几乎没有），所以我决定随着看到书中的现象，随着把原理搞清楚，顺便做成文档发到网上，也希望大家能够通过阅读我的文档有所收获。</p>
<h3 id="感谢">感谢</h3>
<p>今天下午忙完其他的事之后，忽然发现上一篇博客的浏览量有20！写了这么久博客，还从来没这么多人看。昨天讲的SVD有点粗糙，原因是我个人也一知半解，等我的西瓜书到了之后我在再仔细研究一下，再发一篇专门用来讲他们。感谢大家的支持，我会继续写的。</p>
<h2 id="形态学对象计数">形态学：对象计数</h2>
<p>前一阵子看到女朋友再用ImageJ处理叶片数据，结果今天就学到了。</p>
<p>对象计数的过程大体可以分为：</p>
<ul>
<li><p>将图像转换成灰度图</p></li>
<li><p>对灰度图进行二值化</p></li>
<li><p>统计图中值为1的连通块的个数</p></li>
</ul>
<p>下面我们对一张图片进行计数，用的图片并非是网络上的开放图片，如果大家想要练习的话，可以从网上下一些相似的图像自己玩一玩，我用到的图象是这个:</p>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/leafs.jpg" style="zoom:9%;" /></p>
<p>大家看到的样子，是他已经缩放到了9%的样子，所以我们知道这张图片的<strong>尺寸很大</strong>。首先我们将图片以灰度图方式读入，并且进行二值化处理，进行观察。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> measurements, morphology</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> modules</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(im1, im2, module = <span class="string">'gray'</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    在一张图里面显示两个图片</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">8</span>),ncols=<span class="number">2</span>,nrows=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ax[<span class="number">0</span>].imshow(im1, module)</span><br><span class="line"></span><br><span class="line">    ax[<span class="number">1</span>].imshow(im2, module)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">im = array(Image.open(<span class="string">"C:\\Users\\wangsy\\Desktop\\learning\\cl2\\leafs.jpg"</span>).convert(<span class="string">"L"</span>))</span><br><span class="line"></span><br><span class="line">temp = <span class="number">1</span>*(im&gt;<span class="number">140</span>)</span><br><span class="line"></span><br><span class="line">compare(im, temp)</span><br></pre></td></tr></table></figure>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/1586316068914.png" style="zoom:50%;" /></p>
<p>我们可以发现，叶片的形状已经基本呈现出来了，但是比较恼火的是途中的白色处还有零星的噪点（说白了就是本来应该白的地方是黑的），这显然不是我们想要的。这时，我们有几条路去解决这个问题：</p>
<ul>
<li><p>一、调整二值化阈值：</p>
<p>二值化是需要一个阈值的，我们这张图是以140为阈值去做的，我们可以尝试调整一下这个阈值，看看能不能达到降噪的目的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> measurements, morphology</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> modules</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(im1, im2, module = <span class="string">'gray'</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    在一张图里面显示两个图片</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">8</span>),ncols=<span class="number">2</span>,nrows=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ax[<span class="number">0</span>].imshow(im1, module)</span><br><span class="line"></span><br><span class="line">    ax[<span class="number">1</span>].imshow(im2, module)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">im = array(Image.open(<span class="string">"C:\\Users\\wangsy\\Desktop\\learning\\cl2\\leafs.jpg"</span>).convert(<span class="string">"L"</span>))</span><br><span class="line"></span><br><span class="line">temp1 = <span class="number">1</span>*(im&gt;<span class="number">160</span>)</span><br><span class="line"></span><br><span class="line">temp2 =  <span class="number">1</span>*(im&gt;<span class="number">180</span>)</span><br><span class="line"></span><br><span class="line">compare(temp1, temp2)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/1586316336567.png" style="zoom:50%;" /></p>
<p>上面的图像分别是以160、180为阈值进行二值化的图像，可以看出来，阈值高了也未必是一件好事，同时二值化的图像无论如何调整阈值都是会存在一定的噪点的。</p>
<ul>
<li><p><strong>膨胀与腐蚀</strong></p>
<p>图像的膨胀（Dilation）和腐蚀（Erosion）是两种基本的形态学运算，主要用来寻找图像中的极大区域和极小区域。其中膨胀类似于“领域扩张”，将图像中的高亮区域或白色部分进行扩张，其运行结果图比原图的高亮区域更大；腐蚀类似于“领域被蚕食”，将图像中的高亮区域或白色部分进行缩减细化，其运行结果图比原图的高亮区域更小。——这段话来源于<a href="https://blog.csdn.net/weixin_39128119/article/details/84172385" target="_blank" rel="noopener">这篇博客</a></p>
<p>我们这里主要用腐蚀，腐蚀的主要作用就是：</p>
<ul>
<li><p>图像边界收缩</p></li>
<li><p>去噪声</p></li>
<li><p>元素分割</p></li>
</ul>
<p>他的<strong>原理</strong>是使用一个<strong>结构元</strong>扫描这张图片中的每一个元素，如果以当前元素为中心放置结构元的区域中全是1，那么这里就取1，如果不是的话，就取0。结构元是什么呢？实际上和滤波器差不多。说白了就是，有一张图像A，还有一个用于筛选的结构元B。我们以每个A的元素为中心，检查其周围和B一样的区域，如果里面有一个不是1的话，那么这个元素所在位置就是0，反之则为1。</p>
<p>一般使用opencv完成这个操作，但是为了和教材贴合，我们还是用scipy.ndimage来实现这个操作吧。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> measurements, morphology, binary_erosion</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> modules</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(im1, im2, module = <span class="string">'gray'</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    在一张图里面显示两个图片</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">8</span>),ncols=<span class="number">2</span>,nrows=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ax[<span class="number">0</span>].imshow(im1, module)</span><br><span class="line"></span><br><span class="line">    ax[<span class="number">1</span>].imshow(im2, module)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">im = array(Image.open(<span class="string">"C:\\Users\\wangsy\\Desktop\\learning\\cl2\\leafs.jpg"</span>).convert(<span class="string">"L"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">im = <span class="number">1</span>*(im&lt;<span class="number">150</span>)</span><br><span class="line"></span><br><span class="line">im = modules.imresize(im, (im.shape[<span class="number">1</span>]//<span class="number">6</span>,im.shape[<span class="number">0</span>]//<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">labels, nbr_objects = measurements.label(im)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">im_open = binary_erosion(im, iterations =<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">compare(im, im_open)</span><br><span class="line"></span><br><span class="line">labels_open, nbr_objects_open = measurements.label(im_open)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(nbr_objects, nbr_objects_open)</span><br></pre></td></tr></table></figure>
<p>我们使用腐蚀功能对图片进行腐蚀，使用measurements.label对腐蚀后的图片做了统计，下面是两种结果的对比:</p>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/1586318442208.png" style="zoom: 50%;" /></p></li>
</ul>
<p>仔细观察你会发现，腐蚀过的叶片更加瘦小，里面的黑洞洞也更大了，并且旁边的噪点变少了，我们使用统计功能发现：</p>
<blockquote>
<p>未腐蚀统计的连通块数目：22</p>
</blockquote>
<blockquote>

</blockquote>
<blockquote>
<p>腐蚀过的区域连通块数目：10</p>
</blockquote>
<p>可以看出，腐蚀过的区域的连通块数目更加符合我们的预期。当然，在上面的代码中，为了增加程序运行的效率，我使用了之前章节中我们写过的imresize函数对原本很大的图片进行了缩放，图片被缩放了六倍。</p>
<p>当然了，这一部分的问题解决的并不完美，但是由于能力有限，暂时无法全部解决，我会在以后再回来填坑的。</p>
<h2 id="一些有用的scipy模块">一些有用的Scipy模块</h2>
<h3 id="读写.mat文件">读写.mat文件</h3>
<p>你可以使用Scipy来对.mat文件进行读取和存储，操作如下：</p>
<h4 id="读取">读取</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">data = scipy.io.loadmat(<span class="string">'test.mat'</span>)</span><br></pre></td></tr></table></figure>
<p>打开的data对象包含一个字典，字典的键表示原来的.mat文件中的变量名，当然你也可以反过来将你创建好的字典进行保存。</p>
<h4 id="保存">保存</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">data = &#123;&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="string">'x'</span>] = x</span><br><span class="line"></span><br><span class="line">scipy.io.savemat(<span class="string">'test.mat'</span>,data)</span><br></pre></td></tr></table></figure>
<h3 id="以图像的形式保存数组">以图像的形式保存数组</h3>
<p>因为我们需要对图像进行操作，并且需要使用数组对象来做运算，所以可以直接保存为图像文件。imsave()函数可以从scipy.misc模块载入。要将数组im保存到文件中，可以使用下面的命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.misc <span class="keyword">import</span> imsave</span><br><span class="line"></span><br><span class="line">imsave(<span class="string">'test.jpg'</span>,im)</span><br></pre></td></tr></table></figure>
<p>这里面也包含了著名的Lena测试图像：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">lena = scipy.misc.lena()</span><br></pre></td></tr></table></figure>
<p>woc，这是啥，我快点打开看看。</p>
<blockquote>
<p>AttributeError: module 'scipy.misc' has no attribute 'lena'</p>
</blockquote>
<p>百度之，发现是这张图：</p>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/20140702104508726.jpg" style="zoom:50%;" /></p>
<p>其实这张图的完整版有点让人大跌眼镜，好奇的可以点<a href="https://img-blog.csdn.net/20140702104120484" target="_blank" rel="noopener">这个链接</a>看一下，还是比较惊艳的哈。这背后还有一段八卦，好奇的可以看<a href="https://blog.csdn.net/Leytton/article/details/36385645" target="_blank" rel="noopener">这里</a></p>
<h2 id="高级示例图像去噪">高级示例：图像去噪</h2>
<p>告诉你个好消息，第一章快学完了。</p>
<h3 id="原理">原理</h3>
<p>这里使用的是<strong>ROF去噪模型</strong>。据说他的数学基础和处理技巧都非常高深，所以书里就没讲。但是好在，书中还是有对ROF模型的简述:</p>
<p>一副灰度图像<span class="math inline">\(I\)</span>的<strong>全变差</strong>定义为梯度范数之和。在连续表示的情况下，全变差表示为:</p>
<p>$$</p>
<p>J(I) = |I|dx</p>
<p>$$</p>
<p>在离散表示的情况下，全变差表示为：</p>
<p>$$</p>
<p>J(I) = _x |I|</p>
<p>$$</p>
<p>这里的<span class="math inline">\(I\)</span>就是这张图片，相当于是一个多元函数的自变量。其中上面的式子是在所有图像坐标 <span class="math inline">\(X = [x,y]\)</span>上取和。在ROF模型中，目标函数为寻找降噪后的图像U，使下式最小：</p>
<p>$$</p>
<p> _{U}||I-U||^2+2J(U)</p>
<p>$$</p>
<p>图形学在研究的问题都是<strong>病态</strong>的问题，用人话来说就是没法准确表示的问题，所以在早年（AI不火的时候）图形学问题大多都是通过<strong>最小化能量函数</strong>的方法进行求解的，上面的也是一样。我们观察上面的式子可以发现，这个式子表示：通过调整U,来使得后面的式子达到最小化，后面的式子分为两部分：</p>
<ul>
<li><p><span class="math inline">\(||I-U||^2\)</span>上过初中的兄弟萌不难把它和距离公式联系在一起，那么这个就表示新的图U与原来的图I之间的距离，这个距离实质上描述了两张图的差异程度</p></li>
<li><p><span class="math inline">\(2\lambda J(U)\)</span> 这部分描述的是图像的平滑程度，我们认为平滑的图像噪声会更小，这一项小的时候噪声会更小。</p></li>
</ul>
<p>我们通过权衡这两项来均衡图像的失真程度以及修改后图像的平滑程度，试想如果没有了前一项，那么机器直接生成一张空白的图像就可以溜之大吉。反之，如果只有前面一项，机器直接生成一个和原图完全一样的图片也可以蒙混过关。当然，我们也可以通过调节两项之间的权重来调节生成的图片的效果。</p>
<h3 id="代码">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(im1, im2, module = <span class="string">'gray'</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    在一张图里面显示两个图片</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">8</span>),ncols=<span class="number">2</span>,nrows=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ax[<span class="number">0</span>].imshow(im1, module)</span><br><span class="line"></span><br><span class="line">    ax[<span class="number">1</span>].imshow(im2, module)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">denoise</span><span class="params">(im, U_init, tolerance = <span class="number">0.1</span>, tau = <span class="number">0.125</span>, tv_weight = <span class="number">100</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        ROF降噪模型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        输入：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            im     : 有噪声的图像</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            U_int : 降噪后图像的初始值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            去噪和去纹理后的图像， 纹理残留</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取图像的大小</span></span><br><span class="line"></span><br><span class="line">    m, n  = im.shape</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化变量</span></span><br><span class="line"></span><br><span class="line">    U  = U_init</span><br><span class="line"></span><br><span class="line">    Px = im <span class="comment"># 对偶域的x 分量</span></span><br><span class="line"></span><br><span class="line">    Py = im <span class="comment"># 对偶域的y 分量</span></span><br><span class="line"></span><br><span class="line">    error = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(error &gt; tolerance):</span><br><span class="line"></span><br><span class="line">        iter+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(iter &gt; <span class="number">10000</span>):</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(iter %<span class="number">1000</span> ==<span class="number">0</span>):</span><br><span class="line"></span><br><span class="line">            compare(im,U)</span><br><span class="line"></span><br><span class="line">        Uold = U</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 变量U梯度的x分量</span></span><br><span class="line"></span><br><span class="line">        GradUx = roll(U, <span class="number">-1</span>, axis = <span class="number">1</span>) - U</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 变量U梯度的y分量</span></span><br><span class="line"></span><br><span class="line">        GradUy = roll(U, <span class="number">-1</span>, axis = <span class="number">0</span>) - U</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新对偶变量</span></span><br><span class="line"></span><br><span class="line">        PxNew = Px + (tau / tv_weight) * GradUx</span><br><span class="line"></span><br><span class="line">        PyNew = Py + (tau / tv_weight) * GradUy</span><br><span class="line"></span><br><span class="line">        NormNew = maximum(<span class="number">1</span>, sqrt(PxNew**<span class="number">2</span> + PyNew**<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新X、Y分量</span></span><br><span class="line"></span><br><span class="line">        Px = PxNew / NormNew</span><br><span class="line"></span><br><span class="line">        Py = PyNew / NormNew</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新原始变量</span></span><br><span class="line"></span><br><span class="line">        RxPx = roll(Px, <span class="number">1</span>, axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        RyPy = roll(Py, <span class="number">1</span>, axis = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        DivP = (Px - RxPx) + (Py - RyPy) <span class="comment"># 对偶域的散度</span></span><br><span class="line"></span><br><span class="line">        U = im + tv_weight * DivP <span class="comment"># 更新原始变量</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新误差</span></span><br><span class="line"></span><br><span class="line">        error = linalg.norm(U - Uold) / sqrt(n*m)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> U, im - U</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> numpy <span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> filters</span><br><span class="line"></span><br><span class="line">    print(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用噪声创建合成图像</span></span><br><span class="line"></span><br><span class="line">    im = zeros((<span class="number">500</span>,<span class="number">500</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    im[<span class="number">100</span>:<span class="number">400</span>,<span class="number">100</span>:<span class="number">400</span>] = <span class="number">128</span></span><br><span class="line"></span><br><span class="line">    print(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    im[<span class="number">200</span>:<span class="number">300</span>,<span class="number">200</span>:<span class="number">300</span>] = <span class="number">255</span></span><br><span class="line"></span><br><span class="line">    print(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    im = im + <span class="number">30</span>*random.standard_normal((<span class="number">500</span>,<span class="number">500</span>))</span><br><span class="line"></span><br><span class="line">    G = filters. gaussian_filter(im, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    compare(im,G)</span><br><span class="line"></span><br><span class="line">    U, err = denoise(im,im)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    compare(U, err)</span><br><span class="line"></span><br><span class="line">    compare(U,G)</span><br></pre></td></tr></table></figure>
<h3 id="结果">结果</h3>
<p>这是原来的图片：</p>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/1586353635632.png" style="zoom:50%;" /></p>
<p>下面的图片中，左边是ROF出来的，右边是高斯出来的：</p>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/1586353690425.png" style="zoom:50%;" /></p>
<p>可以看出来，两种方法都是有降噪的作用的，但是两者之间也有所区别：</p>
<ul>
<li><p>高斯：更像是将图片整体同时都进行了模糊，这样能让图像的平滑都变高，但却无法保留图像的边缘信息。</p></li>
<li><p>ROF：相较于高斯，能够保留图像的边缘信息，但是在某些内部部分它的平滑效果不如高斯好</p></li>
</ul>
<h3 id="实际应用">实际应用</h3>
<p>下面我将使用图像平滑技术来P图(这图已经P过了，我再PP看看会咋样)，下面是照片：</p>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/psc.jpg" style="zoom: 25%;" /></p>
<p>可以看到，已经是非常好看的了。</p>
<p>接下来我们先尝试着将它转换成灰度图并且使用ROF进行降噪。</p>
<p>首先先将图片转化成灰度图</p>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/1586354100093.png" style="zoom: 67%;" /></p>
<p>接下来，跑我们的ROF降噪模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Created on Wed Apr  8 21:52:32 2020</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: wangsy</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ROF</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> measurements, morphology, binary_erosion</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> modules</span><br><span class="line"></span><br><span class="line">im = array(Image.open(<span class="string">"C:\\Users\\wangsy\\Desktop\\learning\\cl2\\psc.jpg"</span>).convert(<span class="string">"L"</span>))</span><br><span class="line"></span><br><span class="line">print(im.shape)</span><br><span class="line"></span><br><span class="line">imNew,_ = ROF.denoise(im,im)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ROF.compare(im, imNew)</span><br></pre></td></tr></table></figure>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/1586354712596.png" style="zoom: 67%;" /></p>
<p>发现并没有什么变化。。。为了证明我们这几天的学习是有用的，我决定再给她做一个直方图均衡！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">imNew,_ = modules.histeq(imNew)</span><br><span class="line"></span><br><span class="line">ROF.compare(im, imNew)</span><br></pre></td></tr></table></figure>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/1586354827890.png" style="zoom:67%;" /></p>
<p>emmmm，不说了，这年头进医院有点危险，我要做好防护了。不行！一定是灰度图的问题，我要这样完成美化任务：</p>
<ul>
<li><p>Step1：使用RGB通道读入图形</p></li>
<li><p>Step2：对每个通道的图形单独进行ROF</p></li>
<li><p>Step3：用生成出来的图片装逼，跳</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> ROF</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> measurements, morphology, binary_erosion</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> modules</span><br><span class="line"></span><br><span class="line">im = array(Image.open(<span class="string">"C:\\Users\\wangsy\\Desktop\\learning\\cl2\\psc.jpg"</span>))</span><br><span class="line"></span><br><span class="line">imNew = zeros((im.shape))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line"></span><br><span class="line">    imNew[:,:,i], _ =  ROF.denoise(im[:,:,i],im[:,:,i])</span><br><span class="line"></span><br><span class="line">imNew = imNew/<span class="number">255.</span></span><br><span class="line"></span><br><span class="line">ROF.compare(im,imNew)</span><br></pre></td></tr></table></figure>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/1586356175907.png" style="zoom:50%;" /></p>
<p>这也没啥差别啊。。啊！你看将图片放大后，右边的也就是P过的图变得更白了呢！（确信）</p>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/1586356269773.png" style="zoom: 33%;" /></p>
<p>不行，这样的效果不够明显，但是我又不会别的东西，那就在再每一层加个直方图均衡！</p>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/1586356398861.png" style="zoom:50%;" /></p>
<p>你快看呢！我给你染了个奶奶灰！得了，我没招了GG。</p>
<h3 id="其他真实图片">其他真实图片</h3>
<p>为什么对于上面的图片，我们的P图ROF没有用了呢？我觉得有以下原因：</p>
<ul>
<li><p>一、P图软件（轻颜相机）已经对图像进行了降噪，反复降噪效果不大</p></li>
<li><p>二、由于现代拍摄技术的成熟再加上拍摄场景较为明亮，图片本身噪点就不高</p></li>
</ul>
<p>我用我ipad的原相机在漆黑的夜晚拍了一张图片，我们用这张图片再来看一下降噪的效果：</p>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/IMG_0551.JPG" style="zoom: 15%;" /></p>
<p>这张照片很大，也很糊，我们需要先把它resize一下，让他小一点，我们好快点处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> ROF</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> measurements, morphology, binary_erosion</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> modules</span><br><span class="line"></span><br><span class="line">im = array(Image.open(<span class="string">"C:\\Users\\wangsy\\Desktop\\learning\\cl2\\IMG_0551.JPG"</span>))</span><br><span class="line"></span><br><span class="line">print(im.shape)</span><br><span class="line"></span><br><span class="line">im = modules.imresize(im,(im.shape[<span class="number">0</span>]//<span class="number">3</span>,im.shape[<span class="number">0</span>]//<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">imNew = zeros((im.shape))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line"></span><br><span class="line">    imNew[:,:,i], _ =  ROF.denoise(im[:,:,i],im[:,:,i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># imNew[:,:,i], _ = modules.histeq(imNew[:,:,i])</span></span><br><span class="line"></span><br><span class="line">imNew = imNew/<span class="number">255.</span></span><br><span class="line"></span><br><span class="line">ROF.compare(im,imNew)</span><br></pre></td></tr></table></figure>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/1586356903454.png" style="zoom: 33%;" /></p>
<p>观察上面的图片我们还是看不到太多的区别，但是我们将他们放大：</p>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/1586356943023.png" style="zoom:33%;" /></p>
<p>我们会发现，左边的（原图）噪点明显，而右边的图像则较为平滑。</p>
<p>另外，我想介绍另一个功能，我们对这张图进行直方图均衡化:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> ROF</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> measurements, morphology, binary_erosion</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> modules</span><br><span class="line"></span><br><span class="line">im = array(Image.open(<span class="string">"C:\\Users\\wangsy\\Desktop\\learning\\cl2\\IMG_0551.JPG"</span>))</span><br><span class="line"></span><br><span class="line">print(im.shape)</span><br><span class="line"></span><br><span class="line">im = modules.imresize(im,(im.shape[<span class="number">0</span>]//<span class="number">3</span>,im.shape[<span class="number">0</span>]//<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">imNew = zeros((im.shape))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line"></span><br><span class="line">    imNew[:,:,i], _ =  ROF.denoise(im[:,:,i],im[:,:,i])</span><br><span class="line"></span><br><span class="line">    imNew[:,:,i], _ = modules.histeq(imNew[:,:,i])</span><br><span class="line"></span><br><span class="line">imNew = imNew/<span class="number">255.</span></span><br><span class="line"></span><br><span class="line">ROF.compare(im,imNew)</span><br></pre></td></tr></table></figure>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/1586357031349.png" style="zoom: 67%;" /></p>
<p>小区的雨棚、水管、树丛、墙、路都非常清晰的显示出来了！为了再探索一下这个东西，我决定在漆黑的卧室里给我拍个照片，看看用这个做会怎么样！</p>
<p><img src="https://saiyu-wang-blog.oss-cn-shenzhen.aliyuncs.com/1586357335540.png" style="zoom: 67%;" /></p>
<p>左边是给自己拍的照片，右边是使用直方图均衡化后的照片，属实nb。</p>
<ul>
<li><p>我装逼：bulabulabula！！！</p></li>
<li><p>女朋友：哦</p></li>
</ul>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>通过outlook邮箱实现windows、安卓、ios三平台日历同步</title>
    <url>/2020/04/07/%E9%80%9A%E8%BF%87outlook%E9%82%AE%E7%AE%B1%E5%AE%9E%E7%8E%B0windows%E3%80%81%E5%AE%89%E5%8D%93%E3%80%81ios%E4%B8%89%E5%B9%B3%E5%8F%B0%E6%97%A5%E5%8E%86%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>开学一阵子了，最近各大高校都在网上授课，在上(mo)课(yu)的时候忽然看到一篇博客：<a href="https://sspai.com/post/39645" target="_blank" rel="noopener">又到了每年此刻，教你把课程表导入日历</a>，忽然惊起，感叹道:把课程表导入日历，让日历提醒我上课！这样就不会因为coding(moyu)影响到我上(gua)课(ji)了。 再导入电脑后，我还希望能够把电脑日历中的内容和手机、平板同步，我使用的设备是：<strong>win10电脑+华为手机+ipad</strong>。 通过阅读这篇博客，你将学会：<strong>如何通过outlook账号，将win10日历、华为日历、苹果日历同步，达到一平台更改，多平台更新的效果。</strong></p>
<h1 id="第一步outlook邮箱注册">第一步——outlook邮箱注册</h1>
<p>注册一个outlook邮箱，这个没什么好讲的，注册的时候也没什么要求，我当时就是一路yes点下去的 # 第二步——windows端登录账号 点击电脑右下角日历 <img src="https://img-blog.csdnimg.cn/20200228161326364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="右下角日历" /> 进入日历界面（没操作过的话不会有这些事件） <img src="https://img-blog.csdnimg.cn/20200228161355625.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="日历界面" /> 点击左下角<strong>设置-&gt;管理账户-&gt;添加账户</strong>添加你刚注册好的outlook账户 <img src="https://img-blog.csdnimg.cn/20200228161628521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="添加账户" /> 添加成功后，左边这一栏里面会出现你的账户，我这里的账户名叫做Outlook，勾选你要同步的日历（目前为空） <img src="https://img-blog.csdnimg.cn/20200228161937840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="勾选日历" /> 到此为止，电脑端操作结束。</p>
<h1 id="第三步在手机端添加outlook日历">第三步——在手机端添加outlook日历</h1>
<p>打开华为自带日历： <img src="https://img-blog.csdnimg.cn/20200228170325553.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="华为自带日历" /> 点击左方菜单，进入日历账户管理，点击添加账户，账户类型为exchange： <img src="https://img-blog.csdnimg.cn/20200228170458795.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="exchange" /> 选择类型为公司，将自己的outlook账号填上去就可以了，密码直接填自己的windows登陆密码即可，这样，电脑端和手机端的连接就完成了！</p>
<h1 id="第四步在ios端添加outlook日历">第四步——在IOS端添加outlook日历</h1>
<p>以ipad为例，设置--&gt;密码域账户--&gt;添加账户，和手机端一样，将outlook邮箱登录，即可完成ipad上面</p>
<h1 id="完成">完成</h1>
<p>到此为止，三个平台的同步就完成了，我试过很多方法，qq邮箱、等等都不如outlook方便。</p>
]]></content>
      <categories>
        <category>乱搞</category>
      </categories>
      <tags>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title>python图像处理笔记(一)</title>
    <url>/2020/04/07/python%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="图像处理笔记一">图像处理笔记(一)</h1>
<h2 id="直方图均衡化">直方图均衡化</h2>
<h3 id="参考文档">参考文档</h3>
<p>[1] Jan Erik Solem. Python计算机视觉编程 (图灵程序设计丛书) (p. 11). 人民邮电出版社.</p>
<p>[2] 直方图均衡化</p>
<h3 id="代码">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直方图均衡化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">histeq</span><span class="params">(im, nbr_bins = <span class="number">256</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    对一副灰度图像进行直方图均衡化</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 计算图像的直方图</span></span><br><span class="line">    imhist, bins = histogram(im.flatten(), nbr_bins, normed = <span class="literal">True</span>)</span><br><span class="line">    cdf = imhist.cumsum()</span><br><span class="line">    cdf = <span class="number">255</span> * cdf / cdf[<span class="number">-1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用累积分布函数的线性插值，计算新的像素值</span></span><br><span class="line">    im2 = interp(im.flatten(), bins[:<span class="number">-1</span>], cdf)</span><br><span class="line">    <span class="keyword">return</span> im2.reshape(im.shape), cdf</span><br></pre></td></tr></table></figure>
<h3 id="讲解">讲解</h3>
<h4 id="解决的问题">解决的问题</h4>
<figure>
<img src="https://img-blog.csdnimg.cn/20200407233710618.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>通常，暗图像直方图的分量集中在灰度较低的一端，而亮图像直方图分量偏向于灰度较高的一端。</p>
<p>从图中可以得到这样的结论：如果一幅图像的灰度直方图几乎覆盖了整个灰度的取值范围，并且除了个别灰度值的个数较为突出，整个灰度值分布近似于均匀分布，那么这幅图像就具有较大的灰度动态范围和较高的对比度，同时图像的细节更为丰富。已经证明，仅仅依靠输入图像的直方图信息，就可以得到一个变换函数，利用该变换函数可以将输入图像达到上述效果，该过程就是直方图均衡化。</p>
<p>一句话说，就是直方图的值都聚在一块不清楚，均衡化之后能清除很多。</p>
<h3 id="方法">方法</h3>
<p>将图像中的灰度级均匀的映射到整个灰度级范围，具体的方法如下：</p>
<ul>
<li>前提假设：在一张有N个像素点的图片中，有灰度值的取值范围是0~M，你希望映射到的范围是<span class="math inline">\([x,y]\)</span></li>
<li>第一步：统计每一个灰度值出现的次数<span class="math inline">\(t_i\)</span>，其中<span class="math inline">\(i\)</span>代表灰度，<span class="math inline">\(t_i\)</span>代表其出现的次数</li>
<li>第二步：计算每一种灰度值对应的像素点个数在总体中占比<span class="math inline">\(P_i = \frac{t_i}{N}\)</span></li>
<li>第三步：计算累计占比<span class="math inline">\(\sigma P_i=\Sigma_{i=0}^{i}P_i\)</span></li>
<li>第四步：计算映射后的灰度值<span class="math inline">\(final_i=\sigma P_i*(y-x+1)\)</span></li>
</ul>
<h2 id="图像平均">图像平均</h2>
<h3 id="代码-1">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_average</span><span class="params">(imList)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算图像列表的平均图像</span></span><br><span class="line"><span class="string">    imList ： 一个列表，里面包含很多图像</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 打开一张图像，将其存放在浮点数类型数组中</span></span><br><span class="line">    averageim = array(Image.open(imlist[<span class="number">0</span>]), <span class="string">'f'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> imname <span class="keyword">in</span> imlist[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            averageim += array(Image.open(imname))</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(imname + <span class="string">'...skipped'</span>)</span><br><span class="line">    averageim /= len(imlist)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array(averageim, <span class="string">'uint8'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="讲解-1">讲解</h3>
<p>没啥好讲的，把一堆图拉到一块，平均一下即可。这个方法可以用于降噪， 但是我们也会发现，这个方法要把所有图片都拉到内存里，如果要平均很多的图片的话，我们需要拉很多的内存，不过又有一种方法就是可以每次平均一张也就是每次新引入一张，也可以。</p>
<h2 id="图像的主成分分析pca">图像的主成分分析（PCA）</h2>
<h3 id="参考资料">参考资料</h3>
<p>[1] Jan Erik Solem. Python计算机视觉编程 (图灵程序设计丛书) (p. 11). 人民邮电出版社.</p>
<p>[2] <a href="https://www.bilibili.com/video/BV1F441187rd?from=search&amp;seid=4973130116529586818" target="_blank" rel="noopener">机器学习经典算法：PCA降维与SVD矩阵分解</a>—— <a href="https://space.bilibili.com/410704854" target="_blank" rel="noopener">自兴人工智能教育</a></p>
<p>主成分分析法，老朋友了。这个目前已知的有两种用法：</p>
<ul>
<li>降低数据维度</li>
<li>求每一个值在总体中的客观权重（重要程度）</li>
</ul>
<p>利用这个可以做图像的缩略图，它的优点是能在降维的时候，同时尽量多的保持训练数据的信息，这就很nb了。</p>
<h3 id="代码-2">代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PCA</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pca</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    主成分分析法：</span></span><br><span class="line"><span class="string">    输入： 矩阵X，其中该矩阵中储存训练数据，每一行为一条训练数据</span></span><br><span class="line"><span class="string">    返回：投影矩阵（按维度的重要性排序）、方差和均值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 转化成numpy.array矩阵</span></span><br><span class="line">    X = np.array(X)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取维度</span></span><br><span class="line">    num_data, dim = X.shape</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 数据中心化</span></span><br><span class="line">    mean_X = X.mean(axis = <span class="number">0</span>)</span><br><span class="line">    X = X - mean_X</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dim &gt; num_data):</span><br><span class="line">        <span class="comment"># PCA - 使用紧致技巧</span></span><br><span class="line">        M = dot(X,X.T) <span class="comment"># 协方差矩阵</span></span><br><span class="line">        e, EV = linalg.eigh(M) <span class="comment"># 特征值和特征向量</span></span><br><span class="line">        tmp = dot(X.T, EV).T <span class="comment">#紧致技巧？？？说实话我还是不懂</span></span><br><span class="line">        V = tmp[::<span class="number">-1</span>]<span class="comment"># 由于最后的特征向量是我们所需要的，所以要将它逆转</span></span><br><span class="line">        S = sqrt(e)[::<span class="number">-1</span>]<span class="comment"># 由于特征值是按照递增顺序排列的，所以需要将其逆转</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(V.shape[<span class="number">1</span>]):</span><br><span class="line">            V[:, i] /= S</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="comment"># PCA- 使用SVD方法</span></span><br><span class="line">        U, S, V = linalg.svd(X)</span><br><span class="line">        V = V[:num_data] <span class="comment"># 仅仅返回前num_data 维的数据才合理</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> V, S, mean_X</span><br></pre></td></tr></table></figure>
<h3 id="原理">原理</h3>
<h4 id="pca">PCA</h4>
<h5 id="pca做了什么">PCA做了什么？</h5>
<p>众所周知，PCA可以用来降维，举例来说，如果现在由一组数据，规格是100*4的，也就是说，有100组数据，每组数据有4个特征，现在我们想把它的每一组特征的数目降到2，变化完成后，变成100*2的矩阵，那么这个变化需要什么呢？学过线代的同学都懂了，这里需要在乘上个4*2的矩阵就可以完成这种变化，那么求这个4*2的矩阵，就是PCA的主要任务。</p>
<h5 id="操作流程">操作流程</h5>
<ul>
<li><p>第一步：先对数据进行标准化操作</p></li>
<li><p>第二步：计算协方差矩阵</p>
<p>什么是协方差：</p>
<p>协方差：<span class="math inline">\(\sigma_{jk}=\frac{1}{n-1}\Sigma_{i=1}^n(x_{ij}-x_{j}.mean)(x_{ik}-x_k.mean)\)</span></p>
<p>协方差代表着两个数据之间的相关性，相关性越大，协方差越大</p>
<p>协方差矩阵蕴含着任意两个变量之间的协方差</p>
<p>协方差矩阵的计算：<span class="math inline">\(\Sigma=\frac{1}{n-1}((X-x.mean^T(X-x.mean))\)</span></p></li>
<li><p>对协方差矩阵求特征值和特征向量：</p>
<p>什么是特征值和特征向量?</p>
<p>线性代数学了一年多了，现在只记得加减乘和转置了，取个逆都是高端操作了，特征值和特征向量是啥来着？不记得了。</p>
<p>直接看定义：<span class="math inline">\(A\)</span> 是<span class="math inline">\(n\)</span>阶方阵，若存在数<span class="math inline">\(\lambda\)</span>和非零向量x使得<span class="math inline">\(Ax = \lambda x\)</span>那么称<span class="math inline">\(\lambda\)</span>是A的一个特征值，<span class="math inline">\(x\)</span>为A的对应于特征值<span class="math inline">\(\lambda\)</span>的特征向量。</p>
<p>我们现在有一个这样的矩阵： <span class="math display">\[
a = \left[
\begin{matrix}
1 &amp; 2&amp;3&amp;4\\
2&amp;1&amp;5&amp;6\\
3&amp;5&amp;1&amp;7\\
4&amp;6&amp;7&amp;1
\end{matrix}
\right]
\]</span> 我们使用语句：np.linalg.eig(a)，得到了以下结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">7</span>],[<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>]])</span><br><span class="line">In [<span class="number">10</span>]: b,c = np.linalg.eig(a)</span><br><span class="line">In [<span class="number">11</span>]: b, c</span><br><span class="line">Out[<span class="number">11</span>]:</span><br><span class="line">(array([<span class="number">15.01698746</span>, <span class="number">-0.67469831</span>, <span class="number">-4.04123361</span>, <span class="number">-6.30105553</span>]),</span><br><span class="line"> array([[ <span class="number">0.35249192</span>,  <span class="number">0.89949656</span>, <span class="number">-0.21038586</span>, <span class="number">-0.14964351</span>],</span><br><span class="line">        [ <span class="number">0.49287878</span>, <span class="number">-0.40507255</span>, <span class="number">-0.72842863</span>, <span class="number">-0.24975682</span>],</span><br><span class="line">        [ <span class="number">0.54203206</span>, <span class="number">-0.15251679</span>,  <span class="number">0.63351659</span>, <span class="number">-0.53065677</span>],</span><br><span class="line">        [ <span class="number">0.58225527</span>, <span class="number">-0.05967247</span>,  <span class="number">0.15422794</span>,  <span class="number">0.79600989</span>]]))</span><br></pre></td></tr></table></figure>
<p>我们根据刚才的定义进行检验：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: b[<span class="number">0</span>]*c[:,<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">26</span>]: array([<span class="number">5.29336674</span>, <span class="number">7.40155453</span>, <span class="number">8.13968862</span>, <span class="number">8.74372006</span>])</span><br><span class="line">In [<span class="number">27</span>]: np.dot(a,c[:,<span class="number">0</span>])</span><br><span class="line">Out[<span class="number">27</span>]: array([<span class="number">5.29336674</span>, <span class="number">7.40155453</span>, <span class="number">8.13968862</span>, <span class="number">8.74372006</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">28</span>]: b[<span class="number">1</span>]*c[:,<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">28</span>]: array([<span class="number">-0.60688881</span>,  <span class="number">0.27330177</span>,  <span class="number">0.10290282</span>,  <span class="number">0.04026092</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: np.dot(a,c[:,<span class="number">1</span>])</span><br><span class="line">Out[<span class="number">29</span>]: array([<span class="number">-0.60688881</span>,  <span class="number">0.27330177</span>,  <span class="number">0.10290282</span>,  <span class="number">0.04026092</span>])</span><br></pre></td></tr></table></figure>
<p>所以我们得到了四组特征向量和特征值，据说特征值代表着当前特征向量的重要程度。</p>
<p>对这些特征值进行归一化，将他们映射到1~100的区间中。</p></li>
</ul>
<figure>
<img src="https://img-blog.csdnimg.cn/20200407233729395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>可以看到，后两个特征值都太小了，而且我们的任务是把这个100*4的矩阵转化成100*2的矩阵，所以我们需要选取两个特征向量，所以呢我们就去选最大的两个特征值所对应的特征向量，也就是特征向量0和1。</p>
<p>将他们合成一个4*2的矩阵，计算原矩阵与他们的矩阵乘法，就可以得到新的特征矩阵了。</p>
<h4 id="svd矩阵分裂">SVD矩阵分裂</h4>
<h5 id="目标">目标</h5>
<p>将一个矩阵A分解三个矩阵的乘积：</p>
<p>如下:</p>
<pre class="mermaid">graph LR
A[A m*n] -->u[u m*m]
A[A m*n] -->S[S m*n]
A[A m*n] -->V[V n*n]</pre>
<p>我们的目标是将一个m*n的矩阵A拆分成u*S*V的形式，他们的形状如上图所示。</p>
<p>其中S是一个对角矩阵，对角矩阵就是只有主对角线上的元素不是零的矩阵，你还看不懂什么叫对角矩阵的话建议百度。</p>
<p>剩下的看这篇博客 https://mp.weixin.qq.com/s/Dv51K8JETakIKe5dPBAPVg</p>
<h2 id="使用pickle模块">使用pickle模块</h2>
<p>pickle可以接受几乎所有python的对象，并且将其转换成字符串表示，这个过程叫做<strong>封装(pickling)</strong>。从字符串表示中重构该对象，成为<strong>拆封(unpickling)</strong>。这些字符串表示可以方便的储存和传输。</p>
<h3 id="储存">储存</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'font_pca_modules.pkl'</span>, <span class="string">'wb'</span>)</span><br><span class="line">pickle.dump(immean,f)</span><br><span class="line">pickle.dump(V,f)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>在上述的例子中，许多对象可以保存到同一文件中。pickle模块中有很多不同协议可以生成.pkl文件，如果不确定的话，最好以二进制文件的形式去读取、写入。在其他python会话中载入数据，只需要使用load()方法。</p>
<h3 id="读取">读取</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">'font_pca_modules.pkl'</span>, <span class="string">'rb'</span>)</span><br><span class="line">immean = pickle.load(f)</span><br><span class="line">V = pickle.load(f)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>需要注意的是，dump的顺序和load的顺序必须一样，当然，与文件相关的读写操作可以用with语句完成，这样可以避免文件开关导致的错误。</p>
<h3 id="使用with的保存和载入">使用with的保存和载入</h3>
<h4 id="保存">保存</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'font_pca_modules.pkl'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pickle.dump(immean,f)</span><br><span class="line">	pickle.dump(V,f)</span><br></pre></td></tr></table></figure>
<h4 id="载入">载入</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'font_pca_modules.pkl'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    immean = pickle.load(f)</span><br><span class="line">	V = pickle.load(f)</span><br></pre></td></tr></table></figure>
<p>从本质上说这两种方法没什么不同的，就是在with的作用域中，f是开的，出了with的作用域后，f就会自动关闭，当然我本人是不喜欢这种代码形式的，但是为了让自己的代码风格尽量规范，我决定适应这一形式。</p>
<h2 id="scipy">Scipy</h2>
<h3 id="图像模糊">图像模糊</h3>
<p>作者在这里又不经意的抛出了一个重点。。</p>
<p>图像的<strong>高斯模糊</strong>的实质就是灰度图像I和一个高斯核进行卷积的操作。</p>
<p>这里给没有入门的兄弟萌讲一下，什么叫卷积，数学上两个函数的卷积，我目前还没有学（大二下）。图的卷积只是借了一个概念而已，简单地讲：假如有一个<span class="math inline">\(n \times n\)</span>的矩阵A ，还有一个<span class="math inline">\(3 \times3\)</span>的滤波器B。不要纠结什么叫滤波器，下面会讲清楚的。他们现在分别长这个样子： <span class="math display">\[
A = 
\left[
\begin{matrix}
a_{1,1} &amp; a_{1,2} &amp;... &amp; a_{1,n} \\
a_{2,1} &amp; a_{2,2} &amp;... &amp; a_{2,n} \\
...  &amp;...&amp; &amp;... \\
a_{n,1} &amp;a_{n,2}&amp;... &amp;a_{n,n}
\end{matrix}
\right],
B = 
\left[
\begin{matrix}
-1&amp;0&amp;1\\
-1&amp;0&amp;1\\
-1&amp;0&amp;1
\end{matrix}
\right]
\]</span> A和B进行卷积操作，生成了个什么玩意呢?很简单，生成了一个新的矩阵，这个矩阵的每一个元素就像是下面的图片里一样（特殊说明：下面的图片是我在<a href="https://www.cnblogs.com/SivilTaram/p/graph_neural_network_2.html" target="_blank" rel="noopener">这个网站</a>上面直接拿的）</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vU2l2aWxUYXJhbS8xNTEwNDg1L29faW1hZ2UtMTMtY29udi1jbm4uZ2lm" /></p>
<p>所以我们可以做一个联想，卷积就是拿着一个放大镜把这个图扫一遍生成一张新的图，放大镜(也就是滤波器)不一样，得到的结果也不一样。</p>
<p>下面我们来看一下如何对一张图片进行高斯模糊。talk is free，代码来了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> filters</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(im1, im2, module = <span class="string">'gray'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    在一张图里面显示两个图片</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">8</span>),ncols=<span class="number">2</span>,nrows=<span class="number">1</span>)</span><br><span class="line">    ax[<span class="number">0</span>].imshow(im1, module)</span><br><span class="line">    ax[<span class="number">1</span>].imshow(im2, module)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">im = array(Image.open(<span class="string">"C:\\Users\\wangsy\\Desktop\\learning\\timg.jpg"</span>).convert(<span class="string">"L"</span>))</span><br><span class="line">im2 = filters.gaussian_filter(im, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">compare(im, im2)</span><br></pre></td></tr></table></figure>
<p>主体就只有下面两行，filters.gaussian_filter(im, 5)，这里的第一个参数代表需要进行高斯模糊的矩阵，第二个代表标准差，这个大家都懂，最后的效果如下:</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200407233741180.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>我们将标准差从5降低到2进行观察，发现果然模糊的程度降低了。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200407233749131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>如果要对一张彩色图像进行高斯模糊（彩色图形就是多通道图形，我们的灰度图只有一个通道，而通常彩色图形是由RGB三个通道组成的），我们只需要对他的每一层进行高斯模糊即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> filters</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(im1, im2, module = <span class="string">'gray'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    在一张图里面显示两个图片</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">8</span>),ncols=<span class="number">2</span>,nrows=<span class="number">1</span>)</span><br><span class="line">    ax[<span class="number">0</span>].imshow(im1, module)</span><br><span class="line">    ax[<span class="number">1</span>].imshow(im2, module)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">im = array(Image.open(<span class="string">"C:\\Users\\wangsy\\Desktop\\learning\\timg.jpg"</span>))</span><br><span class="line">im2 = zeros(im.shape)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    im2[:, :, i] = filters.gaussian_filter(im[:, :, i], <span class="number">5</span>)</span><br><span class="line">im2 = uint8(im2)</span><br><span class="line">compare(im, im2)</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200407233757627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>将标准差降低到2，效果如下</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200407233804321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>对于三通道，我产生了一种很奇葩的想法， 那就是如果每一层用于模糊的标准差不一样会发生什么？我将模糊的值从全都是五改为了i*3：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">im2[:, :, i] = filters.gaussian_filter(im[:, :, i], i*<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>模糊后的图片变成了这样：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200407233812348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>我们可以理解，因为图像中的红色被模糊的较少，比较强烈，而蓝色和绿色被模糊的程度较大，无法保持原来的亚子，所以红色的框架被显现出来。</p>
<p>将模糊值调节到i*20，我们会发现， 这变成了一张具有魔幻现实主义的图片😂</p>
<figure>
<img src="https://img-blog.csdnimg.cn/2020040723382746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<h3 id="图像导数">图像导数</h3>
<h5 id="参考资料-1">参考资料</h5>
<p>[1] <a href="https://www.cnblogs.com/molakejin/p/5683372.html" target="_blank" rel="noopener">边缘检测的各种微分算子比较</a></p>
<p>从书中可以看出来，在很多应用中图像强度的变化情况是非常重要的信息。强度的变化可以用灰度图像<span class="math inline">\(I\)</span>的<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>方向导数<span class="math inline">\(I_x\)</span>和<span class="math inline">\(I_y\)</span>进行描述。</p>
<p>梯度之中包含两个信息：</p>
<ul>
<li><p><strong>梯度的大小</strong>：</p>
<p><span class="math inline">\(|\Delta I| = \sqrt{I_x^2 + I_y^2}\)</span></p>
<p>他描述了图像变化的强弱</p></li>
<li><p><strong>梯度的角度</strong>：</p>
<p><span class="math inline">\(\alpha = arctan2(I_y,I_x)\)</span></p>
<p>描述了图像中在每一个点上强度变化的最大方向。</p></li>
</ul>
<p>我们可以使用离散点近似的方式来计算图像的导数。图像的导数可以通过卷积简单地实现： <span class="math display">\[
I_x = I * D_x ,I_y = I*D_y
\]</span> 对于<span class="math inline">\(D_x\)</span>和<span class="math inline">\(D_y\)</span>，通常选择 Prewitt 滤波器： <span class="math display">\[
D_x = \left[
\begin{matrix}
-1&amp;0&amp;1\\
-1&amp;0&amp;1\\
-1&amp;0&amp;1
\end{matrix}
\right],
D_y = \left[
\begin{matrix}
-1&amp;-1&amp;-1\\
0&amp;0&amp;0\\
1&amp;1&amp;1
\end{matrix}
\right]
\]</span> 或者是 Sobel 滤波器： <span class="math display">\[
D_x = \left[
\begin{matrix}
-1&amp;0&amp;1\\
-2&amp;0&amp;2\\
-1&amp;0&amp;1
\end{matrix}
\right],
D_y = \left[
\begin{matrix}
-1&amp;-2&amp;-1\\
0&amp;0&amp;0\\
1&amp;2&amp;1
\end{matrix}
\right]
\]</span></p>
<p>如果你看懂了上一节像关于<strong>什么是滤波器</strong>的问题的话，这里应该不难理解，如果你没看懂，那大概率是我没有讲清楚，你可以去网上搜集一些视频教程或是博客帮助自己理解。这两种滤波器的区别是： 据经验得知Sobel要比Prewitt更能准确检测图像边缘。</p>
<p>下面看一下效果:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> scipy.ndimage <span class="keyword">import</span> filters</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span><span class="params">(im1, im2, module = <span class="string">'gray'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    在一张图里面显示两个图片</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    fig, ax = plt.subplots(figsize=(<span class="number">12</span>,<span class="number">8</span>),ncols=<span class="number">2</span>,nrows=<span class="number">1</span>)</span><br><span class="line">    ax[<span class="number">0</span>].imshow(im1, module)</span><br><span class="line">    ax[<span class="number">1</span>].imshow(im2, module)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">im = array(Image.open(<span class="string">"C:\\Users\\wangsy\\Desktop\\learning\\timg.jpg"</span>).convert(<span class="string">"L"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sobel</span></span><br><span class="line">imx = zeros(im.shape)</span><br><span class="line">filters.sobel(im,<span class="number">1</span>,imx)</span><br><span class="line"></span><br><span class="line">imy = zeros(im.shape)</span><br><span class="line">filters.sobel(im,<span class="number">0</span>,imy)</span><br><span class="line"></span><br><span class="line">magnitude = sqrt(imx**<span class="number">2</span> + imy**<span class="number">2</span>)</span><br><span class="line">compare(im, magnitude)</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://img-blog.csdnimg.cn/20200407233841758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>上面展示的是最后提取的X轴和Y轴综合的梯度图</p>
<p><img src="https://img-blog.csdnimg.cn/20200407233849490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 上面两张分别是X轴和Y轴检测的。</p>
<p>今天先到这里。</p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>最优化技术——线性规划</title>
    <url>/2020/04/03/%E6%9C%80%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="最优化技术线性规划">最优化技术——线性规划</h1>
<h2 id="线性规划基本概念">线性规划基本概念</h2>
<p>线性规划问题就是在一组线性约束条件下，求解目标函数最优解的问题</p>
<h3 id="标准形式">标准形式</h3>
<p>线性规划问题的标准形式：</p>
<ul>
<li>目标函数求最大值</li>
<li>所有约束条件均由等式表示</li>
<li>每个约束条件右端常数常为非负值</li>
<li>所有决策变量为非负值</li>
</ul>
<h3 id="改造方法">改造方法</h3>
<p>所有的情况与改造方法</p>
<ul>
<li><p>目标<strong>函数求最小值则应该改为求最大值</strong>：</p>
<ul>
<li><p><strong>方法——添加负号</strong>：</p>
<p><span class="math display">\[ min F  = \Sigma c_jx_j  \rightarrow maxF = -\Sigma c_jx_j\]</span></p></li>
</ul></li>
<li><p>约束条件中，某些<strong>常数项bi为负数</strong></p>
<ul>
<li><p><strong>方法——在约束条件两边乘以负号</strong></p>
<p><span class="math display">\[\Sigma a_{i,j}x_j&gt;-3 \rightarrow -\Sigma a_{i,j}x_j&lt;3\]</span></p></li>
</ul></li>
<li><p>约束条件<strong>不等式符号为&lt;=</strong></p>
<ul>
<li><p><strong>方法——在不等式左边加上一个非负变量（松驰变量）</strong></p>
<p><span class="math display">\[\Sigma a_{i,j}x_j \leq b_i \rightarrow \Sigma_{j=1}^m a_{ij}x_j+x_{m+1}=b_i\]</span></p></li>
</ul></li>
<li><p>约束条件<strong>不等式符号为&gt;= </strong></p>
<ul>
<li><p><strong>在不等式左边减去一个非负变量（剩余变量）</strong></p>
<p><span class="math display">\[\Sigma a_{i,j}x_j \geq b_i \rightarrow \Sigma_{j=1}^m a_{ij}x_j-x_{m+1}=b_i\]</span></p></li>
</ul></li>
<li><p>约束条件中某变量有如下限制：</p>
<ul>
<li><p>一、某变量<strong>必须为负数</strong>,即：<span class="math display">\[x_j \leq0\]</span>:</p>
<ul>
<li><p><strong>方法——设置一个新的变量</strong></p>
<p><span class="math display">\[x_j&#39; = -x_j\]</span></p></li>
</ul></li>
<li><p>二、某个变量<strong>无符号限制</strong>：</p>
<ul>
<li><p><strong>方法——将该变量拆分成两个正数的差</strong></p>
<p><span class="math display">\[V_k \geq 0, U_k \geq 0,X_k = V_k - U_k\]</span></p></li>
</ul></li>
</ul></li>
</ul>
<h3 id="例题">例题</h3>
<p>一、</p>
<p><span class="math display">\[min F = -3x_1 + 4x_2 -2x_3 + 5x_4\]</span></p>
<p><span class="math inline">\(s.t.\)</span></p>
<p><span class="math display">\[4x_1 - x_2+2x_3-x_4=-2\]</span></p>
<p><span class="math display">\[x_1+x_2+2x_3-x_4 \leq14\]</span></p>
<p><span class="math display">\[-2x_1+3x_2-x_3+2x_4\geq2\]</span></p>
<p><span class="math display">\[x_1\geq0,x_2\leq0,x_3\geq0\]</span></p>
<p>将上面的式子化成标准型，首先需要检查上面的式子中有哪些地方不符合我们的要求：</p>
<ol type="1">
<li>目标函数为最小值<span class="math display">\[min F = -3x_1 + 4x_2 -2x_3 + 5x_4\]</span></li>
<li>等式约束右边为负数<span class="math display">\[4x_1 - x_2+2x_3-x_4=-2\]</span></li>
<li>不等式约束<span class="math display">\[x_1+x_2+2x_3-x_4 \leq14\]</span>，<span class="math display">\[-2x_1+3x_2-x_3+2x_4\geq2\]</span></li>
<li>约束中有小于零的<span class="math display">\[x_1\geq0,x_2\leq0,x_3\geq0\]</span></li>
</ol>
<p>额，经过整理我们发现。。。都不符合，所以需要一条一条的改：</p>
<table>
<thead>
<tr class="header">
<th>改前</th>
<th>改后</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math display">\[min F = -3x_1 + 4x_2 -2x_3 + 5x_4\]</span></td>
<td><span class="math display">\[maxS=-minF = 3x_1-4x_2+2x_3-5x_4\]</span></td>
</tr>
<tr class="even">
<td><span class="math display">\[4x_1 - x_2+2x_3-x_4=-2\]</span></td>
<td><span class="math display">\[-4x_1+x_2-2x_3+x_4 = 2\]</span></td>
</tr>
<tr class="odd">
<td><span class="math display">\[x_1+x_2+2x_3-x_4 \leq14\]</span></td>
<td><span class="math display">\[x_1+x_2+2x_3-x_4+x_5 =14\]</span></td>
</tr>
<tr class="even">
<td><span class="math display">\[-2x_1+3x_2-x_3+2x_4\geq2\]</span></td>
<td><span class="math display">\[-2x_1+3x_2-x_3+2x_4 -x_6= 2\]</span></td>
</tr>
<tr class="odd">
<td><span class="math display">\[x_2\leq0\]</span></td>
<td>设<span class="math display">\[x_7 \geq 0 , x_7 = - x_2\]</span></td>
</tr>
<tr class="even">
<td><span class="math display">\[x_4 \]</span>无约束</td>
<td>设<span class="math display">\[x_8,x_9\geq0,x_4 = x_8-x_9\]</span></td>
</tr>
</tbody>
</table>
<p>整理之后得到：</p>
<p><span class="math display">\[maxS=-minF = 3x_1+4x_7+2x_3-5x_8+5x_9\]</span></p>
<p><span class="math inline">\(s.t.\)</span></p>
<p><span class="math display">\[-4x_1-x_7-2x_3+x_8-x_9 = 2\]</span></p>
<p><span class="math display">\[x_1-x_7+2x_3-x_8+x_9+x_5 =14\]</span></p>
<p><span class="math display">\[-2x_1-3x_7-x_3+2x_8-2x_9 - x_6= 2\]</span></p>
<p><span class="math display">\[x_i \geq 0,j=1,3,5,6,7,8,9\]</span></p>
<h2 id="概念之凸集">概念之凸集</h2>
<figure>
<img src="https://img-blog.csdnimg.cn/20200402192222776.png" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<ul>
<li>凸集：如果集合C中任意两点<span class="math display">\[X_1,X_2\]</span>，其连线上的所有点也都是集合C中的点，称C为凸集。</li>
<li>有限个凸集的交集仍然是凸集</li>
<li>顶点：如果凸集C中不存在任何两个不同的点<span class="math display">\[X_1,X_2\]</span>，使<span class="math inline">\(X\)</span>成为这两个点连线上的一个点。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200402192251668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> ## 线性规划的一些定义</p>
<ul>
<li><p>定义一：凡是满足<span class="math display">\[Ax=b\]</span>及<span class="math display">\[x\geq0\]</span>的解<span class="math display">\[x = (x_1,x_2,..,x_n)^T\]</span>称为线性规划问题的<strong>可行解</strong>。同时满足<span class="math display">\[max Z = cx\]</span>的可行解称为最优解</p></li>
<li><p>定义二：设线性规划约束方程组的系数矩阵<span class="math inline">\(A_{m*n}\)</span>的秩为<span class="math inline">\(m\)</span>，则<span class="math inline">\(A\)</span>中某<span class="math inline">\(m\)</span>列组成的任一个<span class="math inline">\(m\)</span>阶可逆阵<span class="math inline">\(B\)</span>称为该线性规划问题的一个<strong>基矩阵</strong>，简称基。若记<span class="math inline">\(B=(p_1,p_2,…,p_m)\)</span>，则称<span class="math inline">\(p_k(k=1,2,…m)\)</span>为基B中的一个<strong>基向量</strong>。则A中其余n-m个列向量为非基向量。</p>
<p>感觉这里很象最大线性无关组。</p></li>
<li><p>定义3：当<span class="math inline">\(Ax=b\)</span>式中A确定了一个基B后，与基向量<span class="math inline">\(p_k\)</span>相对应的决策变量<span class="math inline">\(x_k\)</span>称为关于基B的一个<strong>基变</strong>量，而与非基向量所对应的决策变量称为<strong>非基变量</strong>。</p></li>
<li><p>定义4：设<span class="math display">\[B=(p_{k_1},p_{k_2},…,p_{k_m})\]</span>是A中的一个基，对应的基变量为<span class="math display">\[x_{k_1},x_{k_2},…,x_{k_m}\]</span>,我们称<strong>非基变量的取值均为零</strong>且满足约束条件的一个解x,为关于基B的一个<strong>基本解</strong>。</p></li>
</ul>
<h2 id="解的确定">解的确定</h2>
<h3 id="基本解的确定">基本解的确定</h3>
<p>B为一个基矩阵，<span class="math display">\[X_B\]</span>为对应的基变量， <span class="math inline">\(N\)</span>为非基矩阵，<span class="math inline">\(X_N\)</span>为对应的非基变量，那么<span class="math display">\[Ax=b\]</span>可以写成: <span class="math display">\[
BX_B+NX_N=b
\]</span> 由这个式子可以推出: <span class="math display">\[
X_B = B^{-1}b-B^{-1}NX_N
\]</span> 同时，根据基本解的定义，非基变量的解都是0，所以，最终的解是： <span class="math display">\[
\left[
\begin{matrix}
X_B\\
X_N
\end{matrix}
\right]
=
\left[
\begin{matrix}
B^{-1}b\\
0
\end{matrix}
\right]
\]</span> 这样的解也被称为<strong>关于基B的基本解</strong>，同时有定义五:</p>
<ul>
<li>满足非负条件<span class="math inline">\(x\geq0\)</span>的基本解称为<strong>基本可行解</strong></li>
</ul>
<h3 id="例题-1">例题</h3>
<p>求下列方程组的一个基本解、基本可行解</p>
<p><span class="math display">\[x_1 + 2x_2 \leq 8\]</span></p>
<p><span class="math display">\[x_2\leq 2\]</span></p>
<p>解:</p>
<ol type="1">
<li><p>首先将他化成标准形式</p>
<p><span class="math display">\[x_1+2x_2 +x_3 = 8\]</span></p>
<p><span class="math display">\[x_2+x_4 = 2\]</span></p></li>
<li><p>根据上方方程得到系数矩阵：</p>
<p><span class="math display">\[A=\left[\begin{matrix}1 &amp; 3 &amp; 1 &amp; 0\\0 &amp; 1 &amp; 0 &amp; 1 \end{matrix} \right]\]</span></p></li>
<li><p>取前两个列向量作为基向量，后两个就是非基向量</p>
<p><span class="math display">\[B = \left[ \begin{matrix}1 &amp; 2 \\ 0 &amp;1 \end{matrix} \right]\]</span></p></li>
<li><p>令非基变量<span class="math display">\[x_3, x_4 = 0\]</span>，可以得到基本解</p>
<p><span class="math display">\[(4,2,0,0)^T\]</span></p></li>
</ol>
<h3 id="图解法">图解法</h3>
<p>假设解以下问题</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200402192119676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>我们可以用图解法的方法解决（初中生就会的那种）</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200402192207733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>关于图解法的一些定理：</p>
<ul>
<li><strong>定理一</strong>：若线性规划问题存在可行解，则该问题的可行域一定是凸集</li>
<li><strong>定理二</strong>：线性规划问题的基本可行解X对应可行域（凸集）的顶点</li>
<li><strong>定理三：</strong>若问题存在最优解，一定存在一个基本可行解是最优解</li>
</ul>
<p>看到定理二忽然恍然大悟，原来我初中铤而走险，每次都只试交点的方法是有科学依据的（逃</p>
<p>定理三也非常有意义，因为它直接给我们提供了一种解决优化问题的方法：找出所有基本可行解然后再一个一个比较，直接得到最大的，但是可惜的是，这样的做法时间复杂度过高，电脑有点遭不住。</p>
]]></content>
      <categories>
        <category>最优化技术</category>
      </categories>
      <tags>
        <tag>最优化技术</tag>
        <tag>大二下</tag>
        <tag>课内学习</tag>
      </tags>
  </entry>
  <entry>
    <title>最优化技术——单纯形法</title>
    <url>/2020/04/03/%E6%9C%80%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%E2%80%94%E2%80%94%E5%8D%95%E7%BA%AF%E5%BD%A2%E6%B3%95/</url>
    <content><![CDATA[<h1 id="最优化技术单纯形法">最优化技术——单纯形法</h1>
<h2 id="说明">说明</h2>
<p>这个文章的大部分内容（几乎全部）都来自于我最优化课程的课程笔记。主要来源是重庆大学文静老师的PPT，个人主要用于整理、归纳，如果有侵权等问题，我会在第一时间将博客撤销。</p>
<h2 id="单纯形法的流程介绍">单纯形法的流程介绍</h2>
<figure>
<img src="https://img-blog.csdnimg.cn/20200402192453767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>直观的去看这个流程，有一点点像前面的一些函数的优化方法。但是在枚举的过程中，有一些问题值得关注：</p>
<ul>
<li>枚举的起点？</li>
<li>如何判断当前已经是最优解了？</li>
<li>如何在当前解的前提下找到一个更好的解？</li>
</ul>
<h2 id="单纯形法的迭代原理">单纯形法的迭代原理</h2>
<p>通过一个例子来讲解单纯形法的基本原理</p>
<p>我们这样一个线性规划问题：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200402192500440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>因为这里主要讨论单纯形法，所以我们不再纠结怎么化成标准型。</p>
<ol type="1">
<li><p>选择初始基，确定基本可行解</p>
<p>这里使用的是观察法(我：？？？)，观察系数矩阵中是否含有现成的单位阵，如果有的话就直接用现成的单位阵作为基。</p>
<p>在这里我们选定的基变量为：<span class="math display">\[(x_3,x_4,x_5)\]</span></p>
<p>选定的基矩阵为单位矩阵<span class="math display">\[I_3\]</span></p>
<p>找到的基本可行解：</p>
<p><span class="math display">\[\left[ \begin{matrix}x_B &amp; x_N \end{matrix} \right]  = \left[ \begin{matrix}B^{-1}b\ 0 \end{matrix} \right]\]</span></p>
<p>即：<span class="math display">\[x_1,x_2,x_3,x_4,x_5 = 0,0,8,16,12\]</span></p>
<p>Q:为什么要找单位阵?</p>
<p>A:我们都学过《线性代数》，线代告诉我们，一个矩阵能够被化作单位矩阵和这个矩阵可逆是等价的，有根据上一节讲的，在求解过程中需要对基去逆，所以综上所述，需要找一个单位阵/可以化成单位阵的。</p></li>
<li><p>判断当前解是否为最优解</p>
<p>将基变量使用非基变量表示，使用非基变量表示目标函数。</p>
<p><span class="math display">\[ x_3 = 8 - x_1 - 2x_2\]</span></p>
<p><span class="math display">\[ x_4 = 16 - 4x_1\]</span></p>
<p><span class="math display">\[x_5 = 12 - 4x_2\]</span></p>
<p><span class="math display">\[Z = 2x_1 +3x_2\]</span></p>
<p>我们的非基变量向上增加，目标函数<span class="math display">\[Z\]</span>的值也是增加的，所以说现在的基本可行解的取值不是最优的。那么什么时候它的取值才是最优的呢？</p>
<p>当非基变量的值增加，而目标函数的值不增加的时候，就是最优的。</p>
<p>也就是说当目标函数中的系数也就是检验数都小于等于0时，就是最优解，这里包括两种情况：</p>
<ul>
<li>检验数为0 ： 是最优解，但并不是唯一的最优解，表示存在无数个最优解</li>
<li>检验数为1：是唯一的最优解</li>
</ul></li>
<li><p>如何转到下一个基本可行解</p>
<p>回到我们的目标函数：</p>
<p><span class="math display">\[Z = 2x_1 + 3 x_2\]</span></p>
<p>从这个目标函数中我们可以看出，<span class="math inline">\(x_2\)</span>对目标函数的贡献比<span class="math inline">\(x_1\)</span>大。要让<span class="math inline">\(x_2\)</span>的取值从0变成正值，所以<span class="math inline">\(x_2\)</span>从非基变量转为基变量，称作<strong>进基变量</strong>。</p>
<p>这里就有一个问题，有一个变量从非基变量变成基变量，就意味着会有一个基变量变成非基变量，这个变成非基变量的变量叫做<strong>离基变量</strong>。</p>
<p><strong>离基变量的选择：</strong></p>
<p>这里我们需要回到用非基变量表示基变量的那一步：</p>
<p><span class="math display">\[ x_3 = 8 - x_1 - 2x_2\]</span></p>
<p><span class="math display">\[ x_4 = 16 - 4x_1\]</span></p>
<p><span class="math display">\[x_5 = 12 - 4x_2\]</span></p>
<p>那么在挑选离基变量的时候，我们将收敛的最快的（当进基变量增大时，最先到0的）拿出去。</p>
<p>按照这个方法，我们新的基变量是<span class="math inline">\((x_2,x_3,x_4)\)</span>，非基变量是：<span class="math inline">\((x_1,x_5)\)</span></p>
<p>然后再回到第一步开始检验，直到得到最优解为止。</p></li>
</ol>
<h2 id="单纯形表">单纯形表</h2>
<h3 id="单纯形表的构建">单纯形表的构建</h3>
<figure>
<img src="https://img-blog.csdnimg.cn/20200402192511691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>这里我们不再关注怎么加松弛变量之类的问题了</p>
<p><img src="https://img-blog.csdnimg.cn/20200402192518476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 单纯形表中：</p>
<ul>
<li><p><span class="math inline">\(X_B\)</span>：表示当前的基变量，初始挑选单位阵为初始基，构成向量B</p></li>
<li><p><span class="math inline">\(C_B\)</span>：代表当前基变量在目标函数中的系数向量</p></li>
<li><p><span class="math inline">\(b_j\)</span>：代表约束条件的右端的b值</p></li>
<li><p><span class="math inline">\(c_j\)</span>：代表目标函数的系数，在这里<span class="math display">\[c= （3，4，0，0）\]</span></p></li>
<li><p><span class="math inline">\(x_1,x_2...\)</span>下面的数字：约束条件的系数矩阵</p></li>
<li><p><span class="math inline">\(\sigma_j\)</span>：检验数，<span class="math display">\[\sigma_j = c_j-\Sigma c_ia_{ij}\]</span> ，这里的<span class="math inline">\(a_{ij}\)</span>是系数矩阵</p>
<p>以<span class="math inline">\(\sigma_1\)</span>为例，<span class="math inline">\(\sigma_1 = 3-( 2*0+1*0)=3\)</span></p></li>
</ul>
<h3 id="找到入基变量">找到入基变量</h3>
<p>方法：找检验数最大的，再上一张表里面，<span class="math inline">\(x_2\)</span>的检验数最大，所以将作为入基变量</p>
<h3 id="找到出基变量">找到出基变量</h3>
<p>方法：找<span class="math inline">\(\theta\)</span>，我们顺着上面来，我们现在确定了<span class="math inline">\(x_2\)</span>就是所谓的入基变量，下面，开始计算：</p>
<p><span class="math display">\[ \theta =  \frac{b_j}{x_2}  \]</span></p>
<p>在上面的表中，<span class="math display">\[\theta_3= 40,\theta_4 = 10 \]</span></p>
<p>值得注意的是：当<span class="math inline">\(x_2\)</span>的值为负值的时候，就不需要求<span class="math inline">\(\theta\)</span>了。</p>
<p>到此为止，谁的<span class="math inline">\(\theta\)</span>值越小就选谁当出基变量</p>
<h3 id="总体操作">总体操作</h3>
<p>找到入基变量，出基变量之后，列一张新的单纯形表，并且以此往复即可。当所有非基变量都为负数或零时停止，这时最优解就是：基变量取得到的值，非基变量取0.</p>
]]></content>
      <categories>
        <category>最优化技术</category>
      </categories>
      <tags>
        <tag>最优化技术</tag>
        <tag>大二下</tag>
        <tag>课内学习</tag>
      </tags>
  </entry>
  <entry>
    <title>组成原理第二章续</title>
    <url>/2020/04/03/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%BB%AD/</url>
    <content><![CDATA[<h1 id="组成原理第二章续">组成原理——第二章续</h1>
<h2 id="栈的补充">栈的补充</h2>
<p>栈在程序的运行过程中起着非常重要的作用。 <img src="https://img-blog.csdnimg.cn/20200402192704877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>为了管理栈，我们设置了两个指针：$sp, $fp。$sp记录的是栈最低的部分的地址，$fp记录的是栈最高的部分的地址。在函数执行过程中所需保存的局部变量、参数、返回地址调用的过程叫做过程帧。引入$fp可以达到快速恢复栈的目的，避免了内存泄露的问题。</p>
<p>程序的执行体所占有的内存区域可以分为四大类：</p>
<ul>
<li><strong>text-代码段</strong>：用来<strong>存放指令</strong></li>
<li><strong>Static data</strong>：静态数据</li>
<li><strong>Dynamic data-动态数据</strong>：内部使用的堆，C的malloc()，C++和java的 new 都在堆中。</li>
<li><strong>Stack-栈：</strong>存储局部变量</li>
</ul>
<p>通常来说，堆和栈共享一个内存区域，这样可以最大限度地利用内存空间。</p>
<h2 id="字符数据-character-data">字符数据-Character Data</h2>
<h3 id="字符编码">字符编码：</h3>
<ul>
<li>ASCII码：现在已经很少使用，一共可以表示128个字符</li>
</ul>
<figure>
<img src="https://img-blog.csdnimg.cn/20200402192710902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<ul>
<li>Latin-1: 256个字符，这个是对ASCII码的拓展</li>
<li>Unicode：三十二位字符集，可以用于表示中文</li>
<li>UTF-8, UTF-16, 以及一些变长的编码</li>
</ul>
<p>为了处理这些不同的编码，MIPS准备了以下指令：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200402192716366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>完成字符串的复制功能：</p>
<p>以C的代码为例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> x[], <span class="keyword">char</span> y[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((x[i]=y[i])!=<span class="string">'\0'</span>) i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设这里传进来的变量是$a0 - x[] 和 $a1 - y[]，i是$s0</p>
<p>那么我们可以有下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">srrcpy:</span><br><span class="line">addi $sp, $sp, -4 # 压栈，压一个元素</span><br><span class="line">sw   $s0, 0($sp) # 保存s0， 这里相当于是新开一个局部变量， 把原来这个局部变量存的东西存到内存里。</span><br><span class="line">add  $s0, $zero, $zero # 给出 s0初始值，  &#x3D; 0</span><br><span class="line">L1:</span><br><span class="line">add $t1, $s0, $a1 # $t1 代表 $y[i] 的地址</span><br><span class="line">lbu $t2, 0($t1) # t2 &#x3D; y[i], 这里是一次读一个字节，当作无符号数的方法</span><br><span class="line">add $t3, $s0, $a0 # t3 &#x3D; x[i]</span><br><span class="line">sb  $t2, 0($t3) # y[i] &#x3D; x[i]</span><br><span class="line">beq $t2, $zero, L2 # if (t2 &#x3D;&#x3D; &#39;\0&#39;) goto L2</span><br><span class="line">addi $s0, $s0, 1 # else s0 ++; continue;</span><br><span class="line">j   L1</span><br><span class="line">L2:</span><br><span class="line">lw  $s0, 0($sp) # 恢复原来的临时变量</span><br><span class="line">addi $sp, $sp, 4 # 恢复栈区</span><br><span class="line">jr $ra # 返回了</span><br></pre></td></tr></table></figure>
<h2 id="三十二位常数-32-bit-constants">三十二位常数 32-bit Constants</h2>
<p>结合我们前面学的知识，我们知道，32位mips中，一条语句的长度是32位，这就代表我们无法在一条语句中将一个三十二位数字赋给一个寄存器，mips为我们提供了一种方法，下面看两个语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lui $s0, constant</span><br><span class="line">ori $s0, $s0, constant</span><br></pre></td></tr></table></figure>
<p>其中lui代表着将constant数字赋给$s0的高16位，并将$s0的低16位清零。</p>
<p>ori是异或指令，我们都知道0异或x = x ，那么异或指令也可以用做赋值，所以我们在这里可以用ori来达到使用立即数给寄存器低16位赋值的效果。</p>
<p>看不懂可以再结合下面的图看一下。 <img src="https://img-blog.csdnimg.cn/20200402192723783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<h2 id="分支的地址">分支的地址</h2>
<p>以beq语句为例</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200402192729479.png" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>可以看到跳转的地址长度只有十六位，那是不是就表明我们程序的长度仅能在<span class="math inline">\(2^{16}\)</span>以内呢？</p>
<p>并不，其实跳转的地址是<span class="math display">\[Target\_address=PC + offset *4\]</span>，这样可以在这个指令前后<span class="math inline">\(2^{16}\)</span>之内进行转移如果还不够用呢？回想一下还有一个更短的语句，叫做<span class="math inline">\(j\)</span>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200402192733998.png" alt="在这里插入图片描述" /> 但是值得注意的是，使用该语句到达的地址也并非address中的地址，而是由PC的高四位和address*4拼接而成的，也就是说：<span class="math display">\[Target\_address = [PC_{31},PC_{30},PC_{29},PC_{28},address_{26}...address_{1},address_{0},0,0]\]</span></p>
<p>编译器可以将跳转的过远的条件转移语句，拆分成条件转移语句和直接转移语句的组合来达到远距离转移的目的。如果还要远，那么可以参考函数跳转的方法，直接使用<span class="math inline">\(jr , ra\)</span>直接将转移的寄存器的地址赋给$pc，这样就可以实现任意转移，可以实现在<span class="math inline">\(2^{32}\)</span>次方的范围内进行转移。但是一般情况下代码不会超过<span class="math inline">\(2^{28}\)</span>。</p>
<h2 id="寻址模式">寻址模式</h2>
<h4 id="数据寻址">数据寻址</h4>
<ol type="1">
<li>立即数寻址：操作数放在指令里面。</li>
<li>寄存器寻址：根据寄存器编号寻址</li>
<li>基址寻址：根据初始地址和偏移量进行寻址</li>
</ol>
<h4 id="指令寻址">指令寻址</h4>
<ol type="1">
<li>相对PC寻址：PC+偏移地址</li>
<li>无条件跳转：PC高四位和address左移两位拼接</li>
<li>直接赋值跳转：使用jar，直接改变pc进行跳转</li>
</ol>
<h2 id="多进程调度同步机制">多进程调度同步机制</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ll rt, offset(rs)</span><br><span class="line">sc rt, offset(rs)</span><br></pre></td></tr></table></figure>
<p>这俩看视频实在是看不懂，我这里参考了这篇博文:<a href="https://blog.csdn.net/gzxhjwddf/article/details/70098521?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">理解MIPS指令集中的ll (load linked) 和 sc (store conditional)指令</a></p>
<p>ll和sc指令是一种在多处理器系统中实现共享内存的原子操作的方法，且不需要为了让一个处理器独占它而锁定它。</p>
<p>意思是，你用ll指令读取一个内存中的数据并存到一个寄存器，然后在寄存器修改（或不）这个值，随后用sc指令将它写入到同样的（原来的）位置。而sc指令只在<strong>你修改寄存器中的值的期间，没有任何一个处理器改变它内存中的值</strong> 这种情况下，将值写入。它同时需要（的副作用是）设置一个指示状态的变量来表明是否成功写入。（成功为1，失败为0）</p>
<p>当新的值成功地被写入了，那么可以认为这个线程在没有别的线程干涉的情况下完成了（一个值的）读-改-写过程。如果失败了，接下来就取决于程序是要放弃这个操作还是再试一次了，不过至少它（ll&amp;sc）不会生成一个隐性的（不被察觉的）竞争危害。</p>
<p>基于这两条指令的swap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">add $t0, $zero, $s4 # t0 &#x3D; s4</span><br><span class="line">ll  $t0, 0($s1)  </span><br><span class="line">sc  $t0, 0($s1)</span><br><span class="line">beq $t0, $zero, try</span><br><span class="line">add $s4, $zero, $t1</span><br></pre></td></tr></table></figure>
<h2 id="高级语言的编译程序的启动机制">高级语言的编译、程序的启动机制</h2>
<h3 id="总体结构">总体结构</h3>
<figure>
<img src="https://img-blog.csdnimg.cn/20200402192745824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<h3 id="伪指令">伪指令</h3>
<p>查看下面的语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">move $t0, $t1</span><br><span class="line">blt $t0, $t1, L</span><br></pre></td></tr></table></figure>
<p>实际上在mips 指令集中是没有上面的语句的，为了解决这一问题，我们使用了伪指令，也就是说，当遇到这样的伪指令时，将它转化成对应的mips指令，如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add $t0, $zero, $t1</span><br><span class="line"></span><br><span class="line">slt $at, $t0, $t1</span><br><span class="line">bne $at, $zero, L</span><br></pre></td></tr></table></figure>
<p>这里的$at是一个专门给汇编器预留的临时变量。</p>
<p>中是没有上面的语句的，为了解决这一问题，我们使用了伪指令，也就是说，当遇到这样的伪指令时，将它转化成对应的mips指令，如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add $t0, $zero, $t1</span><br><span class="line"></span><br><span class="line">slt $at, $t0, $t1</span><br><span class="line">bne $at, $zero, L</span><br></pre></td></tr></table></figure>
<p>这里的$at是一个专门给汇编器预留的临时变量。</p>
]]></content>
      <categories>
        <category>组成原理</category>
      </categories>
      <tags>
        <tag>大二下</tag>
        <tag>课内学习</tag>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>博客后续插件的集成</title>
    <url>/2020/03/30/%E5%8D%9A%E5%AE%A2%E5%90%8E%E7%BB%AD%E6%8F%92%E4%BB%B6%E7%9A%84%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h1 id="向hexonext博客中添加搜索访问统计等功能">向hexo+next博客中添加搜索、访问统计等功能</h1>
<h2 id="添加搜索功能">添加搜索功能</h2>
<p>进入博客所在文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/blog</span><br><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>修改blog文件夹下的_config.yml文件，在最底部添加配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>完成后，编辑themes/next下的配置文件，更改local_search属性下的enable为true：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim themes/next/</span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="添加不蒜子统计">添加不蒜子统计</h2>
<p>为了知道我们博客的阅读量和某篇文章的阅读量，我们使用不蒜子进行统计。</p>
<p>打开themes/next文件夹下的配置文件进行配置，更改busuanzi_count一栏，更改为：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"> <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line"> <span class="attr">total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line"> <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line"> <span class="attr">total_views_icon:</span> <span class="string">eye</span></span><br><span class="line"> <span class="attr">post_views:</span> <span class="literal">true</span></span><br><span class="line"> <span class="attr">post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure>
<p>保存退出，因为不蒜子的域名发生了变化，所以我们需要在这里进行一定的更改。</p>
<p>我们需要编辑next/layout/_third-party/analytics/busuanzi-counter.swig</p>
<p>打开它，将里面的url链接更改为https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js</p>
<h2 id="数学公式">数学公式</h2>
<p>编辑 主题配置文件，将 <code>mathjax</code> 下的 <code>enable</code> 设定为 <code>true</code> 即可。 <code>cdn</code> 用于指定 MathJax 的脚本地址，默认是 MathJax 官方提供的 CDN 地址。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure>
<p>如果改变后无效的话请参考<a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">这篇文档</a></p>
<h2 id="加入线条">加入线条</h2>
更改next/layout/_layout.swig文件，在
</body>
<p>之前加入一行代码，如下方所示</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>组成原理第二章</title>
    <url>/2020/03/29/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="计算机指令">计算机指令</h1>
<h2 id="算术运算指令">算术运算指令</h2>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add </span>a, <span class="keyword">b, </span>c<span class="comment"># a = b + c</span></span><br></pre></td></tr></table></figure>
<p><strong>设计原则一——对指令进行规整化设置</strong></p>
<ul>
<li>简化实现</li>
<li>获得更高的性能，更低的成本</li>
</ul>
<p>代码示例</p>
<ul>
<li>C语言代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">f = (g + h) - (i + j)</span><br></pre></td></tr></table></figure>
<ul>
<li>MIPS</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add </span><span class="built_in">t0</span>, g, h <span class="comment"># temp : t0 = g + h</span></span><br><span class="line"><span class="keyword">add </span><span class="built_in">t1</span>, i, <span class="keyword">j </span><span class="comment"># temp : t1 = i + j</span></span><br><span class="line"><span class="keyword">sub </span>f, <span class="built_in">t0</span>, <span class="built_in">t1</span> <span class="comment">#final: f  = t0 - t1</span></span><br></pre></td></tr></table></figure>
<p>参与算术逻辑运算的变量必须是<strong>寄存器变量</strong>，对于MIPS(x 32)指令集来说，有32个寄存器，每个寄存器长<span class="math display">\[32bit\]</span>，它们：</p>
<ul>
<li>用于存储最常用到的变量</li>
<li>每个寄存器的编号为0~31</li>
<li>每个寄存器中32位数据称作一个<strong>字</strong></li>
</ul>
<p>约定符号：</p>
<ul>
<li>$t0,$t1,...,$t9 用于表示临时变量</li>
<li>$s0,$s1,...,$s 7表示需要保存的变量</li>
</ul>
<p>设计原则二——<strong>更小就会更快</strong></p>
<ul>
<li>倾向于将算术运算放到寄存器中运行，以加快速度</li>
<li>内存的存储单元通常是百万级的</li>
</ul>
<p>前面的代码，根据<strong>约定符号进行矫正</strong>：</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add </span>$<span class="built_in">t0</span>, $<span class="built_in">s1</span>, $<span class="built_in">s2</span></span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">t1</span>, $<span class="built_in">s3</span>, $<span class="built_in">s4</span></span><br><span class="line"><span class="keyword">sub </span>$<span class="built_in">s0</span>, $<span class="built_in">t0</span>, $<span class="built_in">t1</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在<span class="math inline">\(MIPS32\)</span>指令集中，只有<span class="math inline">\(32*32\)</span>个存储空间，这并不足以支持所有运算，所以很多的数据是存储在<strong>内存</strong>中的，我们将这些被储存在内存中的数据称为_<strong>Memory Operands</strong>。内存的操作数是用来保存复杂的操作数，这是由寄存器的空间过小导致的。</p>
<p>算数逻辑运算不能直接对内存中的数据进行运算，这就需要我们先<strong>从内存中读取(load)数据</strong>,然后<strong>再进行处理</strong>，最终再将操作的<strong>结果写入(write)内存</strong>。在对内存的操作中，都是通过字节寻址的(每八位分配一个地址)。值得注意的是，每个字节由<span class="math inline">\(8bit\)</span>组成，而寄存器中每一位长度是<span class="math inline">\(32bit\)</span>，这就表明，我们在知道首地址的情况下，想要寻找第<span class="math inline">\(i\)</span>个元素时，需要将偏移量<span class="math inline">\(*4\)</span>。</p>
<p>MIPS中数据的对齐方式是：<strong>大端对齐</strong>。什么是大端对齐呢？</p>
<ul>
<li>存储一个数据，需要四个字节，这也就对应着内存上的四个存储单元。</li>
<li>这四个存储单元有他们相应的标号</li>
<li>高内存地址放整数的低位，低内存地址放整数的高位，这种方式叫正着放，术语叫大端对齐</li>
<li>与大端对齐相反的是小端对齐，说白了就是反着存</li>
</ul>
<p><strong>Memory Operand 小例子</strong></p>
<p><strong>C code</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g = h + A[<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>其中，$s1 is g,$s2 is h,$s3 is the base address of A</p>
<p><strong>MIPS code</strong></p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lw </span> $<span class="built_in">t0</span>, <span class="number">32</span>($<span class="built_in">s3</span>) <span class="comment"># 读取A[8]，32来源于偏移量*4 = 8*4 = 32</span></span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">s1</span>, $<span class="built_in">s2</span>, $<span class="built_in">t0</span></span><br></pre></td></tr></table></figure>
<p><strong>Memory Operand 小例子2</strong></p>
<p><strong>C code</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A[<span class="number">12</span>] = h + A[<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>其中，$s2 is h,$s3 is the base address of A</p>
<p><strong>MIPS code</strong></p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lw </span> $<span class="built_in">t0</span>, <span class="number">32</span>($<span class="built_in">s3</span>)</span><br><span class="line"><span class="keyword">add </span>$<span class="built_in">t0</span>, $<span class="built_in">s2</span>, $<span class="built_in">t0</span></span><br><span class="line"><span class="keyword">sw </span> $<span class="built_in">t0</span>, <span class="number">48</span>($<span class="built_in">s3</span>)<span class="comment">#写入</span></span><br></pre></td></tr></table></figure>
<p>可以看出，寄存器和内存的交互主要通过<span class="math inline">\(lw\)</span> ,<span class="math inline">\(sw\)</span>两条语句，进行数据的读取、写入，对于编译器而言，选择哪些变量放到寄存器中，哪些放到内存中，是非常关键的问题，同时也是非常困难的问题。</p>
<h2 id="立即数">立即数</h2>
<p>所谓<strong>立即数</strong>，即所使用的变量是一个常数，他是包含在指令中的。如:</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">addi </span>$<span class="built_in">s3</span>, $<span class="built_in">s3</span>, <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这就相当于C语言中的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s3 += <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>立即数操作中没有减法，因为减掉一个数就相当于加上这个数的相反数，即：</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">addi </span>$<span class="built_in">s3</span>, $<span class="built_in">s3</span>, -<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>就可以完成C语言中如下功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s3 -= <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p><strong>支持的数字范围：</strong>立即数操作的常亮仅支持有符号的16位整数，即：<span class="math inline">\(\left[ -32768, 32767\right]\)</span>这个区间。如果需要一个32位整数，那么这个整数就只能被先放到内存中，然后再被寄存器读取。</p>
<p>这里就引出了第三个设计原则：<strong>加快高概率事件(Make the Common Case Fast)</strong></p>
<ul>
<li><p>小的常数是常用的</p></li>
<li><p>使用常用的数，不需要从内存中读取</p>
<h3 id="数字的类型">数字的类型</h3></li>
<li><p>无符号整数(unsigned int)</p>
<ul>
<li>用于表示地址</li>
<li>或是非负数</li>
</ul></li>
<li><p>有符号整数</p>
<ul>
<li>正负数</li>
</ul></li>
<li><p>浮点数</p>
<ul>
<li>单精度浮点数(float)</li>
<li>双精度浮点数(double)</li>
</ul></li>
</ul>
<p><strong>有符号数的表示</strong></p>
<ul>
<li>补码</li>
<li>源码</li>
</ul>
<p>补码和源码之间有+0和-0的区别。</p>
<p><strong>MIPS中特殊的取值——0</strong></p>
<p>MIPS中0号寄存器永远为0，只能读取，不能写入。我们常用$zero来代表上述的零号计算器，利用这个寄存器，我们可以进行下面的操作：</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add </span> $<span class="built_in">t2</span>, $<span class="built_in">s1</span>, $<span class="built_in">zero</span></span><br><span class="line"><span class="keyword">addi </span>$<span class="built_in">t2</span>, $<span class="built_in">zero</span>, <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>事实上，MIPS中是没有初始化的方法的，在上面的代码中，我们用$s1的值初始化了$t2，然后将100赋值给$t2，这种语法的设计减少了很多冗余的语句。</p>
<h2 id="有符号数和无符号数的表示">有符号数和无符号数的表示</h2>
<p><strong>无符号二进制数计算公式</strong>: <span class="math display">\[  x = \Sigma \left( x_i 2^i\right) \]</span> 这个老掉牙了，没啥好说的，一个长度为n的无符号二进制数，能表示<span class="math inline">\(\left[0,2^n-1\right]\)</span>这个区间内的整数。</p>
<p><strong>有符号数的表示</strong>：</p>
<ul>
<li><strong>源码的表示：最高为作为符号位</strong>
<ul>
<li><strong>0代表符号为正</strong></li>
<li><strong>1代表符号为负</strong></li>
</ul></li>
<li>源码表示存在的问题：<strong>同时存在正0和负0</strong></li>
</ul>
<p><strong>补码的表示</strong>：这一部分我之前看的时候基本上都是硬背的，现在听到这种讲法才恍然大悟（菜是原罪）</p>
<p>假设补码表示的二进制数有n位，标号为<span class="math inline">\(0 ,n-1\)</span>，那么补码到十进制数的计算公式为： <span class="math display">\[ x = -x_{n-1}*2^{n-1} + \Sigma_{i=0}^{n-2} \left(x_{i}*2^{i}\right) \]</span> 它对应的取值范围是:<span class="math inline">\(\left[ -2^{n-1},+2^{n-1}-1\right]\)</span></p>
<p>在整数运算中，大多数情况下，使用的是补码的形式。下面有一些特殊的补码数字（帮助理解用的，不用想哪里特殊）:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">十进制</th>
<th style="text-align: center;">二进制</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">0000 0000 ... 0000</td>
</tr>
<tr class="even">
<td style="text-align: center;">-1</td>
<td style="text-align: center;">1111 1111 ... 1111</td>
</tr>
<tr class="odd">
<td style="text-align: center;">最小的数</td>
<td style="text-align: center;">1000 0000 ... 0000</td>
</tr>
<tr class="even">
<td style="text-align: center;">最大的数</td>
<td style="text-align: center;">0111 1111 ... 1111</td>
</tr>
</tbody>
</table>
<p>一般情况下，MIPS指令集下的运算都是对有符号数进行运算，除非你显式的告诉计算机要进行无符号数运算，需使用addu操作。</p>
<p>常见操作：</p>
<ul>
<li>将数字取反：<strong>将数字的每一位取反，再对最后一位加1</strong>。
<ul>
<li>优点：可以用已有的加法电路，做简单的拓展即可作为减法电路使用。</li>
</ul></li>
<li><strong>符号位扩展</strong>：
<ul>
<li>应用场景：如:使用<span class="math inline">\(addi\)</span>指令时，得到的是一个16位数字，要将该数字拓展为32位数字，才可以与其他数字进行算术运算。</li>
<li><strong>无符号数的拓展方法</strong>：
<ul>
<li>直接补零</li>
</ul></li>
<li><strong>有符号数的拓展方法</strong>：
<ul>
<li><strong>正数</strong>：在数字前方<strong>补0</strong></li>
<li><strong>负数</strong>：在数字前方<strong>补1</strong></li>
</ul></li>
</ul></li>
</ul>
<h2 id="指令的表示">指令的表示</h2>
<p>还记得我们第一章的时候讲过，汇编语言多数时间执行着<strong>将高级语言翻译成机器语言(machine code)</strong> 工作。下面是一些寄存器名称和用途的的对应表： <img src="https://img-blog.csdnimg.cn/20200329231009644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 其中，1号寄存器被称为$at，它是为汇编程序预留的；26-27号寄存器被称为$k0,$k1，他们是保留给操作系统的。</p>
<p>指令集分为六大类：</p>
<ul>
<li>算数逻辑运算</li>
<li>内存访问</li>
<li>分支和跳转指令</li>
<li>浮点运算指令 --使用协处理器完成</li>
<li>内存管理指令</li>
<li>特殊指令</li>
</ul>
<p>0-31号寄存器是我们（程序员）能够访问的到的寄存器，还有我们访问不到的寄存器：</p>
<ul>
<li>PC：用于存放当前程序正在执行的指令</li>
<li>HI &amp; LO：在乘除法运算时做临时储存</li>
</ul>
<h3 id="mips32中指令集架构的格式">mips32中指令集架构的格式</h3>
<p><img src="https://img-blog.csdnimg.cn/20200329231053563.png" alt="在这里插入图片描述" /> #### R format</p>
<p>主要用途：用于表示<strong>算数逻辑运算</strong>，分为：</p>
<p>他们分别代表：</p>
<ul>
<li><strong>op</strong>：<span class="math inline">\(operation\ code\)</span>用于表示当前的操作类型</li>
<li><strong>rs,rt</strong>：表示用于运算的两个源操作数，对应寄存器的编号</li>
<li><strong>rd</strong>：目标操作数，对应寄存器的编号</li>
<li><strong>shamt</strong>：针对移位运算，记录移位的次数</li>
<li><strong>funct</strong>：是opCode的拓展</li>
</ul>
<p>例子：</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add </span>$<span class="built_in">t0</span>, $<span class="built_in">s1</span>, $<span class="built_in">s2</span></span><br></pre></td></tr></table></figure>
<p>对应的指令为：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">special</th>
<th style="text-align: center;">$s1</th>
<th style="text-align: center;">$s2</th>
<th style="text-align: center;">$t0</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">add</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">17</td>
<td style="text-align: center;">18</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">32</td>
</tr>
<tr class="even">
<td style="text-align: center;">000000</td>
<td style="text-align: center;">10001</td>
<td style="text-align: center;">10010</td>
<td style="text-align: center;">01000</td>
<td style="text-align: center;">00000</td>
<td style="text-align: center;">100000</td>
</tr>
</tbody>
</table>
<h4 id="i-format">I format</h4>
<p><img src="https://img-blog.csdnimg.cn/20200329231114195.png" alt="在这里插入图片描述" /> I-format可以用于之前的<span class="math inline">\(addi\)</span>操作、<span class="math inline">\(load/store\)</span>或是条件跳转等指令。 其中</p>
<ul>
<li>rs/rt ：源操作或目标操作寄存器</li>
<li><span class="math inline">\(constant\ or\ address\)</span></li>
<li>在进行运算时：补码形式的二进制数</li>
<li>在进行寻址时：表示内存地址</li>
</ul>
<p>设计规则四——<strong><em>Good design demands good compromises</em></strong></p>
<p>这种设计方法看似折中、不利于译码，但将长度固定在了３２位，为了统一，增加了一部分译码的复杂性，达到了整体的统一，同时，这种设计方法，降低了后期电路设计的复杂性。</p>
<h4 id="j-format">J format</h4>
<p>后面再讲</p>
<h3 id="冯诺依曼计算机设计的两个关键特性">冯诺依曼计算机设计的两个关键特性</h3>
<h4 id="指令和数据都是二进制串无法区分">１．指令和数据都是二进制串，无法区分</h4>
<h4 id="程序时能够被改写的">２．程序时能够被改写的</h4>
<figure>
<img src="https://img-blog.csdnimg.cn/20200329231127317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>存储程序相关的基本概念：</p>
<ul>
<li><p><strong>程序可以被保存为二进制文件</strong>，这样的特性使得一个程序可以从一个电脑搬到另一个电脑上使用，这一个叫做“<strong><em>二进制的兼容性</em></strong>”（deepin-wine）</p></li>
<li><p>为了<strong>保证对已经编译好了的软件的继承</strong>，指令集架构应当围绕着少数几个大的指令集架构发展。</p>
<h2 id="逻辑运算指令">逻辑运算指令</h2>
<p>一些对应的语言： <img src="https://img-blog.csdnimg.cn/20200329231142538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<h3 id="移位运算shift-operations">移位运算(Shift Operations)</h3></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">special</th>
<th style="text-align: center;">rs</th>
<th style="text-align: center;">rt</th>
<th style="text-align: center;">rd</th>
<th style="text-align: center;">shamt</th>
<th style="text-align: center;">funct</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">6 bits</td>
<td style="text-align: center;">5 bits</td>
<td style="text-align: center;">5 bits</td>
<td style="text-align: center;">5 bits</td>
<td style="text-align: center;">5 bits</td>
<td style="text-align: center;">6 bits</td>
</tr>
</tbody>
</table>
<p>C语言中 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$s1 = $s2 &lt;&lt; <span class="number">10</span>;</span><br><span class="line">$s1 = $s2 &gt;&gt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure> 与MIPS中： <figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sll </span>$<span class="number">1</span>,$<span class="number">2</span>,<span class="number">10</span></span><br><span class="line"><span class="keyword">srl </span>$<span class="number">1</span>,$<span class="number">2</span>,<span class="number">10</span></span><br></pre></td></tr></table></figure> 相同 其中： shamt-用于记录移动多少位</p>
<ul>
<li><p>逻辑左移运算：</p>
<ul>
<li>左移，并将空出来的部分用零填充</li>
<li>左移<span class="math inline">\(i\)</span>位，相当于乘上<span class="math inline">\(2^i\)</span></li>
</ul></li>
<li><p>逻辑右移运算：</p>
<ul>
<li><p>右移，并将空出来的部分用零填充</p></li>
<li><p>右移<span class="math inline">\(i\)</span>位，相当于除以上<span class="math inline">\(2^i\)</span></p>
<h3 id="与或运算andor-operations">与、或运算(And/Or Operations)</h3>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and </span>$<span class="built_in">t0</span>, $<span class="built_in">t1</span>, $<span class="built_in">t2</span><span class="comment">#t0 = t1 and t2</span></span><br><span class="line"><span class="keyword">or </span>   $<span class="built_in">t0</span>, $<span class="built_in">t1</span>, $<span class="built_in">t2</span><span class="comment">#t0 = t1 or     t2</span></span><br></pre></td></tr></table></figure>
<p>将$t1 &amp; $t2的值赋给$t0，与运算可以运用在屏蔽寄存器中。</p></li>
</ul></li>
</ul>
<h3 id="nor运算">NOR运算</h3>
<p>NOR就是not，or，这是一个三目运算符，使用方法如下:</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nor </span>$<span class="built_in">t0</span>, $<span class="built_in">t1</span>, $<span class="built_in">t2</span></span><br></pre></td></tr></table></figure>
<p>这个运算表示<span class="math inline">\(not\ \left( t2\ or\ t1\right)\)</span> MIPS中没有单独的取反操作，如果想要对$t1取反存入到$t0中，方法如下：</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">nor </span>$<span class="built_in">t0</span>, $<span class="built_in">t1</span>, $<span class="built_in">zero</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，进行的是<span class="math inline">\(not\ \left( t1\ or\ zero\right)\)</span>的操作，其中，任何一个数和零进行或运算，还是他本身，再对它本身取反就可以得到<span class="math inline">\(not\ t1\)</span>的结果。</p>
<h2 id="条件指令分支与循环">条件指令（分支与循环）</h2>
<p>常见的控制指令：</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">beq </span>re, rt, L1</span><br><span class="line"><span class="keyword">bne </span>rs, rt, L1</span><br><span class="line"><span class="keyword">j </span>         L1</span><br></pre></td></tr></table></figure>
<p>他们对应的C语言语法是:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#beq re, rt, L1</span></span><br><span class="line"><span class="keyword">if</span>(re == rt)&#123;</span><br><span class="line">    <span class="keyword">goto</span> L1; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#bne rs, rt, L1</span></span><br><span class="line"><span class="keyword">if</span>(re != rt)&#123;</span><br><span class="line">    <span class="keyword">goto</span> L1; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#j          L1，无条件跳转</span></span><br><span class="line"><span class="keyword">goto</span> L1;</span><br></pre></td></tr></table></figure>
<p>跳转的目标指令，与当前的beq/bne之间，不能超过正负<span class="math inline">\(2^{15}\)</span>，同时，在写C和C++的时候除特殊情况外应当避免/减少goto语句的使用，因为使用goto语句不当可能会让程序表意不明，更加混乱。</p>
<h3 id="一个小例子选择结构">一个小例子（选择结构）</h3>
<p>老规矩，先看C/C++</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i==j)&#123;</span><br><span class="line">    f = g + h;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    f = g - h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的MIPS</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line">          <span class="comment">#s3 is i, s4 is j, s0 is f, s1 is g, s2 is h.</span></span><br><span class="line">          <span class="keyword">bne </span>$<span class="built_in">s3</span>, $<span class="built_in">s4</span>, Else<span class="comment">#判断i,j是否相等，若不等就直接跳过下面两行</span></span><br><span class="line">          <span class="keyword">add </span>$<span class="built_in">s0</span>, $<span class="built_in">s1</span>, $<span class="built_in">s2</span><span class="comment">#若相等，就继续执行到这一行，完成f=g+h</span></span><br><span class="line">          <span class="keyword">j </span>Exit<span class="comment">#执行完f = g - h之后跳过下一条语句直接退出</span></span><br><span class="line"><span class="symbol">Else:</span> <span class="keyword">sub </span>$<span class="built_in">s0</span>, $<span class="built_in">s1</span>, $<span class="built_in">s2</span><span class="comment">#执行f = g - h</span></span><br><span class="line"><span class="symbol">Exit:</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看出，MIPS的标记本身并没有改变代码的执行顺序，仅仅是对某行代码做了标记而已，如果没有<span class="math inline">\(j,bne,beq\)</span>三条语句的话，就算程序中有标记，MIPS还是会顺序执行的。</p>
<h3 id="第二个例子循环结构">第二个例子（循环结构）</h3>
<p>Ccode</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(save[i] == k) i += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>MIPS Code</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"> <span class="comment">#i is $s3, k is $s5, 地址被保存在$s6中</span></span><br><span class="line"><span class="symbol"> Loop:</span> <span class="keyword">sll </span>$<span class="built_in">t1</span>, $<span class="built_in">s3</span>, <span class="number">2</span> <span class="comment">#偏移量 = i * 4</span></span><br><span class="line">              <span class="keyword">add </span>$<span class="built_in">t1</span>, $<span class="built_in">t1</span>, $<span class="built_in">s6</span><span class="comment"># 当前地址= 起始地址 + 偏移量</span></span><br><span class="line">              <span class="keyword">lw </span>$<span class="built_in">t0</span>, <span class="number">0</span>($<span class="built_in">t1</span>)<span class="comment">#读取数据到t0</span></span><br><span class="line">              <span class="keyword">bne </span>$<span class="built_in">t0</span>, $<span class="built_in">s5</span>, Exit</span><br><span class="line">              <span class="keyword">addi </span>$<span class="built_in">s3</span>, $<span class="built_in">s3</span>, <span class="number">1</span><span class="comment"># s3 = s3 + 1</span></span><br><span class="line">              <span class="keyword">j </span> Loop</span><br><span class="line"><span class="symbol">Exit:</span></span><br></pre></td></tr></table></figure>
<p>没啥好讲的了，自行体会。</p>
<h3 id="更多条件指令">更多条件指令</h3>
<p>MIPS Code</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">slt </span>rd, rs, rt</span><br><span class="line"><span class="keyword">slti </span>rt, rs, constant</span><br></pre></td></tr></table></figure>
<p>C Code</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#slt rd, rs, rt</span></span><br><span class="line"><span class="keyword">if</span>(rs &lt; rt )&#123;</span><br><span class="line">    rd = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    rd = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#slti rt, rs, constant</span></span><br><span class="line"><span class="keyword">if</span>(re &lt; constant)&#123;</span><br><span class="line">    rd = <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    rd = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个语句可以和beq一起用，来进行在大于、小于等情况下的选择结构。</p>
<h3 id="小练习">小练习</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    j = j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上述代码转化成mips指令集中的code，i,j--&gt;$s1,$s2 我的答案：</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line">           <span class="keyword">slt </span>   $<span class="built_in">t0</span>, i, <span class="keyword">j </span><span class="comment"># if i&gt;=j 0</span></span><br><span class="line">           <span class="keyword">beq </span>$<span class="built_in">t0</span>, $<span class="built_in">zero</span>, Else <span class="comment">#if t0==zero --&gt; i&gt;=j goto Else:j=j+1,else go on</span></span><br><span class="line">           <span class="keyword">addi </span>$<span class="built_in">s1</span>, $<span class="built_in">s1</span>, <span class="number">1</span></span><br><span class="line">           <span class="keyword">j </span>        Exit</span><br><span class="line"><span class="symbol">Else:</span> <span class="keyword">addi </span>$<span class="built_in">s2</span>, $<span class="built_in">s2</span>, <span class="number">1</span></span><br><span class="line"><span class="symbol">Exit:</span> ...</span><br></pre></td></tr></table></figure>
<h3 id="有符号和无符号数字的比较">有符号和无符号数字的比较</h3>
<p>无符号数进行比较： sltu,sltui，其实说白了就是后面加个u就是无符号数操作，再加个i就是常数操作。</p>
<h2 id="函数的调用和函数的返回">函数的调用和函数的返回</h2>
<p><strong>基本块</strong>，是一个指令序列，在这个序列中是<strong>没有分支指令</strong>的，也<strong>没有其他分支指令的跳转指令</strong>。 <img src="https://img-blog.csdnimg.cn/20200329231201446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>函数调用的基本步骤：</p>
<ul>
<li>将函数相关的参数放入寄存器中(load 指令或者是逻辑运算指令)</li>
<li>将寄存器的控制权交给函数相关的进程。<strong>关键</strong></li>
<li>申请，并获得存储空间（堆栈）</li>
<li>执行函数中的指令</li>
<li>将返回的结果放回寄存器中<strong>关键</strong></li>
<li>将结果返回到调用的地址中</li>
</ul>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">jal </span>ProcedureLabel</span><br></pre></td></tr></table></figure>
<p>将寄存器控制权交给相关的进程： 将ProcedureLabel的下一个地址放到$ra中，然后跳转到目标地址。（这里$ra用于记录返回值返回到哪里）</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="keyword">jr </span>$<span class="built_in">ra</span></span><br></pre></td></tr></table></figure>
<p>将$ra复制到程序计数器中，这条语句也可以用于其他的跳转用途。</p>
<p>这段他讲的好抽象，我有点没听懂。 下面有一个实例。</p>
<h3 id="leaf-procedure-example不调用其它函数的函数">Leaf Procedure Example（不调用其它函数的函数）</h3>
<p>C Code</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">leaf_example</span><span class="params">(<span class="keyword">int</span> g, <span class="keyword">int</span> h, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> f;</span><br><span class="line">    f = (g + h) - (i + j);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我就直接贴最后的代码了：</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line">leaf_example：</span><br><span class="line">    <span class="keyword">addi </span>$<span class="built_in">sp</span>, $<span class="built_in">sp</span>, -<span class="number">4</span><span class="comment">#压栈，往下压四个字节</span></span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">s0</span>, <span class="number">0</span>($<span class="built_in">sp</span>)<span class="comment">#将s0放入压好的栈中</span></span><br><span class="line">    <span class="keyword">add </span>$<span class="built_in">t0</span>, $<span class="built_in">a0</span>, $<span class="built_in">a1</span></span><br><span class="line">    <span class="keyword">add </span>$<span class="built_in">t1</span>, $<span class="built_in">a2</span>, $<span class="built_in">a3</span></span><br><span class="line">    <span class="keyword">sub </span>$<span class="built_in">s0</span>, $<span class="built_in">t0</span>, $<span class="built_in">t1</span></span><br><span class="line">    <span class="keyword">add </span>$<span class="built_in">v0</span>, $<span class="built_in">s0</span>, $<span class="built_in">zero</span><span class="comment">#将结果放入用于返回的参数$v0中</span></span><br><span class="line">    <span class="keyword">lw </span>$<span class="built_in">s0</span>, <span class="number">0</span>($<span class="built_in">sp</span>)<span class="comment">#恢复$s0</span></span><br><span class="line">    <span class="keyword">addi </span>$<span class="built_in">sp</span>, $<span class="built_in">sp</span>, <span class="number">4</span><span class="comment">#恢复堆栈位置</span></span><br><span class="line">    <span class="keyword">jr </span>$<span class="built_in">ra</span><span class="comment">#返回</span></span><br></pre></td></tr></table></figure>
<p>说实话，除了jr都看懂了，那个确实没看懂。</p>
<h2 id="none-leaf-procedures函数的嵌套调用">None-Leaf Procedures（函数的嵌套调用）</h2>
<p>调用者需要将一些信息存储到堆栈中：</p>
<ul>
<li>被使用的寄存器($s0-$s7)</li>
<li>他的返回地址</li>
<li>在函数、过程中用到的临时变量 在返回之前，将堆栈中数据取出进行恢复。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">return</span> n*fact(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的mips,参数n放到$a0中，结果放到$v0</p>
<figure class="highlight mips"><table><tr><td class="code"><pre><span class="line"><span class="symbol">fact:</span></span><br><span class="line">    <span class="keyword">addi </span>$<span class="built_in">sp</span>, $<span class="built_in">sp</span>, -<span class="number">8</span></span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">ra</span>, <span class="number">4</span>($<span class="built_in">sp</span>)</span><br><span class="line">    <span class="keyword">sw </span>$<span class="built_in">a0</span>, <span class="number">0</span>($<span class="built_in">sp</span>)</span><br><span class="line">    <span class="keyword">slti </span>$<span class="built_in">t0</span>, $<span class="built_in">a0</span>, <span class="number">1</span><span class="comment">#判断是否小于1</span></span><br><span class="line">    <span class="keyword">beq </span>$<span class="built_in">t0</span>, $<span class="built_in">zero</span>, L1<span class="comment">#如果大于等于1，那么跳到后面去</span></span><br><span class="line">    <span class="keyword">addi </span>$<span class="built_in">v0</span>, $<span class="built_in">zero</span>, <span class="number">1</span><span class="comment">#如果小于1，那么将1付给v0</span></span><br><span class="line">    <span class="keyword">addi </span>$<span class="built_in">sp</span>, $<span class="built_in">sp</span>, <span class="number">8</span><span class="comment">#从栈空间中出栈两个</span></span><br><span class="line">    <span class="keyword">jr </span>$<span class="built_in">ra</span><span class="comment">#返回</span></span><br><span class="line"><span class="symbol">L1:</span></span><br><span class="line">    <span class="keyword">addi </span>$<span class="built_in">a0</span>, $<span class="built_in">a0</span>, -<span class="number">1</span><span class="comment">#减一</span></span><br><span class="line">    <span class="keyword">jal </span>fact<span class="comment"># 从新跳转到fact部分去执行</span></span><br><span class="line">    <span class="keyword">lw </span>$<span class="built_in">a0</span>, <span class="number">0</span>($<span class="built_in">sp</span>)<span class="comment">#将堆栈中把两个参数取出</span></span><br><span class="line">    <span class="keyword">lw </span>$<span class="built_in">ra</span>, <span class="number">4</span>($<span class="built_in">sp</span>)</span><br><span class="line">    <span class="keyword">addi </span>$<span class="built_in">sp</span>, $<span class="built_in">sp</span>, <span class="number">8</span><span class="comment">#恢复堆栈</span></span><br><span class="line">    <span class="keyword">mul </span>$<span class="built_in">v0</span>, $<span class="built_in">a0</span>, $<span class="built_in">v0</span><span class="comment">#相乘</span></span><br><span class="line">    <span class="keyword">jr </span>$<span class="built_in">ra</span><span class="comment">#返回</span></span><br></pre></td></tr></table></figure>
<h2 id="栈上的变量">栈上的变量</h2>
<p><img src="https://img-blog.csdnimg.cn/20200329231237290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /> 堆栈用于存储临时变量。 图中$sp指向堆栈可用地址，申请栈的时候，向下申请。$fp的存在使得便于恢复栈。</p>
<p>内存中一个程序分为不同的段：</p>
<ul>
<li><strong>代码段</strong>：用于存放指令</li>
<li><strong>静态数据</strong>：执行过程中不会变的数据</li>
<li><strong>堆</strong>：C语言中new出来的东东，需要手动释放</li>
<li><strong>栈</strong>：临时变量</li>
</ul>
<p>思考：</p>
<ul>
<li>递归能否转循环
<ul>
<li>答案是可以的，就直接模拟它的栈</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>组成原理</category>
      </categories>
      <tags>
        <tag>大二下</tag>
        <tag>课内学习</tag>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下Hexo+NexT博客搭建</title>
    <url>/2020/03/29/Ubuntu%E4%B8%8BHexo-NexT%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="ubuntu下使用hexogithubnext搭建个人博客">Ubuntu下使用Hexo+GitHub+nexT搭建个人博客</h1>
<h2 id="一下载nodejs和npm">一、下载nodejs和npm</h2>
<p>打开 <a href="http://nodejs.cn/" target="_blank" rel="noopener">Node.js</a>官网，下载源代码，解压后进行编译、安装。</p>
<p>解压后进入文件夹，输入:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make -j 12#使用12线程编译，可以视情况而定</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>至此为止Node.js, npm下载完成，输入语句</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p>检验是否安装成功。</p>
<h2 id="二下载hexo并在本地搭建博客">二、下载Hexo并在本地搭建博客</h2>
<p>先安装Hexo</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo -g</span><br></pre></td></tr></table></figure>
<p>使用下方语句检验是否安装成功:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<p>出现版本信息就说明安装成功了。接下来使用hexo对博客进行初始化和本地布置，输入语句，在这个过程中出现任何问题，都可以将这个博客文件夹干掉重来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo hexo init blog  # blog可以替换成你喜欢的名字，该操作可以在任何文件夹下进行</span><br><span class="line">cd blog</span><br><span class="line">sudo npm install </span><br><span class="line">sudo hexo clean</span><br><span class="line">sudo hexo g</span><br><span class="line">sudo hexo d</span><br></pre></td></tr></table></figure>
<p>操作完成后会出现如下信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO  Deploy done: git</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure>
<p>这时候我们将上面的网址复制到浏览器中，进入即可，进入后可以看到如下画面： <img src="https://img-blog.csdnimg.cn/20200329213651340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>至此，hexo本地部署完成</p>
<h2 id="三-将hexo博客push到github">三、 将Hexo博客Push到GitHub</h2>
<p>进入GitHub，如果没有账号，那么自行注册。</p>
<p>进入个人主页，新建一个仓库，仓库的名字是且必须是：</p>
<blockquote>
<h3 id="xxxxxx.github.io">xxxxxx.github.io</h3>
</blockquote>
<p>以我为例，我的账号是wang-sy，在这里我填写的是wang-sy.github.io，以后我们也将通过这个网址来访问我们的博客。</p>
<p>进入我们之前创建的blog文件夹，对_config.yml进行编辑，修改最后面的内容，修改为:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/wang-sy/wang-sy.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>修改完成后保存，我们将初始化的博客部署到github中，在控制台中输入如下代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blog#进入你定义的博客文件夹</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>
<p>等待一段时间后，在浏览器中输入，你自己的xxx.github.io，即可查看博客，如下：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/2020032921370616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>值得注意的是，<strong>将内容push到GitHub后需要等待一段时间后，你的改动才能有效</strong>。所以说如果到了这步，你不能通过xxx.github.io访问自己的博客的话，不妨稍等片刻（不超过五分钟）再重新尝试一下。</p>
<p>到此为止我们部署的博客，不仅可以在本地供自己查看，也可以在云端供所有人查看，博客的基础搭建完成，在后面的章节中我们会引入nexT对博客进行美化。</p>
<h2 id="四使用next主题进行美化">四、使用Next主题进行美化</h2>
<p>进入上面的界面后，我感觉非常的赏心悦目，但是坐在一旁的女朋友却并不这么想，于是问题就来了，难道只能用一种主题么？答案显然是否。Hexo拥有许多可配置的选项，其中就包括了更改<strong>主题</strong>，Next是使用人数最多的主题之一，所以出现问题的时候上网搜解决方案比较容易一些，所以我们使用了Next主题，在这一节中，我们介绍如何下载并更换主题，我们以Next为例。</p>
<h4 id="下载next">下载Next</h4>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blog/themes</span><br><span class="line">git clone https://github.com/iissnan/hexo-theme-next.git next</span><br></pre></td></tr></table></figure>
<h4 id="启用主题">启用主题</h4>
<p>进入blog文件夹，并且使用vim编辑_config.yml文件，将主题选项改为next</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blog</span><br><span class="line">sudo vim _config.yml</span><br></pre></td></tr></table></figure>
<p>值得注意的是，在以后的修改中我们不仅要修改blog文件夹下的_config.yml，也要修改主题包中的_config.yml：</p>
<ul>
<li><p>位于站点根目录下的_config.yml，主要包含 Hexo 本身的配置</p></li>
<li><p>另一份位于主题目录下的_config.yml，这份配置由主题作者提供，主要用于配置主题相关的选项</p></li>
</ul>
<h4 id="重新更新">重新更新</h4>
<p>注意，每次更新搞这几步就可以了，你也可以把它写成一个shell脚本，以后每次同步直接运行shell脚本即可。</p>
<p>当然，你也可以每次都运行下面的所有语句，脚本如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/blog</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">hexo s</span><br><span class="line">ehco "ok"</span><br></pre></td></tr></table></figure>
<p>运行完成后我们打开 http://localhost:4000 查看使用next主题的博客，效果如下</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200329213805633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>emmm，为什么感觉还不如原来的好看呢（逃</p>
<h3 id="五让它变得好看">五、让它变得好看</h3>
<p>我们同样是Next，别人的长这个样子：从这里进入，<a href="http://blog.maroom.cn/" target="_blank" rel="noopener">我的next安装就是借鉴的他的</a></p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200329213726210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>那肯定不得行，我们也要把自己的博客搞漂亮点，我们先对未来进行规划，以我自己为例：</p>
<ul>
<li><p>博客需要分类，我在同时学习不同方向的知识，需要分类功能才能有序的检索</p></li>
<li><p>我的博客不能叫Hexo，要叫SaiyuWang's Blog</p></li>
<li><p>我要上面那种两栏的，不要这种中间一条的</p></li>
<li><p>我要搞个小头像，下面还要放段话</p></li>
</ul>
<p>有了需求之后，我们开工，开工之前，我们再次重申<strong>如果过程中出现问题，你又不想找错的话，可以直接干掉blog文件夹从头再来，如果你害怕这种事情发生，那么你可以将过程中的操作写入shell脚本中，以达到一键回到上一步的目的。</strong></p>
<h4 id="调整主题">调整主题</h4>
<p>正如我们上文所说，我们不想要中间一大条的，我们想要的是像上面那张图里一样的，于是我们需要更改NexT的主题，来达到我们的目的。</p>
<p>通过阅读文档，我们知道Next支持三种主题：</p>
<ul>
<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li>
<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li>
<li>Pisces - 双栏 Scheme，小家碧玉似的清新</li>
</ul>
<p>看描述我们要的是Pisces主题，下面进行设置，各位也可以各取所需。正如上一章所说，我们要更改next内部的主题，所以我们对themes/next文件夹中的_config.yml进行更改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">sudo vim _config.yml</span><br></pre></td></tr></table></figure>
<p>搜索 scheme 关键字,你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 <code>#</code> 去除即可，这里我们选用Pisces。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Pisces</span></span><br></pre></td></tr></table></figure>
<p>这里科普一下，在vim中可以通过在命令模式下的</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:/<span class="built_in">string</span></span><br></pre></td></tr></table></figure>
<p>语句来对相应字符串进行搜索。更改完成后我们进行更新查看。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200329213832142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>这样的布局基本上符合我们的要求。</p>
<h4 id="设置语言">设置语言</h4>
<p>打开blog文件夹下的_config.yml，对语言进行设定。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/blog</span><br><span class="line">sudo vim _config.yml</span><br></pre></td></tr></table></figure>
<p>将<code>language</code> 设置成你所需要的语言，我们将语言设置为简体中文。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure>
<p>如果需要繁体中文，那么将zh-Hans更改为zh-tw或zh-hk即可（PS：我怀疑这个语言包的作者有台独意向 ）</p>
<h4 id="设置菜单">设置菜单</h4>
<h5 id="添加属性">添加属性</h5>
<p>正如前面所说，我们希望左边栏中的内容丰富起来，至少包括分类、Home、等功能，下面我们将通过修改themes/next文件夹下的_config.yml文件来达到丰富菜单的目的。</p>
<p>我们先打开themes/next中的_config.yml进行编辑：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">sudo vim _config.yml</span><br></pre></td></tr></table></figure>
<p>首先，我们设置主页和归档，进入_config.yml后，无需翻页直接对menu项目下面的属性进行更改，我们将该属性改为下面的样子：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || tags</span></span><br><span class="line">  <span class="comment">#categories: /categories/ || th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>
<p>保存后重新开始服务，可以看到网页变成了中文版，并且左边框中有了主页和归档两个选项。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200329213856960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>归档即我们博客更新的时间线，如下： <img src="https://img-blog.csdnimg.cn/20200329213905278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>接下来我们添加剩下的两个界面：</p>
<ul>
<li><p>标签页</p></li>
<li><p>分类页</p></li>
</ul>
<p>首先，在themes/next文件夹下的_config.yml中，进行如下更改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"> <span class="attr">home:</span> <span class="string">/</span></span><br><span class="line"> <span class="comment">#about: /about/ || user</span></span><br><span class="line"> <span class="attr">tags:</span> <span class="string">/tags</span></span><br><span class="line"> <span class="attr">categories:</span> <span class="string">/categories</span></span><br><span class="line"> <span class="attr">archives:</span> <span class="string">/archives</span></span><br><span class="line"> <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line"> <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line"> <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>
<p>之所以把他们放在下面添加，是因为前面的两个无需新建新的页面，而这两个需要新建界面才能够添加。接下来我们将分类放入左边的边框中，首先我们使用语句新建相应的面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page "categories"</span><br></pre></td></tr></table></figure>
<p>执行后，收到提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~/blog/source/categories/index.md</span><br></pre></td></tr></table></figure>
<p>这段提示中告诉我们在~/blog/source/categories/文件夹下生成了一个index.md（其实也生成了categories文件夹），我们现在进入这个路径下的index.md进行更改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/blog/source/categories/index.md</span><br></pre></td></tr></table></figure>
<p>在原有的基础上，增加type属性，type: "categories"</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-03-29 19:11:59</span><br><span class="line">type: "categories"</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>完成这些操作后，我们重启服务，进行查看，发现新的网站左边出现了标签、分类两个新的选项，点击进入分类，我们可以看到：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200329213924379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>而进入还没有定义的界面“标签”后，会报错。</p>
<p>分类功能已经基本完成，接下来我们新建一篇文章来进行测试。我将之前写好的文章放入其中，这是一篇关于计算机组成原理的文章，我们通过命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo hexo n "组成原理第一章"</span><br></pre></td></tr></table></figure>
<p>生成一篇名为：组成原理第一章的博客</p>
<p>它返回了提示信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~/blog/source/_posts/组成原理第一章.md</span><br></pre></td></tr></table></figure>
<p>我们可以看出它实际上是创建了一个markdown文件，来供我们编辑。</p>
<p>于是我们编辑这篇markdown文件，我们希望他分类在“组成原理”一类中。对文档进行编辑：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/blog/source/_posts/组成原理第一章.md</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 组成原理第一章</span><br><span class="line">date: 2020-03-29 19:31:12</span><br><span class="line">tags:</span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">- </span>组成原理</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">feff</span>&gt;</span></span># <span class="strong">**引言**</span></span><br><span class="line"></span><br><span class="line">自己看计组，顺便写个markdown玩玩，</span><br><span class="line">bulabula</span><br></pre></td></tr></table></figure>
<p>在这里我们要给文章分类的话，就需要在categories属性下注明他的分类，我们这里规定他的分类为：“组成原理”，我们重新生成博客，进行查看。再次进入分类，我们就发现多出来一个组成原理类，组成原理类中也有一片我们新建的文档。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200329213941340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>接下来我们仿制上面的思路，将tag列表加入，下面只贴代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page "tags",</span><br></pre></td></tr></table></figure>
<p>收到：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~/blog/source/tags/index.md</span><br></pre></td></tr></table></figure>
<p>编辑文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim ~/blog/source/tags/index.md</span><br></pre></td></tr></table></figure>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-03-29 19:41:58</span><br><span class="line">type: "tags"</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>向刚才的文章添加标签，刚才的文章储存在/blog/source/_posts文件夹中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 组成原理第一章</span><br><span class="line">date: 2020-03-29 19:31:12</span><br><span class="line">tags: </span><br><span class="line">- 组成原理</span><br><span class="line">- 大二下</span><br><span class="line">- 课内学习</span><br><span class="line">categories: </span><br><span class="line">- 组成原理</span><br><span class="line">---</span><br><span class="line">&lt;feff&gt;# **引言**</span><br><span class="line"></span><br><span class="line">自己看计组，顺便写个markdown玩玩</span><br></pre></td></tr></table></figure>
<p>重启，进入标签页面，我们可以看到新做出的改变。</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200329213953608.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>进入相应标签就可以找到相应的文章了。</p>
<h5 id="添加图标">添加图标</h5>
<p>最后，我们发现左边的这些栏目都没有图标，所以我们需要给他们加上图标：打开themes/next文件夹下的配置文件进行修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">sudo vim _config.yml</span><br></pre></td></tr></table></figure>
<p>找到menu_icon，进行修改：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Icon Mapping.</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">archive</span></span><br></pre></td></tr></table></figure>
<p>重启服务，观察，竟然没有出现图标，经过一番搜索后，我们在<a href="https://cassiellee.github.io/2019/12/25/Hexo%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E4%B9%8B%E8%8F%9C%E5%8D%95%E5%9B%BE%E6%A0%87%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">这里</a>找到了解决方案：</p>
<p>重新打开themes/next的配置文件，将menu属性下作如下更改，注意修改时大小写和空格要严格遵守。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>
<p>原来这是因为在新版的next中，图标也在menu一栏进行设置，重启服务后，效果如下：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200329214008348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<h5 id="给自己的博客换名字写标题等等">给自己的博客换名字、写标题等等</h5>
<p>首先先准备好图片，我在网上找了只皮卡丘，并且放到了图床中，使用的是<a href="https://imgchr.com/" target="_blank" rel="noopener">路过图床</a>，这只皮卡丘图像的连接是：https://imgchr.com/i/GZ3vOe</p>
<p>这次我们要编辑的是blog文件夹下的配置文件，打开编辑</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~\blog</span><br><span class="line">sudo vim _config.yml</span><br></pre></td></tr></table></figure>
<p>找到avatar属性，进行修改，将刚刚生成的图像链接加入</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="comment"># in theme directory(source/images): /images/avatar.gif</span></span><br><span class="line"><span class="comment"># in site  directory(source/uploads): /uploads/avatar.gif</span></span><br><span class="line"><span class="attr">avatar:</span> <span class="string">https://s1.ax1x.com/2020/03/29/GZ3vOe.jpg</span></span><br></pre></td></tr></table></figure>
<p>重新生成后我们的主页上出现了一只可爱的皮卡丘 <img src="https://img-blog.csdnimg.cn/20200329214014773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<h4 id="填写自己的信息和标语">填写自己的信息和标语</h4>
<p>我们发现，我们的博客还是叫Hexo，我们的名字还是叫John Doe，这显然是不合理的，所以我们要填写自己的信息；</p>
<p>我们打开blog下的配置文件，对其中的内容进行修改，我做出的修改如下</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">SaiyuWang's</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">'淡黄色长裙，蓬松的头发'</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Saiyu</span> <span class="string">Wang</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>
<p>到了这里，看到语言，又想diss一下这个作者，为什么繁体中文是zh-tw和zh-hk？？？</p>
<p>ok到此为止上面的所有需求都完成了。</p>
<h4 id="最后的需求填写自己的社交账号">最后的需求：填写自己的社交账号</h4>
<p>添加社交账号到左边栏</p>
<p>我们打开themes/next文件夹下的配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd themes/next</span><br><span class="line">sudo vim _config.yml</span><br></pre></td></tr></table></figure>
<p>找到social属性进行更改</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/wang-sy</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:wangsaiyu@cqu.edu.cn</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || goo</span></span><br></pre></td></tr></table></figure>
<p>重启查看</p>
<figure>
<img src="https://img-blog.csdnimg.cn/2020032921402096.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<h3 id="六未完成部分">六、未完成部分</h3>
<p>好了，至此位置，美化的部分基本上全部结束，接下来再加一些其他的功能，如评论、流量监测等等功能，这些功能我会在以后慢慢加。</p>
<p>经过观察，markdown中的数学公式渲染仍然有问题，目前还没有寻求解决方案。</p>
<h3 id="七补充">七、补充</h3>
<p>发布之后发现，右边好大一长串，于是赶紧上网找解决方法： 打开next下的配置文件，将auto_excerpt下的enable: 属性改为true即可.</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>组成原理第一章</title>
    <url>/2020/03/29/%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="引言"><strong>引言</strong></h1>
<p>自己看计组，顺便写个markdown玩玩，读的书叫《计算机组成与设计：硬件/软件接口》，作者目前大二，菜鸡一个，里面有部分观点完全出自于个人简介，如果出现了错误，还请各位大佬指正，关于指正可直接提交Issue，如长时间(3~4天)没有回复可以直接通过邮箱：wangsaiyu@cqu.edu.cn与我联系。</p>
<h1 id="第一章-计算机概要与技术"><strong>第一章 计算机概要与技术</strong></h1>
<h2 id="引言-1"><strong>1.1 引言</strong></h2>
<h3 id="计算应用的分类及其特性"><strong>1.1.1计算应用的分类及其特性</strong></h3>
<p>从智能家电到手机再到超级计算机，他们都使用了一套通用的硬件技术，但是这些不同的应用有着不同的设计需求，并以不同的方式通过硬件实现。总的来说，计算机主要包括以下三种类型的应用：</p>
<ul>
<li><strong>个人计算机(PC)：</strong>这是计算机最为人所知的应用方式，值得注意的是PC的出现只有短短的35年，但它推动了许多计算技术的革新。</li>
<li><strong>服务器(server)：</strong>服务器的制造技术和桌面计算机差不多，但是能够提供<strong>更强的计算、储存、I/O能力</strong>。通常情况下，发生故障时服务器的恢复代价远高于PC的恢复代价，因此<strong>服务器更加强调可靠性</strong>。</li>
<li><strong>嵌入式计算机(embedded computer)：</strong>这是数量最多的计算机，应用、性能领域非常广泛。嵌入式计算系统的设计目标是运行单一应用程序或者一组相关的应用程序，其设计目标是：<strong>运行单一应用程序或一组相关的应用程序</strong>，并且通常和硬件集成在一起以单一系统的方式一期交付给用户。(ps : 多bb一点，听去实习的学长说近几年来有很多硬件厂在做FPGA加速卷积运算代替GPU的work)</li>
</ul>
<p>嵌入式应用通常对成本或工号又严格限制。以音乐播放器为例，处理器只需要尽量快速的执行有限的功能，除此外，<strong>减低成本和功耗</strong>是最大的目标。除此之外，由于故障会使使用者感到不适，亦有可能导致安全事故，因此嵌入式计算机对故障非常敏感。在面向消费者的嵌入式应用中，一般通过简单设计来获得可靠性——其重点在于尽可能地保持一项功能的正常运转。</p>
<p>结合我的个人经历来看，在今天基于深度学习的计算机视觉方案已经广泛应用于各个领域。在今天，人脸识别等基于深度学习的技术愈发发达，就连宿舍楼底下都撞上了人脸识别的闸机（再也不敢逃课睡觉了），但是在极端追求速度、准确度、性价比的场景中，深度学习方法仍然无法应用，以立体匹配问题为例，基于互信息熵和动态规划法的SGM方法能够满足在CPU上运行时的<strong>高准确率、实时性</strong>要求，与之对应的深度学习方法：GA-Net(注意，不是GAN)则需要6.5G显存、1080ti / Titan GPUs才能够跑得起，随着各种神仙算法的出现，网络越来越深需要的计算资源也越来越多，这里就反映出了当下深度学习方法在嵌入式系统的应用中存在的不足:</p>
<ul>
<li><strong>计算资源不足：</strong>在不提高成本的情况下很难满足深度学习方法的需求</li>
<li><strong>计算速度不够：</strong>以智能车为例，为应对复杂的路况，周边信息的刷新率不能过低，但是现在深度学习领域的杰出方法的运行速度却不能得到保证，例如，在NVIDIA Titan X显卡环境下，Semi-Global Matching on the GPU可以达到886帧每秒，而深度学习方法仅能达到10.2帧每秒。</li>
<li><strong>正确率相差不多：</strong>SGM和GCN的正确率相差不是很多，都可以满足实用的需求。</li>
</ul>
<h3 id="欢迎来到后pc时代"><strong>1.1.2 欢迎来到后PC时代</strong></h3>
<p><strong>PMD：</strong>技术的持续进步给计算机硬件带来了革命性的变化，对整个信息技术工业产生了震动，随时代的发展，<strong>个人移动设备</strong>(Personal Mobile Device, PMD)正在逐步代替PC，当今的PMD可以是智能手机或平板电脑，而明天的PMD可能会包括电子眼镜等。</p>
<p><strong>云计算：</strong>(cloud computing)替代了传统的服务器，它依赖于称为<strong>仓储规模计算机(Ware-house Scale Computer, WSC)</strong>的举行数据中心，一些公司可以租用其中一部分为PMD提供软件服务，而不用自己构建WSC，PMD与WSC是硬件工业的革命类似，通过云计算实现的<strong>软件即服务</strong>是软件工业的革命。</p>
<p>举个例子，在做一些项目的时候，我们需要用到很好的显卡，比如说上文中提到的<strong>GTX Titan</strong>，20,000￥起步，很显然，这种显卡不是我们能买的起的。但是我们可以租借云GPU服务器来满足我们的计算需求，ECS 的GPU 计算型，最便宜的 P4显卡1781.25 元/月，虽然价格也很贵，但是也是在我们能够支付得起的范围内满足我们的计算需求了。</p>
<hr />
<h2 id="计算机系统机构中的8个伟大思想">1.2计算机系统机构中的8个伟大思想</h2>
<ul>
<li><p><strong>面向摩尔定律的设计：</strong>摩尔定律指出单芯片上的集成度每18~24个月会翻一番</p></li>
<li><p><strong>使用抽象简化设计：</strong>架构师和程序眼必须发明能够提高产量的技术，否则设计实践也会想资源规模一样按照摩尔定律增长，为解决这一问题使用的主要技术就是<strong>抽象</strong>来表达不同设计层级，在高层次中看不到低层次的细节，只能看到一个简化的模型。就像高级语言的出现一样，在使用numpy时，我们的代码经历了python-&gt;C-&gt;汇编-&gt;二进制码的过程。</p></li>
<li><p><strong>加速大概率事件：</strong>相对于优化小概率事件，优化大概率事件的难度低，获得的收益高</p></li>
<li><p><strong>通过并行提高性能：</strong>没什么好说的</p></li>
<li><p><strong>通过流水线提高性能：</strong>我们在软件开发的时候也经常能听到相似的东西:<strong>高内聚，低耦合</strong>。说白了意思就是：把复杂的问题进行拆分，让每一个模块专精于某一个小的方向，这样就可以提高效率。在知乎上看到一个回答感觉很贴切，先贴上来，如图： <img src="https://img-blog.csdnimg.cn/2020030211254483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p></li>
<li><p><strong>通过预测提高性能：</strong>在某些情况下，如果假定从误预测恢复执行代价不高并且预测准确率相对较高，则通过猜测的方式提前开始某些操作，要比等到确切知道这些操作应该启动时才开始要快</p></li>
<li><p><strong>储存器层次：</strong>储存器的速度通常影响性能、储存器的容量限制了解题的规模、当今计算机系统中储存器的代价占了主要部分，人们希望储存器速度更快、容量更大、价格更便宜。设计师们发现可以通过储存器层次来解决这一问题，我们可以将其结构理解为一个金字塔，金字塔下方的储存单元有着<strong>容量大、价格便宜但计算速度较慢</strong>的特点，随着金字塔上层级的升高<strong>计算速度不断升高，但价格也愈发昂贵</strong></p></li>
<li><p><strong>通过冗余提高可靠性：</strong>任何一个物理器件都有可能失效，因此可以通过使用冗余部件的方式提高系统的可靠性</p></li>
</ul>
<hr />
<h2 id="程序概念入门两个抽象的例子"><strong>1.3 程序概念入门——两个抽象的例子</strong></h2>
<h3 id="软件层次"><strong>软件层次</strong></h3>
<p>计算机中的硬件只能执行极为低级的简单指令，从复杂的应用程序，到简单的指令需要经过几个软件层次来将复杂的高层次操作<strong>逐步解释或翻译</strong>成简单的计算机指令。下面的图中给出了这些软件的层次结构，外层是应用软件，中心是硬件，系统软件位于两者之间：</p>
<figure>
<img src="https://img-blog.csdnimg.cn/2020030211255338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>操作软件有很多种，其中两种对于今天的计算机来说是必需的：</p>
<ul>
<li><strong>操作系统</strong>：是<strong>用户程序和硬件</strong>之间的接口，为用户提供各种服务和监护功能，其最重要的作用是：
<ul>
<li>处理基本的**输入输出操作</li>
<li>分配外存和内存</li>
<li>为多个应用程序提供共享计算机资源的服务</li>
</ul></li>
<li><strong>编译程序</strong>：把用<strong>高级语言编写</strong>的程序<strong>翻译成硬件能执行的指令</strong></li>
</ul>
<h3 id="从高级语言到硬件语言"><strong>从高级语言到硬件语言</strong></h3>
<p>第一代程序员是直接使用二进制数与计算机通信的，这是一项非常乏味的工作。所以他们很快发明了助记符，最初从助记符到二进制是通过手工翻译完成的，其过程过于繁琐，于是设计人员开发了<strong>汇编程序</strong>，可以将助记符形式的指令自动翻译成对应的二进制，但是汇编语言需要程序员写出计算机执行的每条指令，要求程序员像计算机一样思考，<strong>高级编程语言</strong>及其编译程序大大的提高了软件的生产力。</p>
<h2 id="硬件概念入门"><strong>1.4 硬件概念入门</strong></h2>
<p>控制一台计算机的基础硬件都要完成相同的基本功能：<strong>输入数据、输出数据、处理数据、储存数据</strong>。计算机是由完成<strong>输入、输出、处理和储存数据的五个部件构成的</strong>，其中最关键的两个部件是：</p>
<ul>
<li><strong>输入设备(input device)</strong>如：麦克风、鼠标等</li>
<li><strong>输出设备(output device)</strong>如：扬声器、显示器等</li>
</ul>
<h2 id="功率趋势与功耗墙">1.5功率趋势与功耗墙</h2>
<p><img src="https://img-blog.csdnimg.cn/20200302112645260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" /></p>
<p><span class="math display">\[CPU功耗 = \frac{1}{2}负载电容 * 工作电压^2 * 开关频率\]</span></p>
<p>自1982年以来，时钟频率增长了一千倍不知，但功耗仅上升了30倍，这是因为能耗是电压平方的函数，能够通过降低电压来将大幅减少功耗，20多年来，电压从5V降到了1V，所以能耗仅上升了30倍。</p>
<h3 id="从单处理器向多处理器的转变">从单处理器向多处理器的转变</h3>
<p>从06年起，所有桌面和服务器公司都在单片位处理器中加入了多个处理器，以求更大的吞吐率，而不再继续追求降低单个程序运行在单个处理器上的响应时间。</p>
<p>那么为什么要才用多核的设计呢？</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200302112700248.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>对于一个大核，为了达到两份的效率，需要付出4份的功耗 <img src="https://img-blog.csdnimg.cn/20200302112707482.png" alt="在这里插入图片描述" /></p>
<p>对于一个小核，为了达到一份效率，只需要付出一份的功耗即可。小核达到大核<span class="math inline">\(\frac{1}{2}\)</span>的效率，却只花费了<span class="math inline">\(\frac{1}{4}\)</span>的功耗。 <img src="https://img-blog.csdnimg.cn/20200302112713327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>将原有的大核拆分成四个小核，在并行情况良好的情况下，可以在功耗与大核相同的情况下，效率达到原来的2倍。 <img src="https://img-blog.csdnimg.cn/20200302112719830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>可以看到，在红线处， 小核的效能和大核的一样，但是小核的功耗确实大核的一半，如果一个手机的内部同时有一个小核、一个大核，那么在处理日常事项时，使用小核，关闭大核。而在处理繁杂任务时使用大核，就可以极大的延长待机时间。</p>
<p>为什么大核的功耗是小核的四倍，效率却只有小核的两倍呢？</p>
<figure>
<img src="https://img-blog.csdnimg.cn/20200302112726473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>大核的功能单元多，流水线深度也较深，所以效率较高，但也正因如此，如果分支预测出错，需要进行回滚，那么浪费的能量也较多，相同情况下， 小核浪费掉的能量也少很多，所以小核可以具有更高的性能/功耗比。</p>
<h2 id="计算机性能的评价">1.6计算机性能的评价</h2>
<p>影响计算机性能的因素</p>
<ul>
<li><strong>算法：</strong>算法决定了任务执行操作的数量</li>
<li><strong>编程语言、编译器、指令集架构：</strong>影响了机器指令的数量</li>
<li><strong>处理器和存储系统</strong>：决定了某一条语句的执行速度</li>
<li><strong>I/O系统</strong>：决定了执行I/O操作的时候需要的时间以及系统执行调用等操作时需要的时间</li>
</ul>
<h3 id="计算机性能评价指标响应时间与吞吐率">计算机性能评价指标——响应时间与吞吐率</h3>
<ul>
<li><strong>响应时间：</strong>给定一任务，需要的执行时间</li>
<li><strong>吞吐率：</strong>表示单位时间内完成的任务数量</li>
</ul>
<p>定义计算机性能公式：</p>
<p><span class="math display">\[P_X = 性能_x = \frac{1}{响应时间}\]</span></p>
<p>要对比两台计算机的性能可以对比他们的相对性能：</p>
<p><span class="math display">\[\frac{性能_x}{性能_y} = \frac{响应时间_y}{响应时间_x}\]</span></p>
<h3 id="度量任务执行的时间">度量任务执行的时间</h3>
<ul>
<li><strong>响应时间(Elapsed time)：</strong>也叫墙上时钟时间(wall clock time)表示完成任务所需要的总时间，受完成任务的处理时间、IO时间、操作系统消耗的时间、不同任务之间调度的时间等等，这种度量方法并不准确。</li>
<li><strong>CPU时间(CPU time)：</strong>只表示在CPU上面的时间刨去了I/O、或运行其他程序的时间等。</li>
</ul>
<p>计算<strong>CPU时间</strong>的方法，相关变量：</p>
<ul>
<li><strong>时钟周期、时钟频率：</strong><span class="math display">\[时钟周期 = \frac{1}{时钟频率}\]</span></li>
</ul>
<p>有公式:</p>
<p><span class="math display">\[CPU时间 = CPU时钟数 * 时钟周期 = \frac{时钟数}{时钟频率}\]</span></p>
<p>由此可见，想要降低CPU时间，需要升高时钟频率，同时减小时钟数。</p>
<h3 id="指令条数instruction-count-与-cpi">指令条数(Instruction Count) 与 CPI</h3>
<p><span class="math display">\[机器周期数 = 指令条数 * 每条指令需要的机器周期数\]</span></p>
<p><span class="math display">\[CPU时间 = 指令条数 * CPI * 时钟周期 = \frac{指令条数 * CPI}{时钟频率}\]</span></p>
<ul>
<li><strong>程序的指令条数：</strong>取决于算法、编程语言、编译器、指令集架构</li>
<li><strong>CPI：</strong>由CPU性能决定，不同的指令有不同的CPI，加法、除法等指令CPI不同</li>
</ul>
<p><span class="math display">\[时钟周期 = \Sigma^{n}_{i=1} (CPI_i * 指令条数_i)\]</span></p>
<p><span class="math display">\[CPI_i = \frac{时钟周期}{指令条数} =  \Sigma_{i=1}^{n}CPI *\frac{指令条数_i}{总指令条数}\]</span></p>
<p><strong>关于性能的总结</strong>:<span class="math display">\[\frac{秒数}{程序} = \frac{指令数}{程序}\frac{时钟周期数}{指令数}\frac{秒数}{时钟周期数}\]</span> <img src="https://img-blog.csdnimg.cn/20200302112742186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>从图中我们可以看出不同的因素对计算机性能的影响，可以看出：</p>
<ul>
<li>软件层主要通过影响<strong>指令数和CPI</strong>来影响计算机性能</li>
<li>硬件层主要通过影响<strong>时钟周期和CPI</strong>来影响计算机性能</li>
</ul>
<p>对于1982年的程序员来说，写好一个程序之后什么都不用干，到了今天，他的程序性能会比当年高一千倍不止，这是因为计算机<strong>硬件的不断发展</strong>，但是今天，计算机不再追求降低单个程序运行在单个处理器上的响应时间，也就是说我们想要改善计算机运行速度，应当着重从软件层次入手，优化算法、优化编译程序、指令集架构等。</p>
<h3 id="综合评价cpu性能方法spec-cpu">综合评价CPU性能方法——SPEC CPU</h3>
<figure>
<img src="https://img-blog.csdnimg.cn/20200302112750759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>在这个测试表中，对CPU在固定环境下，进行了不同应用场景的测试，如字符串处理、围棋游戏、视频压缩等，并且记录下来了完成任务的时间：<span class="math inline">\(Exce\_time\)</span>，将其与<span class="math inline">\(Ref\_time\)</span>进行对比，得到了<span class="math inline">\(SPECratio\)</span>有公式:<span class="math inline">\(SPECratio = \frac{Ref\_time}{Exce\_time}\)</span></p>
<p>总体性能评价使用了几何平均公式：</p>
<p><span class="math display">\[Geometric\_mean = \sqrt[n]{\Pi_{i=1}^n 执行时间比_i}\]</span></p>
<h2 id="关于计算机性能改进的指标">1.7 关于计算机性能改进的指标</h2>
<h3 id="阿姆达尔定理">阿姆达尔定理</h3>
<p><span class="math display">\[改进后的执行时间 = \frac{受改进影响的执行时间}{改进量} + 不受影响的执行时间\]</span></p>
<p>如果乘法运算占总负载的80%，那么无论怎样改进算法，也无法让整体性能提高5倍。这是因为仅提升乘法运算速度，不会影响其他的执行时间。</p>
<p>同时阿姆达尔定理也揭示了：在改进计算机的时候，应当优先改进</p>
<h3 id="用mips度量计算机性能已过时">用MIPS度量计算机性能（已过时）</h3>
<p>MIPS：执行 MIPS百万条指令/秒</p>
<p><span class="math display">\[MIPS = \frac{指令数}{执行时间 * 10^6}\]</span></p>
<p>可以看出在今天，MIPS已经不能正确的的描述CPU的运算能力，这是因为今天的计算机指令较为复杂，不同指令之间的CPI相差较大，所以不能用指令数来简单的代表总任务量。</p>
<h2 id="性能评价功耗问题">1.8 性能评价——功耗问题</h2>
<p>现如今，计算资源消耗的能量占了全世界能耗的2%， 如今能耗问题成为了一个受关注的点。</p>
<h3 id="spec功耗评价">SPEC功耗评价</h3>
<figure>
<img src="https://img-blog.csdnimg.cn/20200302112757684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE3ODUzNjEz,size_16,color_FFFFFF,t_70" alt="" /><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>SPEC采用单个的数字来进行归纳，称为<span class="math inline">\(overall \ ssj\_ops\ per\ watt\)</span></p>
<p><span class="math display">\[overall\ ssj\_ops\ per\ watt = \frac{\Sigma_{i=0}^{10}ssj\_ops_i}{\Sigma_{i=0}^{10}{power_i}}\]</span></p>
<p>值得注意的是，10%负载并不代表10%消耗，可以发现，负载越高功耗比越高。</p>
<hr />
]]></content>
      <categories>
        <category>组成原理</category>
      </categories>
      <tags>
        <tag>大二下</tag>
        <tag>课内学习</tag>
        <tag>组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/29/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
